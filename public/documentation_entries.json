[
  {
    "id": 56,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 57,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 1,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "XeroContactSync",
    "title": "Xero Sync Creates Duplicate Contacts for Name Variations",
    "status": "by_design",
    "severity": "medium",
    "first_reported": "2025-09-20",
    "last_occurred": "2025-11-10",
    "fixed_date": null,
    "scenario": "Xero contact \"ABC Plumbing Pty Ltd\" and existing local contact \"ABC Plumbing\" are treated as different contacts during sync, creating duplicates.",
    "root_cause": "Fuzzy match threshold set at 85% similarity doesn't catch common business suffix variations like \"Pty Ltd\" vs no suffix, \"Trading As\" vs legal name, ampersand vs \"and\".",
    "solution": "1. Manual Merge: Use POST /api/v1/contacts/merge. 2. Preventive: Set tax_number (ABN/ACN) - Priority 2 matching catches these. 3. Workaround: Manually link via POST /api/v1/contacts/:id/link_xero_contact",
    "prevention": "Always set ABN for Australian businesses to enable Priority 2 matching",
    "metadata": {
      "tags": [
        "xero",
        "duplicate",
        "fuzzy-matching"
      ]
    },
    "search_text": "Xero Sync Creates Duplicate Contacts for Name Variations XeroContactSync Xero contact \"ABC Plumbing Pty Ltd\" and existing local contact \"ABC Plumbing\" are treated as different contacts during sync, creating duplicates. Fuzzy match threshold set at 85% similarity doesn't catch common business suffix variations like \"Pty Ltd\" vs no suffix, \"Trading As\" vs legal name, ampersand vs \"and\". 1. Manual Merge: Use POST /api/v1/contacts/merge. 2. Preventive: Set tax_number (ABN/ACN) - Priority 2 matching catches these. 3. Workaround: Manually link via POST /api/v1/contacts/:id/link_xero_contact Always set ABN for Australian businesses to enable Priority 2 matching",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Xero contact \"ABC Plumbing Pty Ltd\" and existing local contact \"ABC Plumbing\" are treated as different contacts during sync, creating duplicates.",
    "details": "Fuzzy match threshold set at 85% similarity doesn't catch common business suffix variations like \"Pty Ltd\" vs no suffix, \"Trading As\" vs legal name, ampersand vs \"and\".",
    "examples": null,
    "recommendations": "1. Manual Merge: Use POST /api/v1/contacts/merge. 2. Preventive: Set tax_number (ABN/ACN) - Priority 2 matching catches these. 3. Workaround: Manually link via POST /api/v1/contacts/:id/link_xero_contact",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 2,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "ContactMerge",
    "title": "Contact Merge Fails When Supplier Has Active Purchase Orders",
    "status": "fixed",
    "severity": "high",
    "first_reported": "2025-11-04",
    "last_occurred": "2025-11-04",
    "fixed_date": "2025-11-05",
    "scenario": "Attempting to merge two supplier contacts fails with foreign key constraint error when source supplier has purchase orders.",
    "root_cause": "Merge controller was updating PricebookItem and PriceHistory foreign keys, but forgot to update PurchaseOrder.supplier_id.",
    "solution": "Added missing PurchaseOrder update: PurchaseOrder.where(supplier_id: source.id).update_all(supplier_id: target.id)",
    "prevention": "Always check ALL foreign key relationships when implementing merge features",
    "metadata": {
      "tags": [
        "merge",
        "purchase-orders"
      ],
      "pr_url": "https://github.com/trapid/pull/123"
    },
    "search_text": "Contact Merge Fails When Supplier Has Active Purchase Orders ContactMerge Attempting to merge two supplier contacts fails with foreign key constraint error when source supplier has purchase orders. Merge controller was updating PricebookItem and PriceHistory foreign keys, but forgot to update PurchaseOrder.supplier_id. Added missing PurchaseOrder update: PurchaseOrder.where(supplier_id: source.id).update_all(supplier_id: target.id) Always check ALL foreign key relationships when implementing merge features",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Attempting to merge two supplier contacts fails with foreign key constraint error when source supplier has purchase orders.",
    "details": "Merge controller was updating PricebookItem and PriceHistory foreign keys, but forgot to update PurchaseOrder.supplier_id.",
    "examples": null,
    "recommendations": "Added missing PurchaseOrder update: PurchaseOrder.where(supplier_id: source.id).update_all(supplier_id: target.id)",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 3,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "XeroContactSync",
    "title": "Primary Contact Person Not Enforced on Xero Sync",
    "status": "fixed",
    "severity": "low",
    "first_reported": "2025-10-12",
    "last_occurred": "2025-10-12",
    "fixed_date": "2025-10-15",
    "scenario": "After Xero contact sync, contacts end up with multiple is_primary = true contact persons.",
    "root_cause": "XeroContactSyncService was creating ContactPerson records directly without triggering callbacks",
    "solution": "Changed to use single record creation which triggers callbacks",
    "prevention": "Added validation test in contact_person_spec.rb",
    "metadata": {
      "tags": [
        "xero",
        "contact-person",
        "callbacks"
      ]
    },
    "search_text": "Primary Contact Person Not Enforced on Xero Sync XeroContactSync After Xero contact sync, contacts end up with multiple is_primary = true contact persons. XeroContactSyncService was creating ContactPerson records directly without triggering callbacks Changed to use single record creation which triggers callbacks Added validation test in contact_person_spec.rb",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "After Xero contact sync, contacts end up with multiple is_primary = true contact persons.",
    "details": "XeroContactSyncService was creating ContactPerson records directly without triggering callbacks",
    "examples": null,
    "recommendations": "Changed to use single record creation which triggers callbacks",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 9,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "Contact",
    "title": "Deleting Contact Doesn't Clear Related Supplier References",
    "status": "fixed",
    "severity": "high",
    "first_reported": "2025-09-25",
    "last_occurred": null,
    "fixed_date": "2025-09-28",
    "scenario": "Deleting a contact that has linked suppliers leaves orphaned SupplierContact records",
    "root_cause": "Missing dependent: :destroy on has_many :supplier_contacts association",
    "solution": "Added cascade delete: has_many :supplier_contacts, dependent: :destroy",
    "prevention": "Added model test to verify cascade deletion",
    "metadata": {
      "tags": [
        "cascade-delete",
        "associations"
      ]
    },
    "search_text": "Deleting Contact Doesn't Clear Related Supplier References Contact Deleting a contact that has linked suppliers leaves orphaned SupplierContact records Missing dependent: :destroy on has_many :supplier_contacts association Added cascade delete: has_many :supplier_contacts, dependent: :destroy Added model test to verify cascade deletion",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Deleting a contact that has linked suppliers leaves orphaned SupplierContact records",
    "details": "Missing dependent: :destroy on has_many :supplier_contacts association",
    "examples": null,
    "recommendations": "Added cascade delete: has_many :supplier_contacts, dependent: :destroy",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 29,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Race Condition in PO Number Generation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Two users create POs simultaneously → potential for duplicate PO numbers.",
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Race Condition in PO Number Generation bug Two users create POs simultaneously → potential for duplicate PO numbers. Two users create POs simultaneously → potential for duplicate PO numbers.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Two users create POs simultaneously → potential for duplicate PO numbers.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 30,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Payment Status Calculation Confusion",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User sets `amount_paid = $990` on PO with `total = $1000`.\nPayment status shows \"Part Payment\" instead of \"Complete\".",
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Status Calculation Confusion bug User sets `amount_paid = $990` on PO with `total = $1000`.\nPayment status shows \"Part Payment\" instead of \"Complete\". User sets `amount_paid = $990` on PO with `total = $1000`.\nPayment status shows \"Part Payment\" instead of \"Complete\".",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User sets `amount_paid = $990` on PO with `total = $1000`.\nPayment status shows \"Part Payment\" instead of \"Complete\".",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 31,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Smart Lookup Returns Wrong Supplier",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User expects \"ABC Supplier\" but system selects \"XYZ Supplier\" for item.",
    "root_cause": null,
    "solution": "1. Check category default: Settings → Price Books → Categories\n2. Update default supplier if needed\n3. Or manually override after smart lookup",
    "prevention": null,
    "metadata": {},
    "search_text": "Smart Lookup Returns Wrong Supplier bug User expects \"ABC Supplier\" but system selects \"XYZ Supplier\" for item. 1. Check category default: Settings → Price Books → Categories\n2. Update default supplier if needed\n3. Or manually override after smart lookup User expects \"ABC Supplier\" but system selects \"XYZ Supplier\" for item.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User expects \"ABC Supplier\" but system selects \"XYZ Supplier\" for item.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 50,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:49 +1000",
    "updated_at": "2025-11-16 21:03:49 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 51,
    "chapter_number": 12,
    "chapter_name": "OneDrive Integration",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:49 +1000",
    "updated_at": "2025-11-16 21:03:49 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 4,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "PortalAuth",
    "title": "Portal Password Reset Loop for Locked Accounts",
    "status": "fixed",
    "severity": "medium",
    "first_reported": "2025-10-28",
    "last_occurred": "2025-10-28",
    "fixed_date": "2025-11-01",
    "scenario": "Portal users locked out after 5 failed attempts cannot reset password because password reset endpoint also checks locked? status.",
    "root_cause": "Password reset endpoint was checking lockout status, preventing locked users from resetting passwords",
    "solution": "Modified password reset endpoint to skip lockout check and clear locked_until and failed_login_attempts on successful reset",
    "prevention": "Only check lockout on login attempts, not password resets",
    "metadata": {
      "tags": [
        "portal",
        "password-reset",
        "lockout"
      ]
    },
    "search_text": "Portal Password Reset Loop for Locked Accounts PortalAuth Portal users locked out after 5 failed attempts cannot reset password because password reset endpoint also checks locked? status. Password reset endpoint was checking lockout status, preventing locked users from resetting passwords Modified password reset endpoint to skip lockout check and clear locked_until and failed_login_attempts on successful reset Only check lockout on login attempts, not password resets",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Portal users locked out after 5 failed attempts cannot reset password because password reset endpoint also checks locked? status.",
    "details": "Password reset endpoint was checking lockout status, preventing locked users from resetting passwords",
    "examples": null,
    "recommendations": "Modified password reset endpoint to skip lockout check and clear locked_until and failed_login_attempts on successful reset",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 5,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "ContactRelationship",
    "title": "Bidirectional Relationship Cascade Causes Infinite Loop",
    "status": "by_design",
    "severity": "critical",
    "first_reported": "2025-09-15",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Creating a relationship triggers after_create which creates the reverse, which triggers another after_create, leading to infinite recursion.",
    "root_cause": "Bidirectional relationships need to create reverse relationships automatically without protection",
    "solution": "Use Thread-local flag to prevent recursion: Thread.current[:creating_reverse_relationship]",
    "prevention": "This pattern MUST be used for all bidirectional associations. See BIBLE RULE #3.2",
    "metadata": {
      "tags": [
        "relationships",
        "infinite-loop",
        "recursion"
      ],
      "related_rule": "RULE #3.2"
    },
    "search_text": "Bidirectional Relationship Cascade Causes Infinite Loop ContactRelationship Creating a relationship triggers after_create which creates the reverse, which triggers another after_create, leading to infinite recursion. Bidirectional relationships need to create reverse relationships automatically without protection Use Thread-local flag to prevent recursion: Thread.current[:creating_reverse_relationship] This pattern MUST be used for all bidirectional associations. See BIBLE RULE #3.2",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Creating a relationship triggers after_create which creates the reverse, which triggers another after_create, leading to infinite recursion.",
    "details": "Bidirectional relationships need to create reverse relationships automatically without protection",
    "examples": null,
    "recommendations": "Use Thread-local flag to prevent recursion: Thread.current[:creating_reverse_relationship]",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 6,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "ContactActivity",
    "title": "Contact Activity Log Growing Too Large (>10k Records)",
    "status": "monitoring",
    "severity": "low",
    "first_reported": "2025-10-20",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Contacts with high Xero sync frequency accumulate thousands of ContactActivity records, slowing down activities endpoint",
    "root_cause": "No archival or pagination for activity logs",
    "solution": "Activities endpoint limits to 50 most recent records",
    "prevention": "Consider adding archival for activities older than 6 months, implement pagination",
    "metadata": {
      "tags": [
        "performance",
        "activity-log"
      ],
      "max_records": 8432
    },
    "search_text": "Contact Activity Log Growing Too Large (>10k Records) ContactActivity Contacts with high Xero sync frequency accumulate thousands of ContactActivity records, slowing down activities endpoint No archival or pagination for activity logs Activities endpoint limits to 50 most recent records Consider adding archival for activities older than 6 months, implement pagination",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Contacts with high Xero sync frequency accumulate thousands of ContactActivity records, slowing down activities endpoint",
    "details": "No archival or pagination for activity logs",
    "examples": null,
    "recommendations": "Activities endpoint limits to 50 most recent records",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 7,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "PortalUser",
    "title": "Portal User Email Validation Too Strict",
    "status": "fixed",
    "severity": "low",
    "first_reported": "2025-10-22",
    "last_occurred": null,
    "fixed_date": "2025-10-25",
    "scenario": "Portal user creation fails for valid email addresses with plus addressing or subdomains",
    "root_cause": "Email validation regex was overly restrictive",
    "solution": "Changed to use Ruby's built-in URI::MailTo::EMAIL_REGEXP",
    "prevention": "Use standard email validation libraries instead of custom regex",
    "metadata": {
      "tags": [
        "portal",
        "email-validation"
      ]
    },
    "search_text": "Portal User Email Validation Too Strict PortalUser Portal user creation fails for valid email addresses with plus addressing or subdomains Email validation regex was overly restrictive Changed to use Ruby's built-in URI::MailTo::EMAIL_REGEXP Use standard email validation libraries instead of custom regex",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Portal user creation fails for valid email addresses with plus addressing or subdomains",
    "details": "Email validation regex was overly restrictive",
    "examples": null,
    "recommendations": "Changed to use Ruby's built-in URI::MailTo::EMAIL_REGEXP",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 8,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "ContactsController",
    "title": "Contact Type Filter Returns Wrong Results for \"Both\"",
    "status": "fixed",
    "severity": "medium",
    "first_reported": "2025-10-15",
    "last_occurred": null,
    "fixed_date": "2025-10-18",
    "scenario": "Filtering contacts with ?type=both returns contacts that are customer OR supplier instead of customer AND supplier",
    "root_cause": "Controller was using array overlap check (&&) instead of array containment (@>)",
    "solution": "Changed to array containment operator: contact_types @> ARRAY['customer', 'supplier']::varchar[]",
    "prevention": "Use @> for AND logic on PostgreSQL arrays, && for OR logic",
    "metadata": {
      "tags": [
        "filtering",
        "postgresql",
        "arrays"
      ]
    },
    "search_text": "Contact Type Filter Returns Wrong Results for \"Both\" ContactsController Filtering contacts with ?type=both returns contacts that are customer OR supplier instead of customer AND supplier Controller was using array overlap check (&&) instead of array containment (@>) Changed to array containment operator: contact_types @> ARRAY['customer', 'supplier']::varchar[] Use @> for AND logic on PostgreSQL arrays, && for OR logic",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Filtering contacts with ?type=both returns contacts that are customer OR supplier instead of customer AND supplier",
    "details": "Controller was using array overlap check (&&) instead of array containment (@>)",
    "examples": null,
    "recommendations": "Changed to array containment operator: contact_types @> ARRAY['customer', 'supplier']::varchar[]",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 10,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "XeroContactSync",
    "title": "Xero Sync Rate Limiting Causes Timeout on Large Contact Lists",
    "status": "by_design",
    "severity": "low",
    "first_reported": "2025-11-08",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Syncing 500+ contacts from Xero takes over 10 minutes due to 1.2-second delay, causing Heroku timeout",
    "root_cause": "Xero API has 60 requests/minute limit. With 500 contacts sync takes 600 seconds",
    "solution": "Run Xero sync as background job: XeroContactSyncJob.perform_later",
    "prevention": "Large syncs must use background jobs",
    "metadata": {
      "tags": [
        "xero",
        "rate-limiting",
        "background-jobs"
      ]
    },
    "search_text": "Xero Sync Rate Limiting Causes Timeout on Large Contact Lists XeroContactSync Syncing 500+ contacts from Xero takes over 10 minutes due to 1.2-second delay, causing Heroku timeout Xero API has 60 requests/minute limit. With 500 contacts sync takes 600 seconds Run Xero sync as background job: XeroContactSyncJob.perform_later Large syncs must use background jobs",
    "created_at": "2025-11-16 08:43:13 +1000",
    "updated_at": "2025-11-16 08:43:13 +1000",
    "entry_type": "bug",
    "description": "Syncing 500+ contacts from Xero takes over 10 minutes due to 1.2-second delay, causing Heroku timeout",
    "details": "Xero API has 60 requests/minute limit. With 500 contacts sync takes 600 seconds",
    "examples": null,
    "recommendations": "Run Xero sync as background job: XeroContactSyncJob.perform_later",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 52,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 11,
    "chapter_number": 0,
    "chapter_name": "System-Wide Knowledge",
    "component": null,
    "title": "Unmigrated Schema Changes (working_days column)",
    "status": "fixed",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "The `working_days` column was added manually to `company_settings` table without creating a migration file. When the test tried to use `working_days`, it failed with \"undefined method\" despite the column existing in the database.",
    "root_cause": "1. Column was added directly to staging database (via console or manual SQL)\n2. No migration file created to track this schema change\n3. ActiveRecord's schema cache didn't recognize the column\n4. Test failed: `undefined method 'working_days' for an instance of CompanySetting`",
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Unmigrated Schema Changes (working_days column) bug The `working_days` column was added manually to `company_settings` table without creating a migration file. When the test tried to use `working_days`, it failed with \"undefined method\" despite the column existing in the database. 1. Column was added directly to staging database (via console or manual SQL)\n2. No migration file created to track this schema change\n3. ActiveRecord's schema cache didn't recognize the column\n4. Test failed: `undefined method 'working_days' for an instance of CompanySetting` The `working_days` column was added manually to `company_settings` table without creating a migration file. When the test tried to use `working_days`, it failed with \"undefined method\" despite the column existing in the database. Manual column addition bypassed Rails migration tracking, causing schema drift between what ActiveRecord knows and what's in the database.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "The `working_days` column was added manually to `company_settings` table without creating a migration file. When the test tried to use `working_days`, it failed with \"undefined method\" despite the column existing in the database.",
    "details": "Manual column addition bypassed Rails migration tracking, causing schema drift between what ActiveRecord knows and what's in the database.",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 12,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": "ScheduleTemplateRows",
    "title": "Nil User in Authorization Check",
    "status": "fixed",
    "severity": "critical",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User attempts to update schedule template rows via Gantt drag-and-drop. API returns error:",
    "root_cause": "1. `ApplicationController#authorize_request` decoded JWT token but didn't validate that `@current_user` was set\n2. If JWT was missing/invalid, `decoded` would be `nil` → `@current_user` remained `nil`\n3. No error was raised - request continued\n4. When `check_can_edit_templates` called `@current_user.can_create_templates?`, it failed with NoMethodError",
    "solution": null,
    "prevention": "- ALWAYS use safe navigation (`&.`) when calling methods on `@current_user`\n- Ensure `authorize_request` validates `@current_user` is not nil\n- Return proper 401 Unauthorized instead of allowing nil to propagate",
    "metadata": {},
    "search_text": "Nil User in Authorization Check ScheduleTemplateRows bug User attempts to update schedule template rows via Gantt drag-and-drop. API returns error: 1. `ApplicationController#authorize_request` decoded JWT token but didn't validate that `@current_user` was set\n2. If JWT was missing/invalid, `decoded` would be `nil` → `@current_user` remained `nil`\n3. No error was raised - request continued\n4. When `check_can_edit_templates` called `@current_user.can_create_templates?`, it failed with NoMethodError - ALWAYS use safe navigation (`&.`) when calling methods on `@current_user`\n- Ensure `authorize_request` validates `@current_user` is not nil\n- Return proper 401 Unauthorized instead of allowing nil to propagate User attempts to update schedule template rows via Gantt drag-and-drop. API returns error:",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User attempts to update schedule template rows via Gantt drag-and-drop. API returns error:",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 13,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "JWT Token Expiration Not Handled in Frontend",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User logs in, leaves tab open for 25 hours, makes request → 401 Unauthorized error.",
    "root_cause": "JWT tokens expire after 24 hours with NO automatic refresh mechanism.",
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "JWT Token Expiration Not Handled in Frontend bug User logs in, leaves tab open for 25 hours, makes request → 401 Unauthorized error. JWT tokens expire after 24 hours with NO automatic refresh mechanism. User logs in, leaves tab open for 25 hours, makes request → 401 Unauthorized error.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User logs in, leaves tab open for 25 hours, makes request → 401 Unauthorized error.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 14,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "No Account Lockout for Admin Users",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Attacker brute forces admin user password with unlimited attempts.",
    "root_cause": "Account lockout only implemented for `PortalUser`, not `User` model.",
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "No Account Lockout for Admin Users bug Attacker brute forces admin user password with unlimited attempts. Account lockout only implemented for `PortalUser`, not `User` model. Attacker brute forces admin user password with unlimited attempts. - Add `failed_login_attempts` and `locked_until` to User model\n- Require admin to unlock accounts (can't self-unlock)\n- Send email on failed login attempts\n\n---",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Attacker brute forces admin user password with unlimited attempts.",
    "details": null,
    "examples": null,
    "recommendations": "- Add `failed_login_attempts` and `locked_until` to User model\n- Require admin to unlock accounts (can't self-unlock)\n- Send email on failed login attempts\n\n---",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 15,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": "Users",
    "title": "Password Reset Email Disabled",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User requests password reset → token generated but NO email sent.",
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Password Reset Email Disabled Users bug User requests password reset → token generated but NO email sent. User requests password reset → token generated but NO email sent.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User requests password reset → token generated but NO email sent.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 16,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": "OmniauthCallbacks",
    "title": "OAuth Token Expiration Not Monitored",
    "status": "open",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User logs in via Microsoft OAuth → token expires after 1 hour → OneDrive API calls fail silently.",
    "root_cause": "`oauth_expires_at` field is stored but not checked before API calls.",
    "solution": "Check token expiration before OneDrive API calls:",
    "prevention": null,
    "metadata": {},
    "search_text": "OAuth Token Expiration Not Monitored OmniauthCallbacks bug User logs in via Microsoft OAuth → token expires after 1 hour → OneDrive API calls fail silently. `oauth_expires_at` field is stored but not checked before API calls. Check token expiration before OneDrive API calls: User logs in via Microsoft OAuth → token expires after 1 hour → OneDrive API calls fail silently.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User logs in via Microsoft OAuth → token expires after 1 hour → OneDrive API calls fail silently.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 17,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": "PricebookItem",
    "title": "Duplicate Price History Entries on Rapid Updates",
    "status": "fixed",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": "2024-10-12",
    "scenario": "When a user rapidly updates the same pricebook item's price multiple times in quick succession (e.g., correcting a typo), duplicate price history entries were created with identical timestamps, causing confusion in price tracking and bloating the database.",
    "root_cause": "- `after_update` callback triggers immediately on each save\n- Two saves within the same second create records with identical `created_at` timestamps\n- No database constraint prevented duplicate (item_id, supplier_id, price, timestamp) combinations",
    "solution": "1. **Database Constraint:** Added unique index on `[:pricebook_item_id, :supplier_id, :new_price, :created_at]` (see Bible RULE #4.2)\n2. **5-Second Time Window:** `track_price_change` callback checks if identical price exists within 5 seconds before creating new history\n3. **Race Condition Safe:** `rescue ActiveRecord::RecordNotUnique` handles concurrent saves gracefully",
    "prevention": null,
    "metadata": {},
    "search_text": "Duplicate Price History Entries on Rapid Updates PricebookItem bug When a user rapidly updates the same pricebook item's price multiple times in quick succession (e.g., correcting a typo), duplicate price history entries were created with identical timestamps, causing confusion in price tracking and bloating the database. - `after_update` callback triggers immediately on each save\n- Two saves within the same second create records with identical `created_at` timestamps\n- No database constraint prevented duplicate (item_id, supplier_id, price, timestamp) combinations 1. **Database Constraint:** Added unique index on `[:pricebook_item_id, :supplier_id, :new_price, :created_at]` (see Bible RULE #4.2)\n2. **5-Second Time Window:** `track_price_change` callback checks if identical price exists within 5 seconds before creating new history\n3. **Race Condition Safe:** `rescue ActiveRecord::RecordNotUnique` handles concurrent saves gracefully When a user rapidly updates the same pricebook item's price multiple times in quick succession (e.g., correcting a typo), duplicate price history entries were created with identical timestamps, causing confusion in price tracking and bloating the database.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "When a user rapidly updates the same pricebook item's price multiple times in quick succession (e.g., correcting a typo), duplicate price history entries were created with identical timestamps, causing confusion in price tracking and bloating the database.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 18,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": "SmartPoLookupService",
    "title": "SmartPoLookupService Missing Items Despite Fuzzy Match",
    "status": "by_design",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User creates estimate with item \"2x4 Framing Lumber\" but SmartPoLookupService doesn't match it to pricebook item \"2x4 Douglas Fir Framing\" even though Levenshtein distance is 72 (above 70 threshold).",
    "root_cause": "- 6-strategy cascade prioritizes **exact match with supplier** and **fuzzy match with supplier** first\n- If estimate line item has `preferred_supplier_id` set, strategies 4-6 (without supplier) never run\n- User expects all fuzzy matches regardless of supplier constraint",
    "solution": "**THIS IS BY DESIGN** - The cascade strategy intentionally respects supplier constraints to ensure:\n1. Supplier relationships are honored (e.g., preferred vendors per job)\n2. Pricing accuracy (different suppliers have different prices)\n3. PO grouping efficiency (minimizes split orders)",
    "prevention": null,
    "metadata": {},
    "search_text": "SmartPoLookupService Missing Items Despite Fuzzy Match SmartPoLookupService bug User creates estimate with item \"2x4 Framing Lumber\" but SmartPoLookupService doesn't match it to pricebook item \"2x4 Douglas Fir Framing\" even though Levenshtein distance is 72 (above 70 threshold). - 6-strategy cascade prioritizes **exact match with supplier** and **fuzzy match with supplier** first\n- If estimate line item has `preferred_supplier_id` set, strategies 4-6 (without supplier) never run\n- User expects all fuzzy matches regardless of supplier constraint **THIS IS BY DESIGN** - The cascade strategy intentionally respects supplier constraints to ensure:\n1. Supplier relationships are honored (e.g., preferred vendors per job)\n2. Pricing accuracy (different suppliers have different prices)\n3. PO grouping efficiency (minimizes split orders) User creates estimate with item \"2x4 Framing Lumber\" but SmartPoLookupService doesn't match it to pricebook item \"2x4 Douglas Fir Framing\" even though Levenshtein distance is 72 (above 70 threshold).",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "User creates estimate with item \"2x4 Framing Lumber\" but SmartPoLookupService doesn't match it to pricebook item \"2x4 Douglas Fir Framing\" even though Levenshtein distance is 72 (above 70 threshold).",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 19,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": "PricebookItem",
    "title": "Price Volatility False Positives on New Items",
    "status": "open",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "New pricebook items with only 2-3 price history entries show \"High Volatility\" warnings even when prices are stable, because Coefficient of Variation (CV) is mathematically unreliable with small sample sizes.",
    "root_cause": "- CV = (Standard Deviation / Mean) × 100\n- Small sample sizes (n < 5) exaggerate CV due to limited data\n- First few price updates naturally have higher variance",
    "solution": "1. **Minimum Sample Requirement:** `calculate_price_volatility` requires at least 5 price history entries before calculating CV\n2. **Return nil for insufficient data:** UI shows \"Insufficient Data\" instead of misleading volatility score\n3. **6-Month Rolling Window:** Only recent prices count, ensuring CV reflects current volatility",
    "prevention": null,
    "metadata": {},
    "search_text": "Price Volatility False Positives on New Items PricebookItem bug New pricebook items with only 2-3 price history entries show \"High Volatility\" warnings even when prices are stable, because Coefficient of Variation (CV) is mathematically unreliable with small sample sizes. - CV = (Standard Deviation / Mean) × 100\n- Small sample sizes (n < 5) exaggerate CV due to limited data\n- First few price updates naturally have higher variance 1. **Minimum Sample Requirement:** `calculate_price_volatility` requires at least 5 price history entries before calculating CV\n2. **Return nil for insufficient data:** UI shows \"Insufficient Data\" instead of misleading volatility score\n3. **6-Month Rolling Window:** Only recent prices count, ensuring CV reflects current volatility New pricebook items with only 2-3 price history entries show \"High Volatility\" warnings even when prices are stable, because Coefficient of Variation (CV) is mathematically unreliable with small sample sizes.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "New pricebook items with only 2-3 price history entries show \"High Volatility\" warnings even when prices are stable, because Coefficient of Variation (CV) is mathematically unreliable with small sample sizes.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 20,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": "PricebookItem",
    "title": "Supplier Name Normalization Overly Aggressive",
    "status": "open",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Two distinct suppliers \"ABC Supply LLC\" and \"ABC Supply Co.\" both normalize to \"ABC SUPPLY\", causing incorrect fuzzy matches in SmartPoLookupService.",
    "root_cause": "- Normalization removes common business suffixes: LLC, Inc, Corp, Ltd, Co., Company, Supply Co\n- Edge case: \"ABC Supply Co.\" has \"Supply Co\" suffix removed even though \"Supply\" is part of business name\n- Levenshtein distance calculated on normalized names",
    "solution": "**KNOWN LIMITATION** - Current normalization is intentionally broad to catch variations like:\n- \"Home Depot\" vs \"Home Depot Inc.\"\n- \"Lowes\" vs \"Lowe's Companies LLC\"",
    "prevention": null,
    "metadata": {},
    "search_text": "Supplier Name Normalization Overly Aggressive PricebookItem bug Two distinct suppliers \"ABC Supply LLC\" and \"ABC Supply Co.\" both normalize to \"ABC SUPPLY\", causing incorrect fuzzy matches in SmartPoLookupService. - Normalization removes common business suffixes: LLC, Inc, Corp, Ltd, Co., Company, Supply Co\n- Edge case: \"ABC Supply Co.\" has \"Supply Co\" suffix removed even though \"Supply\" is part of business name\n- Levenshtein distance calculated on normalized names **KNOWN LIMITATION** - Current normalization is intentionally broad to catch variations like:\n- \"Home Depot\" vs \"Home Depot Inc.\"\n- \"Lowes\" vs \"Lowe's Companies LLC\" Two distinct suppliers \"ABC Supply LLC\" and \"ABC Supply Co.\" both normalize to \"ABC SUPPLY\", causing incorrect fuzzy matches in SmartPoLookupService. - Could use fuzzy string similarity (e.g., Jaro-Winkler) instead of exact normalization\n- Could maintain supplier alias table for known variations",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Two distinct suppliers \"ABC Supply LLC\" and \"ABC Supply Co.\" both normalize to \"ABC SUPPLY\", causing incorrect fuzzy matches in SmartPoLookupService.",
    "details": null,
    "examples": null,
    "recommendations": "- Could use fuzzy string similarity (e.g., Jaro-Winkler) instead of exact normalization\n- Could maintain supplier alias table for known variations",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 21,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": "ScheduleCascadeService",
    "title": "Task Cascade Infinite Loop Risk",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "When task dates change, `ScheduleCascadeService` recursively cascades to dependent tasks. Without proper safeguards, this could create infinite loops in cyclic schedules or repeatedly cascade to manually positioned tasks.",
    "root_cause": "- Recursive cascade could revisit the same task multiple times\n- Manually positioned tasks (user-set dates) should not be auto-updated\n- Circular dependencies could cause infinite recursion",
    "solution": "1. **Circular Dependency Prevention:** `TaskDependency` validates `no_circular_dependencies` using BFS graph traversal (see Bible RULE #5.3)\n2. **Manual Position Respect:** Skip tasks with `manually_positioned?` flag in cascade\n3. **Single Pass Per Task:** Each cascade operation processes downstream once only",
    "prevention": null,
    "metadata": {},
    "search_text": "Task Cascade Infinite Loop Risk ScheduleCascadeService bug When task dates change, `ScheduleCascadeService` recursively cascades to dependent tasks. Without proper safeguards, this could create infinite loops in cyclic schedules or repeatedly cascade to manually positioned tasks. - Recursive cascade could revisit the same task multiple times\n- Manually positioned tasks (user-set dates) should not be auto-updated\n- Circular dependencies could cause infinite recursion 1. **Circular Dependency Prevention:** `TaskDependency` validates `no_circular_dependencies` using BFS graph traversal (see Bible RULE #5.3)\n2. **Manual Position Respect:** Skip tasks with `manually_positioned?` flag in cascade\n3. **Single Pass Per Task:** Each cascade operation processes downstream once only When task dates change, `ScheduleCascadeService` recursively cascades to dependent tasks. Without proper safeguards, this could create infinite loops in cyclic schedules or repeatedly cascade to manually positioned tasks.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "When task dates change, `ScheduleCascadeService` recursively cascades to dependent tasks. Without proper safeguards, this could create infinite loops in cyclic schedules or repeatedly cascade to manually positioned tasks.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 53,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 22,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": "Constructions",
    "title": "Profit Calculation Performance at Scale",
    "status": "by_design",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Construction profit is calculated dynamically via `calculate_live_profit` which sums all PO totals. For jobs with 100+ purchase orders, this can cause N+1 query issues or slow API responses.",
    "root_cause": "- No caching of profit values (intentional per Bible RULE #5.2)\n- Each API request recalculates: `purchase_orders.sum(:total)`\n- Construction detail page requests profit multiple times",
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Profit Calculation Performance at Scale Constructions bug Construction profit is calculated dynamically via `calculate_live_profit` which sums all PO totals. For jobs with 100+ purchase orders, this can cause N+1 query issues or slow API responses. - No caching of profit values (intentional per Bible RULE #5.2)\n- Each API request recalculates: `purchase_orders.sum(:total)`\n- Construction detail page requests profit multiple times Construction profit is calculated dynamically via `calculate_live_profit` which sums all PO totals. For jobs with 100+ purchase orders, this can cause N+1 query issues or slow API responses.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Construction profit is calculated dynamically via `calculate_live_profit` which sums all PO totals. For jobs with 100+ purchase orders, this can cause N+1 query issues or slow API responses.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 23,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "OneDrive Folder Creation Failures",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OneDrive Folder Creation Failures bug **Status:** 🟢 HANDLED WITH RETRIES\n**Severity:** Medium\n**Common Failure Modes:** Token expiration, network timeout, duplicate folder names\n\n**Common Errors:**",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "**Status:** 🟢 HANDLED WITH RETRIES\n**Severity:** Medium\n**Common Failure Modes:** Token expiration, network timeout, duplicate folder names\n\n**Common Errors:**",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 24,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": "ProjectTask",
    "title": "Task Spawning Duplicates (Photo/Cert Tasks)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "If parent task status is updated multiple times (e.g., `complete` → `in_progress` → `complete`), photo and certificate tasks could be spawned multiple times.",
    "root_cause": "- `after_save :spawn_child_tasks_on_status_change` fires on every save\n- No check for existing spawned tasks before creating",
    "solution": "```ruby\n# Check which predecessors are blocking\ntask.blocked_by  # Returns array of incomplete predecessor tasks\n\n# Complete predecessors first, then mark task in_progress",
    "prevention": null,
    "metadata": {},
    "search_text": "Task Spawning Duplicates (Photo/Cert Tasks) ProjectTask bug If parent task status is updated multiple times (e.g., `complete` → `in_progress` → `complete`), photo and certificate tasks could be spawned multiple times. - `after_save :spawn_child_tasks_on_status_change` fires on every save\n- No check for existing spawned tasks before creating ```ruby\n# Check which predecessors are blocking\ntask.blocked_by  # Returns array of incomplete predecessor tasks\n\n# Complete predecessors first, then mark task in_progress If parent task status is updated multiple times (e.g., `complete` → `in_progress` → `complete`), photo and certificate tasks could be spawned multiple times.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "If parent task status is updated multiple times (e.g., `complete` → `in_progress` → `complete`), photo and certificate tasks could be spawned multiple times.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 25,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Fuzzy Matching False Positives at 70-75% Threshold",
    "status": "by_design",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Job names like \"Smith Residence\" might auto-match to \"Smith Commercial Building\" at 72% confidence when they're completely different projects.",
    "root_cause": "- 70% auto-match threshold is aggressive\n- Word-matching bonus (+15 per word) inflates scores\n- \"Smith\" as common name boosts unrelated jobs",
    "solution": "1. **Current:** Users can reject auto-match and manually select correct job\n2. **Mitigation:** Threshold tuning based on production data\n3. **Future:** Add address-based validation (if addresses available in estimate)",
    "prevention": null,
    "metadata": {},
    "search_text": "Fuzzy Matching False Positives at 70-75% Threshold bug Job names like \"Smith Residence\" might auto-match to \"Smith Commercial Building\" at 72% confidence when they're completely different projects. - 70% auto-match threshold is aggressive\n- Word-matching bonus (+15 per word) inflates scores\n- \"Smith\" as common name boosts unrelated jobs 1. **Current:** Users can reject auto-match and manually select correct job\n2. **Mitigation:** Threshold tuning based on production data\n3. **Future:** Add address-based validation (if addresses available in estimate) Job names like \"Smith Residence\" might auto-match to \"Smith Commercial Building\" at 72% confidence when they're completely different projects.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Job names like \"Smith Residence\" might auto-match to \"Smith Commercial Building\" at 72% confidence when they're completely different projects.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 26,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Levenshtein Performance with Very Long Job Names",
    "status": "open",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "Job names exceeding 150 characters (rare but possible) cause Levenshtein calculation to take 50-100ms.",
    "root_cause": "- O(m*n) complexity where m,n = string lengths\n- Matrix allocation for long strings\n- Pure Ruby implementation (no C extension)",
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Levenshtein Performance with Very Long Job Names bug Job names exceeding 150 characters (rare but possible) cause Levenshtein calculation to take 50-100ms. - O(m*n) complexity where m,n = string lengths\n- Matrix allocation for long strings\n- Pure Ruby implementation (no C extension) Job names exceeding 150 characters (rare but possible) cause Levenshtein calculation to take 50-100ms.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "Job names exceeding 150 characters (rare but possible) cause Levenshtein calculation to take 50-100ms.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 27,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Estimate Import Fails Silently on Malformed JSON",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "If Unreal Engine sends malformed JSON (e.g., trailing commas, unquoted keys), Rails parses it incorrectly and estimate import fails without clear error to user.",
    "root_cause": null,
    "solution": null,
    "prevention": "Validate JSON format before processing in Unreal Engine.\n\n---",
    "metadata": {},
    "search_text": "Estimate Import Fails Silently on Malformed JSON bug If Unreal Engine sends malformed JSON (e.g., trailing commas, unquoted keys), Rails parses it incorrectly and estimate import fails without clear error to user. Validate JSON format before processing in Unreal Engine.\n\n--- If Unreal Engine sends malformed JSON (e.g., trailing commas, unquoted keys), Rails parses it incorrectly and estimate import fails without clear error to user.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "If Unreal Engine sends malformed JSON (e.g., trailing commas, unquoted keys), Rails parses it incorrectly and estimate import fails without clear error to user.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 28,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": "EstimateToPurchaseOrderService",
    "title": "AI Review Timeout on Large PDFs",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "PDFs exceeding 50 pages cause Claude API calls to timeout (>5 minutes) even with pagination.",
    "root_cause": "- Claude has per-request token limits\n- 50-page PDFs = 100k+ tokens\n- Processing exceeds 5-minute timeout",
    "solution": "1. Regenerate key: `integration.generate_api_key`\n2. Copy new key to Unreal Engine config\n3. Test with curl:\n   ```bash\n   curl -X POST https://trapid-backend.herokuapp.com/api/v1/external/unreal_estimates \\\n     -H \"X-API-Key: YOUR_KEY\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"job_name\": \"Test\", \"materials\": [{\"item\": \"Test\", \"quantity\": 1}]}'\n   ```\n\n---\n\n### \"Estimate Auto-Matched to Wrong Job\"",
    "prevention": "If this happens frequently:\n1. Increase auto-match threshold to 75%\n2. Add address validation (if available)\n3. Require manual confirmation for 70-75% matches\n\n---\n\n### \"AI Review Stuck in 'Processing' Status\"",
    "metadata": {},
    "search_text": "AI Review Timeout on Large PDFs EstimateToPurchaseOrderService bug PDFs exceeding 50 pages cause Claude API calls to timeout (>5 minutes) even with pagination. - Claude has per-request token limits\n- 50-page PDFs = 100k+ tokens\n- Processing exceeds 5-minute timeout 1. Regenerate key: `integration.generate_api_key`\n2. Copy new key to Unreal Engine config\n3. Test with curl:\n   ```bash\n   curl -X POST https://trapid-backend.herokuapp.com/api/v1/external/unreal_estimates \\\n     -H \"X-API-Key: YOUR_KEY\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"job_name\": \"Test\", \"materials\": [{\"item\": \"Test\", \"quantity\": 1}]}'\n   ```\n\n---\n\n### \"Estimate Auto-Matched to Wrong Job\" If this happens frequently:\n1. Increase auto-match threshold to 75%\n2. Add address validation (if available)\n3. Require manual confirmation for 70-75% matches\n\n---\n\n### \"AI Review Stuck in 'Processing' Status\" PDFs exceeding 50 pages cause Claude API calls to timeout (>5 minutes) even with pagination. - Multi-pass review (chunk PDFs into 10-page sections)\n- Parallel Claude API calls for each chunk\n- Aggregate results\n\n---\n\n## 🏗️ Architecture & Implementation\n\n### Levenshtein Distance Algorithm",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "PDFs exceeding 50 pages cause Claude API calls to timeout (>5 minutes) even with pagination.",
    "details": null,
    "examples": null,
    "recommendations": "- Multi-pass review (chunk PDFs into 10-page sections)\n- Parallel Claude API calls for each chunk\n- Aggregate results\n\n---\n\n## 🏗️ Architecture & Implementation\n\n### Levenshtein Distance Algorithm",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 32,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Price Drift Warning on First-Time Items",
    "status": "open",
    "severity": "low",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "New item has no pricebook entry → shows \"N/A\" drift → confusing to users.",
    "root_cause": null,
    "solution": "```ruby\nActiveRecord::Base.transaction do\n  # Step 1: Unlink old task\n  if old_task = purchase_order.schedule_task\n    old_task.update!(purchase_order_id: nil)\n  end\n\n  # Step 2: Link new task\n  if new_task_id.present?\n    new_task = ScheduleTask.find(new_task_id)\n    new_task.update!(purchase_order_id: purchase_order.id)\n  end\nend",
    "prevention": null,
    "metadata": {},
    "search_text": "Price Drift Warning on First-Time Items bug New item has no pricebook entry → shows \"N/A\" drift → confusing to users. ```ruby\nActiveRecord::Base.transaction do\n  # Step 1: Unlink old task\n  if old_task = purchase_order.schedule_task\n    old_task.update!(purchase_order_id: nil)\n  end\n\n  # Step 2: Link new task\n  if new_task_id.present?\n    new_task = ScheduleTask.find(new_task_id)\n    new_task.update!(purchase_order_id: purchase_order.id)\n  end\nend New item has no pricebook entry → shows \"N/A\" drift → confusing to users.",
    "created_at": "2025-11-16 13:19:12 +1000",
    "updated_at": "2025-11-16 13:19:12 +1000",
    "entry_type": "bug",
    "description": "New item has no pricebook entry → shows \"N/A\" drift → confusing to users.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 33,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": "Authentication",
    "title": "JWT vs Session-Based Auth (Design Decision)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "JWT vs Session-Based Auth (Design Decision) Authentication architecture Stateless authentication using JWT tokens instead of session cookies for API-friendly architecture **Why JWT?**\n- Stateless: No server-side session storage\n- API-friendly: Works well with React SPA\n- Mobile-ready\n\n**Trade-offs:**\n- Cannot revoke tokens\n- Larger size than session ID",
    "created_at": "2025-11-16 13:40:03 +1000",
    "updated_at": "2025-11-16 13:40:03 +1000",
    "entry_type": "architecture",
    "description": "Stateless authentication using JWT tokens instead of session cookies for API-friendly architecture",
    "details": "**Why JWT?**\n- Stateless: No server-side session storage\n- API-friendly: Works well with React SPA\n- Mobile-ready\n\n**Trade-offs:**\n- Cannot revoke tokens\n- Larger size than session ID",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 34,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": "Authorization",
    "title": "Role System Architecture",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Role System Architecture Authorization architecture Hardcoded enum roles in User model for security and performance Roles are hardcoded rather than database-driven to prevent privilege escalation via API exploits.",
    "created_at": "2025-11-16 13:40:03 +1000",
    "updated_at": "2025-11-16 13:40:03 +1000",
    "entry_type": "architecture",
    "description": "Hardcoded enum roles in User model for security and performance",
    "details": "Roles are hardcoded rather than database-driven to prevent privilege escalation via API exploits.",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 35,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": "Contact",
    "title": "Contact Type System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Contact Type System Contact architecture PostgreSQL array column for contact_types to support hybrid entities Uses varchar[] to allow contacts to be both customers and suppliers simultaneously. GIN indexes provide fast querying.",
    "created_at": "2025-11-16 13:40:03 +1000",
    "updated_at": "2025-11-16 13:40:03 +1000",
    "entry_type": "architecture",
    "description": "PostgreSQL array column for contact_types to support hybrid entities",
    "details": "Uses varchar[] to allow contacts to be both customers and suppliers simultaneously. GIN indexes provide fast querying.",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 36,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": "DHtmlxGanttView + ScheduleTemplateEditor",
    "title": "Gantt Shaking During Cascade Operations",
    "status": "fixed",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": "2025-11-16",
    "scenario": "Gantt chart displayed visual shaking or slow flickering during cascade operations. Console logs showed 5+ Gantt reloads within 2-3 seconds during a single drag operation.",
    "root_cause": "The signature-based reload fix (implemented to show cascade updates visually) was triggering a reload for EVERY cascade batch update. Each cascade wave created multiple signature changes, and there was no throttling mechanism during multi-wave cascade operations.",
    "solution": "Three-part fix using cascade depth tracking: 1) Pass cascadeDepthRef to DHtmlxGanttView, 2) Throttle signature-based reloads when cascade depth > 0, 3) Trigger one final reload when cascade depth returns to 0",
    "prevention": "Always check cascade depth before allowing signature-based reloads. Batch all cascade updates into one final reload after operations complete.",
    "metadata": {
      "bug_number": "BUG-006",
      "related_bugs": [
        "BUG-001",
        "BUG-002",
        "BUG-005"
      ],
      "files_changed": [
        "frontend/src/components/schedule-master/ScheduleTemplateEditor.jsx",
        "frontend/src/components/schedule-master/DHtmlxGanttView.jsx"
      ],
      "related_rules": [
        "RULE #9.2"
      ]
    },
    "search_text": "Gantt Shaking During Cascade Operations DHtmlxGanttView + ScheduleTemplateEditor bug Gantt chart displayed visual shaking or slow flickering during cascade operations. Console logs showed 5+ Gantt reloads within 2-3 seconds during a single drag operation. The signature-based reload fix (implemented to show cascade updates visually) was triggering a reload for EVERY cascade batch update. Each cascade wave created multiple signature changes, and there was no throttling mechanism during multi-wave cascade operations. Three-part fix using cascade depth tracking: 1) Pass cascadeDepthRef to DHtmlxGanttView, 2) Throttle signature-based reloads when cascade depth > 0, 3) Trigger one final reload when cascade depth returns to 0 Always check cascade depth before allowing signature-based reloads. Batch all cascade updates into one final reload after operations complete. Visual flickering caused by excessive Gantt reloads during cascade operations Before: 5-8 reloads per drag. After: 1 reload after cascades complete. 80-87% reduction in reloads. Files changed: ScheduleTemplateEditor.jsx (lines 2538, 1214-1216), DHtmlxGanttView.jsx (lines 35, 3884-3891) Use cascade depth tracking to throttle visual updates during multi-step operations",
    "created_at": "2025-11-16 18:58:54 +1000",
    "updated_at": "2025-11-16 18:58:54 +1000",
    "entry_type": "bug",
    "description": "Visual flickering caused by excessive Gantt reloads during cascade operations",
    "details": "Before: 5-8 reloads per drag. After: 1 reload after cascades complete. 80-87% reduction in reloads.",
    "examples": "Files changed: ScheduleTemplateEditor.jsx (lines 2538, 1214-1216), DHtmlxGanttView.jsx (lines 35, 3884-3891)",
    "recommendations": "Use cascade depth tracking to throttle visual updates during multi-step operations",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 46,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "spec/models/agent_definition_spec.rb, spec/requests/agent_definitions_spec.rb",
    "title": "Agent System Test Coverage",
    "status": "open",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": "Unit Tests Needed: AgentDefinition#record_success, AgentDefinition#record_failure, AgentDefinition#success_rate, AgentDefinition#recently_run? | Integration Tests Needed: POST /api/v1/agent_definitions/:id/record_run, GET /api/v1/agent_definitions (priority sorting), Agent invocation protocol (end-to-end) | Current Coverage: 0% (no tests written yet)",
    "prevention": null,
    "metadata": {},
    "search_text": "Agent System Test Coverage spec/models/agent_definition_spec.rb, spec/requests/agent_definitions_spec.rb test Unit Tests Needed: AgentDefinition#record_success, AgentDefinition#record_failure, AgentDefinition#success_rate, AgentDefinition#recently_run? | Integration Tests Needed: POST /api/v1/agent_definitions/:id/record_run, GET /api/v1/agent_definitions (priority sorting), Agent invocation protocol (end-to-end) | Current Coverage: 0% (no tests written yet) Testing status for Agent System components.",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "test",
    "description": "Testing status for Agent System components.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 54,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 55,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:50 +1000",
    "updated_at": "2025-11-16 21:03:50 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 40,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "AgentDefinition, AgentDefinitionsController",
    "title": "Database-Primary Agent Configuration",
    "status": "open",
    "severity": "high",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": "Needed structured data for run tracking, filtering, and real-time updates. Markdown files are read-only snapshots.",
    "solution": "Created agent_definitions table with JSONB fields for metadata and run details. API endpoints for CRUD operations.",
    "prevention": null,
    "metadata": {},
    "search_text": "Database-Primary Agent Configuration AgentDefinition, AgentDefinitionsController architecture Needed structured data for run tracking, filtering, and real-time updates. Markdown files are read-only snapshots. Created agent_definitions table with JSONB fields for metadata and run details. API endpoints for CRUD operations. Agent configurations are stored in database, not markdown files. Trade-off: Requires database migration when adding new agents. Benefit: Live run tracking, success rates, recently_run? checks.",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "architecture",
    "description": "Agent configurations are stored in database, not markdown files.",
    "details": null,
    "examples": null,
    "recommendations": "Trade-off: Requires database migration when adding new agents. Benefit: Live run tracking, success rates, recently_run? checks.",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 41,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "agent_definitions.last_run_details",
    "title": "Run History Tracking with JSONB",
    "status": "open",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": "Run details vary by agent type (files_created, tests_passed, duration_seconds, etc.). Fixed schema would be too rigid.",
    "solution": "Used JSONB columns: last_run_details and metadata for flexible storage.",
    "prevention": null,
    "metadata": {},
    "search_text": "Run History Tracking with JSONB agent_definitions.last_run_details architecture Run details vary by agent type (files_created, tests_passed, duration_seconds, etc.). Fixed schema would be too rigid. Used JSONB columns: last_run_details and metadata for flexible storage. Agent run history stored in JSONB fields for flexibility. Trade-off: No strict validation on JSONB structure. Benefit: Each agent can track custom metrics.",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "architecture",
    "description": "Agent run history stored in JSONB fields for flexibility.",
    "details": null,
    "examples": null,
    "recommendations": "Trade-off: No strict validation on JSONB structure. Benefit: Each agent can track custom metrics.",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 42,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "AgentDefinition.agent_type",
    "title": "Agent Type Taxonomy (4 Types)",
    "status": "open",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": "Needed clear separation of concerns. Backend work vs frontend work vs bug hunting vs planning.",
    "solution": "Created agent_type enum with 4 values. Each agent assigned single type.",
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Type Taxonomy (4 Types) AgentDefinition.agent_type architecture Needed clear separation of concerns. Backend work vs frontend work vs bug hunting vs planning. Created agent_type enum with 4 values. Each agent assigned single type. Agents categorized into 4 types: development, diagnostic, deployment, planning. development: backend-developer, frontend-developer | diagnostic: production-bug-hunter, gantt-bug-hunter | deployment: deploy-manager | planning: planning-collaborator Trade-off: Agents can only have one type. Benefit: Clear responsibility boundaries.",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "architecture",
    "description": "Agents categorized into 4 types: development, diagnostic, deployment, planning.",
    "details": "development: backend-developer, frontend-developer | diagnostic: production-bug-hunter, gantt-bug-hunter | deployment: deploy-manager | planning: planning-collaborator",
    "examples": null,
    "recommendations": "Trade-off: Agents can only have one type. Benefit: Clear responsibility boundaries.",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 43,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "AgentDefinition#recently_run?",
    "title": "recently_run? Smart Test Skipping",
    "status": "open",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": "Gantt Bug Hunter runs 12 automated tests (30-60 seconds). Wasteful to re-run if nothing changed.",
    "solution": "AgentDefinition#recently_run?(minutes = 60) returns true if last successful run was within threshold.",
    "prevention": null,
    "metadata": {},
    "search_text": "recently_run? Smart Test Skipping AgentDefinition#recently_run? architecture Gantt Bug Hunter runs 12 automated tests (30-60 seconds). Wasteful to re-run if nothing changed. AgentDefinition#recently_run?(minutes = 60) returns true if last successful run was within threshold. Diagnostic agents check if tests ran recently to avoid redundant runs. Logic: Returns false if never run | Returns false if last run failed (always re-test failures) | Returns true if last_run_at > 60 minutes ago AND last_status == 'success' Trade-off: Stale results if threshold too high. Benefit: Faster iteration during development.",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "architecture",
    "description": "Diagnostic agents check if tests ran recently to avoid redundant runs.",
    "details": "Logic: Returns false if never run | Returns false if last run failed (always re-test failures) | Returns true if last_run_at > 60 minutes ago AND last_status == 'success'",
    "examples": null,
    "recommendations": "Trade-off: Stale results if threshold too high. Benefit: Faster iteration during development.",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 44,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "CLAUDE.md agent recognition",
    "title": "Agent Shortcuts Not Case-Insensitive",
    "status": "open",
    "severity": "low",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": "User types 'Backend Dev' (capital B) but system expects 'backend dev'.",
    "root_cause": "Shortcut parsing is case-sensitive in CLAUDE.md",
    "solution": "Update shortcut parser to normalize input: .toLowerCase().trim()",
    "prevention": "Add test cases for case variations",
    "metadata": {},
    "search_text": "Agent Shortcuts Not Case-Insensitive CLAUDE.md agent recognition bug User types 'Backend Dev' (capital B) but system expects 'backend dev'. Shortcut parsing is case-sensitive in CLAUDE.md Update shortcut parser to normalize input: .toLowerCase().trim() Add test cases for case variations",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "bug",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 45,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": ".claude/agents/, AgentDefinition",
    "title": "Syncing .claude/agents/*.md with Database",
    "status": "open",
    "severity": "medium",
    "first_reported": "2025-11-16",
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Syncing .claude/agents/*.md with Database .claude/agents/, AgentDefinition dev_note Two sources of agent config: .claude/agents/*.md files and agent_definitions table. Developer updates .md file but forgets to update database, causing drift. Database is authoritative. .md files remain for Claude Code compatibility but are secondary. Future: Create rake task to sync .md files FROM database (reverse of lexicon export).",
    "created_at": "2025-11-16 19:38:41 +1000",
    "updated_at": "2025-11-16 19:38:41 +1000",
    "entry_type": "dev_note",
    "description": "Two sources of agent config: .claude/agents/*.md files and agent_definitions table.",
    "details": "Developer updates .md file but forgets to update database, causing drift.",
    "examples": null,
    "recommendations": "Database is authoritative. .md files remain for Claude Code compatibility but are secondary. Future: Create rake task to sync .md files FROM database (reverse of lexicon export).",
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 47,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:49 +1000",
    "updated_at": "2025-11-16 21:03:49 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 48,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:49 +1000",
    "updated_at": "2025-11-16 21:03:49 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 49,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:03:49 +1000",
    "updated_at": "2025-11-16 21:03:49 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 58,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Chapter Documentation Pending",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Documentation Pending dev_note This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "created_at": "2025-11-16 21:05:36 +1000",
    "updated_at": "2025-11-16 21:05:36 +1000",
    "entry_type": "dev_note",
    "description": "This chapter requires comprehensive documentation. Bug fixes and architecture decisions should be added as they are discovered.",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 59,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "HeadlessUI + Heroicons Architecture Decision",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "HeadlessUI + Heroicons Architecture Decision architecture **Decision:** Use HeadlessUI for component composition + Heroicons for consistent icons\n\n**Rationale:**\n- Composability: HeadlessUI provides unstyled, accessible components styled with TailwindCSS\n- Accessibility Built-in: ARIA attributes handled automatically\n- Icon Consistency: Heroicons (24-outline style) across all 200+ icon usages\n- Package Integration: Both officially maintained by Tailwind Labs\n\n**Evidence:**\n- 20+ component files import HeadlessUI (Tab, Dialog, Menu, etc.)\n- All icons from `@heroicons/react/24/outline`\n- Packages: `@headlessui/react: ^2.2.9`, `@heroicons/react: ^2.2.0`\n\n**Protected Pattern:** HeadlessUI patterns must be preserved in all modals/dropdowns\n",
    "created_at": "2025-11-16 21:27:44 +1000",
    "updated_at": "2025-11-16 21:27:44 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** Use HeadlessUI for component composition + Heroicons for consistent icons\n\n**Rationale:**\n- Composability: HeadlessUI provides unstyled, accessible components styled with TailwindCSS\n- Accessibility Built-in: ARIA attributes handled automatically\n- Icon Consistency: Heroicons (24-outline style) across all 200+ icon usages\n- Package Integration: Both officially maintained by Tailwind Labs\n\n**Evidence:**\n- 20+ component files import HeadlessUI (Tab, Dialog, Menu, etc.)\n- All icons from `@heroicons/react/24/outline`\n- Packages: `@headlessui/react: ^2.2.9`, `@heroicons/react: ^2.2.0`\n\n**Protected Pattern:** HeadlessUI patterns must be preserved in all modals/dropdowns\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 60,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "TailwindCSS Styling Strategy (No CSS-in-JS)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "TailwindCSS Styling Strategy (No CSS-in-JS) architecture **Decision:** Pure TailwindCSS with dark mode via `dark:` prefix (no CSS-in-JS)\n\n**Rationale:**\n- Performance: No runtime style generation (compiled at build time)\n- Type Safety: ClassName strings catch typos at development time\n- Dark Mode Built-In: Tailwind's `dark:` prefix requires no additional libraries\n- Predictable Output: CSS generated once, not recalculated per component\n\n**Evidence:**\n- 5,920+ `dark:` prefixed classes throughout codebase\n- Zero CSS-in-JS libraries (no styled-components, emotion)\n- Minimal tailwind.config.js (no custom plugins)\n\n**Protected Pattern:** No CSS-in-JS conversions planned\n",
    "created_at": "2025-11-16 21:27:44 +1000",
    "updated_at": "2025-11-16 21:27:44 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** Pure TailwindCSS with dark mode via `dark:` prefix (no CSS-in-JS)\n\n**Rationale:**\n- Performance: No runtime style generation (compiled at build time)\n- Type Safety: ClassName strings catch typos at development time\n- Dark Mode Built-In: Tailwind's `dark:` prefix requires no additional libraries\n- Predictable Output: CSS generated once, not recalculated per component\n\n**Evidence:**\n- 5,920+ `dark:` prefixed classes throughout codebase\n- Zero CSS-in-JS libraries (no styled-components, emotion)\n- Minimal tailwind.config.js (no custom plugins)\n\n**Protected Pattern:** No CSS-in-JS conversions planned\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 61,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "ContactsPage as Gold Standard Reference",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "ContactsPage as Gold Standard Reference architecture **Decision:** ContactsPage.jsx designated as primary reference implementation\n\n**Rationale - Feature Complete:**\n- Sticky headers ✅\n- Column resize with drag handles ✅\n- Column reorder (drag-drop) ✅\n- Inline column filters ✅\n- Search with clear button ✅\n- Multi-level sort ✅\n- localStorage persistence ✅\n- Dark mode support ✅\n- Row actions ✅\n- Empty states with action buttons ✅\n\n**File:** `frontend/src/pages/ContactsPage.jsx` (372 lines)\n\n**Use As Reference For:**\n- Column state management patterns\n- URL-based tab sync\n- Table feature implementation\n",
    "created_at": "2025-11-16 21:27:44 +1000",
    "updated_at": "2025-11-16 21:27:44 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** ContactsPage.jsx designated as primary reference implementation\n\n**Rationale - Feature Complete:**\n- Sticky headers ✅\n- Column resize with drag handles ✅\n- Column reorder (drag-drop) ✅\n- Inline column filters ✅\n- Search with clear button ✅\n- Multi-level sort ✅\n- localStorage persistence ✅\n- Dark mode support ✅\n- Row actions ✅\n- Empty states with action buttons ✅\n\n**File:** `frontend/src/pages/ContactsPage.jsx` (372 lines)\n\n**Use As Reference For:**\n- Column state management patterns\n- URL-based tab sync\n- Table feature implementation\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 62,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Dark Mode Implementation Strategy",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Dark Mode Implementation Strategy architecture **Decision:** CSS-first dark mode using `prefers-color-scheme` media query\n\n**Rationale:**\n- No JavaScript Overhead: Applied via CSS, not JS state\n- Respects User Preferences: Automatically responds to OS dark mode\n- Manual Toggle Possible: Can be enhanced later if needed\n- Accessibility Compliant: Respects `prefers-color-scheme` WCAG requirement\n\n**Evidence:**\n- Tailwind config uses default dark mode strategy (media query)\n- 5,920+ dark mode class usages\n- Consistent pattern: `bg-white dark:bg-gray-800`, `text-gray-900 dark:text-white`\n- COLOR_SYSTEM.md documents standardized dark colors\n\n**Protected Pattern:** All dark mode classes must be preserved\n",
    "created_at": "2025-11-16 21:27:44 +1000",
    "updated_at": "2025-11-16 21:27:44 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** CSS-first dark mode using `prefers-color-scheme` media query\n\n**Rationale:**\n- No JavaScript Overhead: Applied via CSS, not JS state\n- Respects User Preferences: Automatically responds to OS dark mode\n- Manual Toggle Possible: Can be enhanced later if needed\n- Accessibility Compliant: Respects `prefers-color-scheme` WCAG requirement\n\n**Evidence:**\n- Tailwind config uses default dark mode strategy (media query)\n- 5,920+ dark mode class usages\n- Consistent pattern: `bg-white dark:bg-gray-800`, `text-gray-900 dark:text-white`\n- COLOR_SYSTEM.md documents standardized dark colors\n\n**Protected Pattern:** All dark mode classes must be preserved\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 63,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "HeadlessUI + Heroicons Architecture Decision",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "HeadlessUI + Heroicons Architecture Decision architecture **Decision:** Use HeadlessUI for component composition + Heroicons for consistent icons\n\n**Rationale:**\n- Composability: HeadlessUI provides unstyled, accessible components styled with TailwindCSS\n- Accessibility Built-in: ARIA attributes handled automatically\n- Icon Consistency: Heroicons (24-outline style) across all 200+ icon usages\n- Package Integration: Both officially maintained by Tailwind Labs\n\n**Evidence:**\n- 20+ component files import HeadlessUI (Tab, Dialog, Menu, etc.)\n- All icons from `@heroicons/react/24/outline`\n- Packages: `@headlessui/react: ^2.2.9`, `@heroicons/react: ^2.2.0`\n\n**Protected Pattern:** HeadlessUI patterns must be preserved in all modals/dropdowns\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** Use HeadlessUI for component composition + Heroicons for consistent icons\n\n**Rationale:**\n- Composability: HeadlessUI provides unstyled, accessible components styled with TailwindCSS\n- Accessibility Built-in: ARIA attributes handled automatically\n- Icon Consistency: Heroicons (24-outline style) across all 200+ icon usages\n- Package Integration: Both officially maintained by Tailwind Labs\n\n**Evidence:**\n- 20+ component files import HeadlessUI (Tab, Dialog, Menu, etc.)\n- All icons from `@heroicons/react/24/outline`\n- Packages: `@headlessui/react: ^2.2.9`, `@heroicons/react: ^2.2.0`\n\n**Protected Pattern:** HeadlessUI patterns must be preserved in all modals/dropdowns\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 64,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "TailwindCSS Styling Strategy (No CSS-in-JS)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "TailwindCSS Styling Strategy (No CSS-in-JS) architecture **Decision:** Pure TailwindCSS with dark mode via `dark:` prefix (no CSS-in-JS)\n\n**Rationale:**\n- Performance: No runtime style generation (compiled at build time)\n- Type Safety: ClassName strings catch typos at development time\n- Dark Mode Built-In: Tailwind's `dark:` prefix requires no additional libraries\n- Predictable Output: CSS generated once, not recalculated per component\n\n**Evidence:**\n- 5,920+ `dark:` prefixed classes throughout codebase\n- Zero CSS-in-JS libraries (no styled-components, emotion)\n- Minimal tailwind.config.js (no custom plugins)\n\n**Protected Pattern:** No CSS-in-JS conversions planned\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** Pure TailwindCSS with dark mode via `dark:` prefix (no CSS-in-JS)\n\n**Rationale:**\n- Performance: No runtime style generation (compiled at build time)\n- Type Safety: ClassName strings catch typos at development time\n- Dark Mode Built-In: Tailwind's `dark:` prefix requires no additional libraries\n- Predictable Output: CSS generated once, not recalculated per component\n\n**Evidence:**\n- 5,920+ `dark:` prefixed classes throughout codebase\n- Zero CSS-in-JS libraries (no styled-components, emotion)\n- Minimal tailwind.config.js (no custom plugins)\n\n**Protected Pattern:** No CSS-in-JS conversions planned\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 65,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "ContactsPage as Gold Standard Reference",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "ContactsPage as Gold Standard Reference architecture **Decision:** ContactsPage.jsx designated as primary reference implementation\n\n**Rationale - Feature Complete:**\n- Sticky headers ✅\n- Column resize with drag handles ✅\n- Column reorder (drag-drop) ✅\n- Inline column filters ✅\n- Search with clear button ✅\n- Multi-level sort ✅\n- localStorage persistence ✅\n- Dark mode support ✅\n- Row actions ✅\n- Empty states with action buttons ✅\n\n**File:** `frontend/src/pages/ContactsPage.jsx` (372 lines)\n\n**Use As Reference For:**\n- Column state management patterns\n- URL-based tab sync\n- Table feature implementation\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** ContactsPage.jsx designated as primary reference implementation\n\n**Rationale - Feature Complete:**\n- Sticky headers ✅\n- Column resize with drag handles ✅\n- Column reorder (drag-drop) ✅\n- Inline column filters ✅\n- Search with clear button ✅\n- Multi-level sort ✅\n- localStorage persistence ✅\n- Dark mode support ✅\n- Row actions ✅\n- Empty states with action buttons ✅\n\n**File:** `frontend/src/pages/ContactsPage.jsx` (372 lines)\n\n**Use As Reference For:**\n- Column state management patterns\n- URL-based tab sync\n- Table feature implementation\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 66,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Dark Mode Implementation Strategy",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Dark Mode Implementation Strategy architecture **Decision:** CSS-first dark mode using `prefers-color-scheme` media query\n\n**Rationale:**\n- No JavaScript Overhead: Applied via CSS, not JS state\n- Respects User Preferences: Automatically responds to OS dark mode\n- Manual Toggle Possible: Can be enhanced later if needed\n- Accessibility Compliant: Respects `prefers-color-scheme` WCAG requirement\n\n**Evidence:**\n- Tailwind config uses default dark mode strategy (media query)\n- 5,920+ dark mode class usages\n- Consistent pattern: `bg-white dark:bg-gray-800`, `text-gray-900 dark:text-white`\n- COLOR_SYSTEM.md documents standardized dark colors\n\n**Protected Pattern:** All dark mode classes must be preserved\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "architecture",
    "description": "**Decision:** CSS-first dark mode using `prefers-color-scheme` media query\n\n**Rationale:**\n- No JavaScript Overhead: Applied via CSS, not JS state\n- Respects User Preferences: Automatically responds to OS dark mode\n- Manual Toggle Possible: Can be enhanced later if needed\n- Accessibility Compliant: Respects `prefers-color-scheme` WCAG requirement\n\n**Evidence:**\n- Tailwind config uses default dark mode strategy (media query)\n- 5,920+ dark mode class usages\n- Consistent pattern: `bg-white dark:bg-gray-800`, `text-gray-900 dark:text-white`\n- COLOR_SYSTEM.md documents standardized dark colors\n\n**Protected Pattern:** All dark mode classes must be preserved\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 67,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Search Boxes Missing Clear Buttons (73 components)",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Search Boxes Missing Clear Buttons (73 components) bug **Impact:** 73 search boxes across codebase\n**Severity:** HIGH - UX regression\n**Rule Violation:** RULE #19.20 (Search Functionality Standards)\n\n**Problem:** Search inputs lack clear button (X icon) to quickly reset search\n\n**Automation:** YES - Script can add clear button to all search boxes (30-40 min)\n\n**Affected Pages:** ContactsPage, PriceBooksPage, SuppliersPage, PurchaseOrdersPage, +40 more\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 73 search boxes across codebase\n**Severity:** HIGH - UX regression\n**Rule Violation:** RULE #19.20 (Search Functionality Standards)\n\n**Problem:** Search inputs lack clear button (X icon) to quickly reset search\n\n**Automation:** YES - Script can add clear button to all search boxes (30-40 min)\n\n**Affected Pages:** ContactsPage, PriceBooksPage, SuppliersPage, PurchaseOrdersPage, +40 more\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 68,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Modals Missing Close Buttons (58 components)",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Modals Missing Close Buttons (58 components) bug **Impact:** 58 modals across codebase\n**Severity:** HIGH - Accessibility issue\n**Rule Violation:** RULE #19.22 (Modal Rules)\n**Current State:** 78 modals have close button, 58 do not\n\n**Problem:** Modals lack visible close button in top-right corner\n\n**Automation:** YES - Template can be applied to all modals (20-30 min)\n\n**Affected Modals:** NewJobModal, EditJobModal, PurchaseOrderModal, +50 more\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 58 modals across codebase\n**Severity:** HIGH - Accessibility issue\n**Rule Violation:** RULE #19.22 (Modal Rules)\n**Current State:** 78 modals have close button, 58 do not\n\n**Problem:** Modals lack visible close button in top-right corner\n\n**Automation:** YES - Template can be applied to all modals (20-30 min)\n\n**Affected Modals:** NewJobModal, EditJobModal, PurchaseOrderModal, +50 more\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 69,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Empty States Missing Action Buttons (66 components)",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Empty States Missing Action Buttons (66 components) bug **Impact:** 66 empty states\n**Severity:** HIGH - UX conversion issue\n**Rule Violation:** RULE #19.27 (Empty State Rules)\n**Current State:** 14 with action buttons, 66 without\n\n**Problem:** Empty states show message but no call-to-action button\n\n**Automation:** PARTIAL - Manual work required (1-2 hours total)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 66 empty states\n**Severity:** HIGH - UX conversion issue\n**Rule Violation:** RULE #19.27 (Empty State Rules)\n**Current State:** 14 with action buttons, 66 without\n\n**Problem:** Empty states show message but no call-to-action button\n\n**Automation:** PARTIAL - Manual work required (1-2 hours total)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 70,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Table Headers Not Sticky (36 tables)",
    "status": "open",
    "severity": "high",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Table Headers Not Sticky (36 tables) bug **Impact:** 36 tables\n**Severity:** HIGH - Scrolling UX\n**Rule Violation:** RULE #19.2 (Sticky Headers)\n**Current State:** 18 with sticky headers, 36 without\n\n**Problem:** Headers scroll out of view in large tables\n\n**Automation:** YES - Add `sticky top-0 z-10` to thead (15-20 min)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 36 tables\n**Severity:** HIGH - Scrolling UX\n**Rule Violation:** RULE #19.2 (Sticky Headers)\n**Current State:** 18 with sticky headers, 36 without\n\n**Problem:** Headers scroll out of view in large tables\n\n**Automation:** YES - Add `sticky top-0 z-10` to thead (15-20 min)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 71,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Inline Column Filters Missing (44 tables)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Inline Column Filters Missing (44 tables) bug **Impact:** 44 tables\n**Severity:** MEDIUM - Feature completeness\n**Rule Violation:** RULE #19.3 (Table Standards)\n\n**Problem:** No filter inputs in column headers for power users\n\n**Automation:** NO - Manual work (3-5 hours)\n\n**Affected Pages:** PriceBooksPage (2 tables), SuppliersPage, JobDetailPage (3 tables), ContactDetailPage (3 tables)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 44 tables\n**Severity:** MEDIUM - Feature completeness\n**Rule Violation:** RULE #19.3 (Table Standards)\n\n**Problem:** No filter inputs in column headers for power users\n\n**Automation:** NO - Manual work (3-5 hours)\n\n**Affected Pages:** PriceBooksPage (2 tables), SuppliersPage, JobDetailPage (3 tables), ContactDetailPage (3 tables)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 72,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Icon Buttons Missing aria-label (50 components)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Icon Buttons Missing aria-label (50 components) bug **Impact:** ~50 icon buttons\n**Severity:** MEDIUM - Screen reader support\n**Rule Violation:** RULE #19.12 (Accessibility)\n\n**Problem:** Icon-only buttons have no label for screen readers\n\n**Automation:** PARTIAL - Requires semantic label for each button (1-2 hours)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** ~50 icon buttons\n**Severity:** MEDIUM - Screen reader support\n**Rule Violation:** RULE #19.12 (Accessibility)\n\n**Problem:** Icon-only buttons have no label for screen readers\n\n**Automation:** PARTIAL - Requires semantic label for each button (1-2 hours)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 73,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Search Results Count Not Displayed (53 components)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Search Results Count Not Displayed (53 components) bug **Impact:** 53 search boxes\n**Severity:** MEDIUM - User feedback/clarity\n**Rule Violation:** RULE #19.20 (Search Standards)\n\n**Problem:** No count of results shown when user searches\n\n**Automation:** YES - Template addition (30 min)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "bug",
    "description": "**Impact:** 53 search boxes\n**Severity:** MEDIUM - User feedback/clarity\n**Rule Violation:** RULE #19.20 (Search Standards)\n\n**Problem:** No count of results shown when user searches\n\n**Automation:** YES - Template addition (30 min)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 74,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "UI Testing Infrastructure State",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "UI Testing Infrastructure State test **Current State:**\n\n✅ **E2E Tests:**\n- Framework: Playwright v1.56.1\n- Tests: 1 Gantt cascade test with bug-hunter diagnostics\n- Location: `frontend/tests/e2e/gantt-cascade.spec.js`\n- Features: API monitoring, state tracking, console log monitoring, screenshots\n\n✅ **Unit Test Setup:**\n- Framework: Vitest v4.0.8\n- Configuration: Exists but no tests written\n\n**Missing Tests:**\n❌ Visual regression tests (Percy, BackstopJS)\n❌ Accessibility tests (axe-core, jest-axe)\n❌ UI component unit tests (Vitest unused)\n❌ Browser compatibility (only Chromium)\n❌ Responsive/mobile tests\n❌ Dark mode screenshot tests\n❌ Performance tests (Lighthouse)\n\n**High Value Quick Wins:**\n1. Dark mode rendering (screenshot tests)\n2. Accessibility scan (axe-core automated)\n3. Responsive layouts (viewport testing)\n4. Color contrast (automated a11y check)\n5. Search clear button functionality\n6. Modal close button functionality\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "test",
    "description": "**Current State:**\n\n✅ **E2E Tests:**\n- Framework: Playwright v1.56.1\n- Tests: 1 Gantt cascade test with bug-hunter diagnostics\n- Location: `frontend/tests/e2e/gantt-cascade.spec.js`\n- Features: API monitoring, state tracking, console log monitoring, screenshots\n\n✅ **Unit Test Setup:**\n- Framework: Vitest v4.0.8\n- Configuration: Exists but no tests written\n\n**Missing Tests:**\n❌ Visual regression tests (Percy, BackstopJS)\n❌ Accessibility tests (axe-core, jest-axe)\n❌ UI component unit tests (Vitest unused)\n❌ Browser compatibility (only Chromium)\n❌ Responsive/mobile tests\n❌ Dark mode screenshot tests\n❌ Performance tests (Lighthouse)\n\n**High Value Quick Wins:**\n1. Dark mode rendering (screenshot tests)\n2. Accessibility scan (axe-core automated)\n3. Responsive layouts (viewport testing)\n4. Color contrast (automated a11y check)\n5. Search clear button functionality\n6. Modal close button functionality\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 75,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "UI/UX Enhancement Roadmap",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "UI/UX Enhancement Roadmap dev_note **Priority Matrix:**\n\n**Quick Wins (1-2 hours total):**\n- ✅ Fix deprecated color classes: amber→yellow, emerald→green (COMPLETED 2025-11-16)\n- [ ] Add clear buttons to 73 search boxes (30-40 min, automatable)\n- [ ] Add close buttons to 58 modals (20-30 min, automatable)\n- [ ] Add sticky headers to 36 tables (15-20 min, automatable)\n\n**High Impact (3-5 hours):**\n- [ ] Add action buttons to 66 empty states (1-2 hours, manual)\n- [ ] Add inline filters to 44 tables (3-5 hours, manual)\n- [ ] Add aria-labels to 50 icon buttons (1-2 hours, manual)\n- [ ] Add search result counts to 53 search boxes (30 min, automatable)\n\n**Medium Impact (5-10 hours):**\n- [ ] Badge icon enhancement (95 badges, 2-3 hours)\n- [ ] URL state sync for 20 tab components (2 hours)\n- [ ] Loading spinners for 12 pages (1 hour)\n- [ ] Button hierarchy audit (100 buttons, 3 hours)\n\n**Future Enhancements:**\n- [ ] Storybook integration (component showcase)\n- [ ] Accessibility scanning (axe-core in CI/CD)\n- [ ] Performance optimization (memoization audit)\n- [ ] Responsive design system documentation\n- [ ] Design tokens export (Figma integration)\n",
    "created_at": "2025-11-16 21:29:53 +1000",
    "updated_at": "2025-11-16 21:29:53 +1000",
    "entry_type": "dev_note",
    "description": "**Priority Matrix:**\n\n**Quick Wins (1-2 hours total):**\n- ✅ Fix deprecated color classes: amber→yellow, emerald→green (COMPLETED 2025-11-16)\n- [ ] Add clear buttons to 73 search boxes (30-40 min, automatable)\n- [ ] Add close buttons to 58 modals (20-30 min, automatable)\n- [ ] Add sticky headers to 36 tables (15-20 min, automatable)\n\n**High Impact (3-5 hours):**\n- [ ] Add action buttons to 66 empty states (1-2 hours, manual)\n- [ ] Add inline filters to 44 tables (3-5 hours, manual)\n- [ ] Add aria-labels to 50 icon buttons (1-2 hours, manual)\n- [ ] Add search result counts to 53 search boxes (30 min, automatable)\n\n**Medium Impact (5-10 hours):**\n- [ ] Badge icon enhancement (95 badges, 2-3 hours)\n- [ ] URL state sync for 20 tab components (2 hours)\n- [ ] Loading spinners for 12 pages (1 hour)\n- [ ] Button hierarchy audit (100 buttons, 3 hours)\n\n**Future Enhancements:**\n- [ ] Storybook integration (component showcase)\n- [ ] Accessibility scanning (axe-core in CI/CD)\n- [ ] Performance optimization (memoization audit)\n- [ ] Responsive design system documentation\n- [ ] Design tokens export (Figma integration)\n",
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 76,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "Claude Code Commands",
    "title": "Claude Code Commands Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude Code Commands Configuration Claude Code Commands dev_note 25 commands configured for Claude Code - **Run all agents in parallel**: /ag, all agents, allagent\n- **Run Backend Developer agent**: /backend, backend, backend dev\n- **Run Frontend Developer agent**: /frontend, frontend, frontend dev\n- **Run Production Bug Hunter agent**: /bug-hunter, bug hunter, production bug hunter\n- **Run Deploy Manager agent**: /deploy, deploy\n- **Run Planning Collaborator agent**: /plan, plan, planning\n- **Run Gantt Bug Hunter agent**: /gantt, gantt\n- **Create new API endpoint**: /api, create api\n- **Add database migration**: /migration, add migration\n- **Fix N+1 query**: /n+1, fix n+1\n- **Create new React component**: /component, create component\n- **Add dark mode support**: /darkmode, dark mode\n- **Fix responsive layout**: /responsive, fix responsive\n- **Analyze Heroku logs**: /logs, heroku logs\n- **Debug production error**: /debug, debug error\n- **Check deployment health**: /health, check health\n- **Run database migrations on staging**: /migrate, run migrations\n- **Plan new feature**: /feature, plan feature\n- **Design database schema**: /schema, design schema\n- **Run Gantt visual tests**: /gantt-test, test gantt\n- **Verify timezone compliance**: /timezone, check timezone\n- **Test cascade behavior**: /cascade, test cascade\n- **Check working days enforcement**: /workdays, working days\n- **Create service object**: /service, create service\n- **Add background job**: /job, background job",
    "created_at": "2025-11-16 22:44:26 +1000",
    "updated_at": "2025-11-16 22:44:26 +1000",
    "entry_type": "dev_note",
    "description": "25 commands configured for Claude Code",
    "details": "- **Run all agents in parallel**: /ag, all agents, allagent\n- **Run Backend Developer agent**: /backend, backend, backend dev\n- **Run Frontend Developer agent**: /frontend, frontend, frontend dev\n- **Run Production Bug Hunter agent**: /bug-hunter, bug hunter, production bug hunter\n- **Run Deploy Manager agent**: /deploy, deploy\n- **Run Planning Collaborator agent**: /plan, plan, planning\n- **Run Gantt Bug Hunter agent**: /gantt, gantt\n- **Create new API endpoint**: /api, create api\n- **Add database migration**: /migration, add migration\n- **Fix N+1 query**: /n+1, fix n+1\n- **Create new React component**: /component, create component\n- **Add dark mode support**: /darkmode, dark mode\n- **Fix responsive layout**: /responsive, fix responsive\n- **Analyze Heroku logs**: /logs, heroku logs\n- **Debug production error**: /debug, debug error\n- **Check deployment health**: /health, check health\n- **Run database migrations on staging**: /migrate, run migrations\n- **Plan new feature**: /feature, plan feature\n- **Design database schema**: /schema, design schema\n- **Run Gantt visual tests**: /gantt-test, test gantt\n- **Verify timezone compliance**: /timezone, check timezone\n- **Test cascade behavior**: /cascade, test cascade\n- **Check working days enforcement**: /workdays, working days\n- **Create service object**: /service, create service\n- **Add background job**: /job, background job",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 77,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "Claude Code Slang",
    "title": "Claude Code Slang Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude Code Slang Configuration Claude Code Slang dev_note 10 slang shortcuts configured for Claude Code - **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **cont**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule",
    "created_at": "2025-11-16 22:44:43 +1000",
    "updated_at": "2025-11-16 22:44:43 +1000",
    "entry_type": "dev_note",
    "description": "10 slang shortcuts configured for Claude Code",
    "details": "- **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **cont**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 78,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "Claude Code Slang",
    "title": "Claude Code Slang Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude Code Slang Configuration Claude Code Slang dev_note 10 slang shortcuts configured for Claude Code - **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **cont**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule",
    "created_at": "2025-11-16 22:47:29 +1000",
    "updated_at": "2025-11-16 22:47:29 +1000",
    "entry_type": "dev_note",
    "description": "10 slang shortcuts configured for Claude Code",
    "details": "- **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **cont**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 79,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "Claude Code Slang",
    "title": "Claude Code Slang Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude Code Slang Configuration Claude Code Slang dev_note 12 slang shortcuts configured for Claude Code - **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **con**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule\n- **ub**: Update Bible\n- **task**: Is the Actual PArt that has a duration on the Gantt",
    "created_at": "2025-11-16 23:47:26 +1000",
    "updated_at": "2025-11-16 23:47:26 +1000",
    "entry_type": "dev_note",
    "description": "12 slang shortcuts configured for Claude Code",
    "details": "- **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **con**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule\n- **ub**: Update Bible\n- **task**: Is the Actual PArt that has a duration on the Gantt",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 80,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": "AgentShortcutsTab",
    "title": "Chapter 19 Table Compliance Implementation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter 19 Table Compliance Implementation AgentShortcutsTab architecture Implemented full Chapter 19 table compliance for Claude Code shortcuts management, including column reordering, visual drag indicators, and proper event separation. **Features Implemented:**\n\n1. **Column Reordering** - HTML5 drag-and-drop API with state management\n2. **Visual Drag Indicators** - Bars3Icon (≡) on all draggable columns\n3. **Toolbar Layout** - Search left, bulk actions + edit buttons right\n4. **Event Separation** - Drag handle does not trigger sorting\n5. **Vertical Alignment** - Fixed with minHeight: 44px\n\n**Technical Implementation:**\n- Added columnOrderCommands/columnOrderSlang state arrays\n- Added draggingColumnCommands/draggingColumnSlang state\n- Implemented onDragStart, onDragOver, onDrop, onDragEnd handlers\n- Separated drag handle (Bars3Icon) from sortable area\n- Added e.stopPropagation() to prevent event conflicts\n\n**Files Modified:**\n- frontend/src/components/settings/AgentShortcutsTab.jsx (lines 14, 35-36, 49-50, 633-660, 823-850) **Trade-offs:**\n- State complexity: Dual table state requires separate variables\n- Column persistence: Currently in-memory only (could add localStorage)\n- Performance: Drag-drop re-renders entire header (acceptable for small tables)\n\n**Future Enhancements:**\n- Add localStorage persistence for column order\n- Add keyboard shortcuts for column reordering\n- Add column order reset button",
    "created_at": "2025-11-17 00:00:07 +1000",
    "updated_at": "2025-11-17 00:00:07 +1000",
    "entry_type": "architecture",
    "description": "Implemented full Chapter 19 table compliance for Claude Code shortcuts management, including column reordering, visual drag indicators, and proper event separation.",
    "details": "**Features Implemented:**\n\n1. **Column Reordering** - HTML5 drag-and-drop API with state management\n2. **Visual Drag Indicators** - Bars3Icon (≡) on all draggable columns\n3. **Toolbar Layout** - Search left, bulk actions + edit buttons right\n4. **Event Separation** - Drag handle does not trigger sorting\n5. **Vertical Alignment** - Fixed with minHeight: 44px\n\n**Technical Implementation:**\n- Added columnOrderCommands/columnOrderSlang state arrays\n- Added draggingColumnCommands/draggingColumnSlang state\n- Implemented onDragStart, onDragOver, onDrop, onDragEnd handlers\n- Separated drag handle (Bars3Icon) from sortable area\n- Added e.stopPropagation() to prevent event conflicts\n\n**Files Modified:**\n- frontend/src/components/settings/AgentShortcutsTab.jsx (lines 14, 35-36, 49-50, 633-660, 823-850)",
    "examples": null,
    "recommendations": "**Trade-offs:**\n- State complexity: Dual table state requires separate variables\n- Column persistence: Currently in-memory only (could add localStorage)\n- Performance: Drag-drop re-renders entire header (acceptable for small tables)\n\n**Future Enhancements:**\n- Add localStorage persistence for column order\n- Add keyboard shortcuts for column reordering\n- Add column order reset button",
    "rule_reference": "Bible Chapter 19 (RULES #19.2, #19.3, #19.5B, #19.7, #19.8, #19.9, #19.11A, #19.13, #19.14, #19.16)",
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 81,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": "Claude Code Slang",
    "title": "Claude Code Slang Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude Code Slang Configuration Claude Code Slang dev_note 12 slang shortcuts configured for Claude Code - **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **con**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule\n- **ub**: Update Bible\n- **c19**: Chapter 19",
    "created_at": "2025-11-17 05:48:16 +1000",
    "updated_at": "2025-11-17 05:48:16 +1000",
    "entry_type": "dev_note",
    "description": "12 slang shortcuts configured for Claude Code",
    "details": "- **sm**: Schedule Master\n- **po**: Purchase Order\n- **est**: Estimate\n- **inv**: Invoice\n- **sup**: Supplier\n- **con**: Contact\n- **pb**: Price Book\n- **wf**: Workflow\n- **gantt**: Gantt Chart\n- **sched**: Schedule\n- **ub**: Update Bible\n- **c19**: Chapter 19",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": null,
    "difficulty": null,
    "summary": null,
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": null
  },
  {
    "id": 82,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Table Component Selection Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Table Component Selection Pattern component Decision tree for choosing between DataTable.jsx (read-only, basic sorting) vs Full table pattern (editing, bulk actions, advanced features) TRAPID_BIBLE.md RULE #19.1",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.1",
    "difficulty": null,
    "summary": "Decision tree for choosing between DataTable.jsx (read-only, basic sorting) vs Full table pattern (editing, bulk actions, advanced features)",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.1"
  },
  {
    "id": 83,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "State Persistence Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "State Persistence Pattern component How to persist table state (filters, column order, visibility) to localStorage TRAPID_BIBLE.md RULE #19.13",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.13",
    "difficulty": null,
    "summary": "How to persist table state (filters, column order, visibility) to localStorage",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.13"
  },
  {
    "id": 84,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Dark Mode Implementation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Dark Mode Implementation component Pattern for implementing dark mode support in table components TRAPID_BIBLE.md RULE #19.15",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.15",
    "difficulty": null,
    "summary": "Pattern for implementing dark mode support in table components",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.15"
  },
  {
    "id": 85,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Table Header Implementation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Table Header Implementation component Required header elements: sortable columns, visibility controls, sticky headers, dark mode TRAPID_BIBLE.md RULE #19.2",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.2",
    "difficulty": null,
    "summary": "Required header elements: sortable columns, visibility controls, sticky headers, dark mode",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.2"
  },
  {
    "id": 86,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Form Standards Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Form Standards Pattern component Standard patterns for form layout, validation, and submission TRAPID_BIBLE.md RULE #19.21",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.21",
    "difficulty": null,
    "summary": "Standard patterns for form layout, validation, and submission",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.21"
  },
  {
    "id": 87,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Column Filter Implementation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Filter Implementation component How to implement inline column filters in table headers TRAPID_BIBLE.md RULE #19.3",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.3",
    "difficulty": null,
    "summary": "How to implement inline column filters in table headers",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.3"
  },
  {
    "id": 88,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Column Resizing Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Resizing Pattern component Pattern for implementing draggable column resize handles TRAPID_BIBLE.md RULE #19.4",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.4",
    "difficulty": null,
    "summary": "Pattern for implementing draggable column resize handles",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.4"
  },
  {
    "id": 89,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Column Reordering Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Reordering Pattern component Pattern for implementing drag-and-drop column reordering TRAPID_BIBLE.md RULE #19.5",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.5",
    "difficulty": null,
    "summary": "Pattern for implementing drag-and-drop column reordering",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.5"
  },
  {
    "id": 90,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Row Selection Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Row Selection Pattern component Pattern for checkbox-based row selection with bulk actions TRAPID_BIBLE.md RULE #19.9",
    "created_at": "2025-11-17 07:51:22 +1000",
    "updated_at": "2025-11-17 07:51:22 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.9",
    "difficulty": null,
    "summary": "Pattern for checkbox-based row selection with bulk actions",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.9"
  },
  {
    "id": 91,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Standardized Toolbar Layout Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Standardized Toolbar Layout Pattern component Standard layout for table toolbars: Global search (left), action buttons in specific order (right) TRAPID_BIBLE.md RULE #19.11A",
    "created_at": "2025-11-17 07:52:02 +1000",
    "updated_at": "2025-11-17 07:52:02 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.11A",
    "difficulty": null,
    "summary": "Standard layout for table toolbars: Global search (left), action buttons in specific order (right)",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.11A"
  },
  {
    "id": 92,
    "chapter_number": 19,
    "chapter_name": "UI/UX Standards & Patterns",
    "component": null,
    "title": "Column Visibility Toggle Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Visibility Toggle Pattern component Pattern for eye icon dropdown to show/hide columns TRAPID_BIBLE.md RULE #19.5A",
    "created_at": "2025-11-17 07:52:02 +1000",
    "updated_at": "2025-11-17 07:52:02 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "19.5A",
    "difficulty": null,
    "summary": "Pattern for eye icon dropdown to show/hide columns",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #19.5A"
  },
  {
    "id": 93,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "Lexicon Update Workflow - Database-Driven Documentation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Lexicon Update Workflow - Database-Driven Documentation feature Step-by-step workflow for updating Lexicon via database UI and exporting to markdown. # Example: Adding a bug entry via Rails console\nDocumentationEntry.create!(\n  chapter_number: 9,\n  chapter_name: 'Gantt & Schedule Master',\n  entry_type: 'bug',\n  title: 'Gantt Shaking During Cascade',\n  status: 'fixed',\n  severity: 'high',\n  first_reported: '2025-11-10',\n  fixed_date: '2025-11-11',\n  description: 'Visual shaking during dependency updates',\n  root_cause: 'isLoadingData not properly managing render locks',\n  solution: 'Added proper lock timing in cascade handler',\n  rule_reference: 'Chapter 9, RULE #9.2'\n) TRAPID_BIBLE.md RULE #0 - Documentation Maintenance **Lexicon is database-driven** - Source of truth is `documentation_entries` table, NOT the .md file.\n\n**Update Workflow:**\n1. Go to Trapid app → Documentation page\n2. Click \"📕 TRAPID Lexicon\"\n3. Add/edit entries via UI (stores in documentation_entries table)\n4. Run: `bin/rails trapid:export_lexicon`\n5. Commit the updated TRAPID_LEXICON.md file\n\n**Export Command:**\n```bash\ncd backend\nbin/rails trapid:export_lexicon\n```\n\n**Git Workflow:**\n```bash\ngit add TRAPID_DOCS/TRAPID_LEXICON.md\ngit commit -m \"docs: Update Lexicon from database export\"\n```",
    "created_at": "2025-11-17 08:01:20 +1000",
    "updated_at": "2025-11-17 08:01:20 +1000",
    "entry_type": "feature",
    "description": null,
    "details": "**Lexicon is database-driven** - Source of truth is `documentation_entries` table, NOT the .md file.\n\n**Update Workflow:**\n1. Go to Trapid app → Documentation page\n2. Click \"📕 TRAPID Lexicon\"\n3. Add/edit entries via UI (stores in documentation_entries table)\n4. Run: `bin/rails trapid:export_lexicon`\n5. Commit the updated TRAPID_LEXICON.md file\n\n**Export Command:**\n```bash\ncd backend\nbin/rails trapid:export_lexicon\n```\n\n**Git Workflow:**\n```bash\ngit add TRAPID_DOCS/TRAPID_LEXICON.md\ngit commit -m \"docs: Update Lexicon from database export\"\n```",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "0.1",
    "difficulty": null,
    "summary": "Step-by-step workflow for updating Lexicon via database UI and exporting to markdown.",
    "code_example": "# Example: Adding a bug entry via Rails console\nDocumentationEntry.create!(\n  chapter_number: 9,\n  chapter_name: 'Gantt & Schedule Master',\n  entry_type: 'bug',\n  title: 'Gantt Shaking During Cascade',\n  status: 'fixed',\n  severity: 'high',\n  first_reported: '2025-11-10',\n  fixed_date: '2025-11-11',\n  description: 'Visual shaking during dependency updates',\n  root_cause: 'isLoadingData not properly managing render locks',\n  solution: 'Added proper lock timing in cascade handler',\n  rule_reference: 'Chapter 9, RULE #9.2'\n)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #0 - Documentation Maintenance"
  },
  {
    "id": 94,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "Database Schema Reference - documentation_entries Table",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Database Schema Reference - documentation_entries Table util Complete field reference for documentation_entries table structure. TRAPID_BIBLE.md RULE #0 **Database Schema Fields:**\n\n**Core Fields:**\n- `chapter_number` - Which chapter (0-20)\n- `chapter_name` - Chapter title\n- `entry_type` - Type: bug, architecture, test, performance, dev_note, common_issue, component, feature, util, hook, integration, optimization\n- `title` - Entry title\n\n**Lexicon-Specific (bugs):**\n- `status` - For bugs: open, fixed, by_design, monitoring\n- `severity` - For bugs: low, medium, high, critical\n- `first_reported` - Date discovered (YYYY-MM-DD)\n- `fixed_date` - Date resolved (YYYY-MM-DD)\n\n**Teacher-Specific:**\n- `section_number` - Format: X.Y or X.YA (e.g., 19.1, 19.11A)\n- `difficulty` - beginner, intermediate, advanced\n- `summary` - Quick summary/description\n- `code_example` - Full code blocks\n- `common_mistakes` - What to avoid\n- `testing_strategy` - How to test\n- `related_rules` - Link to Bible rules\n\n**Universal Content Fields:**\n- `description` - Brief summary\n- `scenario` - How it manifests\n- `root_cause` - Technical explanation\n- `solution` - How to fix/implement\n- `prevention` - How to avoid\n- `component` - Specific component name\n- `details` - Step-by-step guides\n- `examples` - Examples\n- `recommendations` - Best practices\n- `rule_reference` - Link to Bible RULE",
    "created_at": "2025-11-17 08:01:20 +1000",
    "updated_at": "2025-11-17 08:01:20 +1000",
    "entry_type": "util",
    "description": null,
    "details": "**Database Schema Fields:**\n\n**Core Fields:**\n- `chapter_number` - Which chapter (0-20)\n- `chapter_name` - Chapter title\n- `entry_type` - Type: bug, architecture, test, performance, dev_note, common_issue, component, feature, util, hook, integration, optimization\n- `title` - Entry title\n\n**Lexicon-Specific (bugs):**\n- `status` - For bugs: open, fixed, by_design, monitoring\n- `severity` - For bugs: low, medium, high, critical\n- `first_reported` - Date discovered (YYYY-MM-DD)\n- `fixed_date` - Date resolved (YYYY-MM-DD)\n\n**Teacher-Specific:**\n- `section_number` - Format: X.Y or X.YA (e.g., 19.1, 19.11A)\n- `difficulty` - beginner, intermediate, advanced\n- `summary` - Quick summary/description\n- `code_example` - Full code blocks\n- `common_mistakes` - What to avoid\n- `testing_strategy` - How to test\n- `related_rules` - Link to Bible rules\n\n**Universal Content Fields:**\n- `description` - Brief summary\n- `scenario` - How it manifests\n- `root_cause` - Technical explanation\n- `solution` - How to fix/implement\n- `prevention` - How to avoid\n- `component` - Specific component name\n- `details` - Step-by-step guides\n- `examples` - Examples\n- `recommendations` - Best practices\n- `rule_reference` - Link to Bible RULE",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "0.2",
    "difficulty": null,
    "summary": "Complete field reference for documentation_entries table structure.",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #0"
  },
  {
    "id": 95,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "API Endpoints Reference - Documentation System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "API Endpoints Reference - Documentation System integration REST API endpoints for managing documentation entries. // Example: Creating a documentation entry via API\nconst response = await api.post('/api/v1/documentation_entries', {\n  documentation_entry: {\n    chapter_number: 19,\n    chapter_name: 'UI/UX Standards & Patterns',\n    entry_type: 'component',\n    section_number: '19.1',\n    title: 'Table Component Selection Pattern',\n    summary: 'Decision tree for choosing table type',\n    related_rules: 'TRAPID_BIBLE.md RULE #19.1'\n  }\n})\n\n// Example: Exporting Lexicon\nawait api.post('/api/v1/documentation_entries/export_lexicon') TRAPID_BIBLE.md RULE #0 **Documentation Entries API:**\n\n`GET /api/v1/documentation_entries` - List entries\n  - Query params: chapter, type, status, severity, search, category (lexicon/teacher)\n  \n`POST /api/v1/documentation_entries` - Create entry\n  - Body: { documentation_entry: { chapter_number, title, entry_type, ... } }\n  \n`GET /api/v1/documentation_entries/:id` - Get single entry\n\n`PUT /api/v1/documentation_entries/:id` - Update entry\n  - Body: { documentation_entry: { ... } }\n\n`DELETE /api/v1/documentation_entries/:id` - Delete entry\n\n`GET /api/v1/documentation_entries/stats` - Get statistics\n\n`POST /api/v1/documentation_entries/export_lexicon` - Export Lexicon to markdown\n\n`POST /api/v1/documentation_entries/export_teacher` - Export Teacher to markdown\n\n**Legacy Routes (backwards compatible):**\n`/api/v1/documented_bugs/*` - Maps to documentation_entries controller",
    "created_at": "2025-11-17 08:01:20 +1000",
    "updated_at": "2025-11-17 08:01:20 +1000",
    "entry_type": "integration",
    "description": null,
    "details": "**Documentation Entries API:**\n\n`GET /api/v1/documentation_entries` - List entries\n  - Query params: chapter, type, status, severity, search, category (lexicon/teacher)\n  \n`POST /api/v1/documentation_entries` - Create entry\n  - Body: { documentation_entry: { chapter_number, title, entry_type, ... } }\n  \n`GET /api/v1/documentation_entries/:id` - Get single entry\n\n`PUT /api/v1/documentation_entries/:id` - Update entry\n  - Body: { documentation_entry: { ... } }\n\n`DELETE /api/v1/documentation_entries/:id` - Delete entry\n\n`GET /api/v1/documentation_entries/stats` - Get statistics\n\n`POST /api/v1/documentation_entries/export_lexicon` - Export Lexicon to markdown\n\n`POST /api/v1/documentation_entries/export_teacher` - Export Teacher to markdown\n\n**Legacy Routes (backwards compatible):**\n`/api/v1/documented_bugs/*` - Maps to documentation_entries controller",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "0.3",
    "difficulty": null,
    "summary": "REST API endpoints for managing documentation entries.",
    "code_example": "// Example: Creating a documentation entry via API\nconst response = await api.post('/api/v1/documentation_entries', {\n  documentation_entry: {\n    chapter_number: 19,\n    chapter_name: 'UI/UX Standards & Patterns',\n    entry_type: 'component',\n    section_number: '19.1',\n    title: 'Table Component Selection Pattern',\n    summary: 'Decision tree for choosing table type',\n    related_rules: 'TRAPID_BIBLE.md RULE #19.1'\n  }\n})\n\n// Example: Exporting Lexicon\nawait api.post('/api/v1/documentation_entries/export_lexicon')",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #0"
  },
  {
    "id": 96,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "Component Creation Enforcement Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Component Creation Enforcement Pattern component Automated workflow Claude Code must follow before creating any new component. // Example: Creating LexiconTableView.jsx (CORRECT workflow)\n\n// 1. User requests: \"Create a table view for Lexicon\"\n// 2. Claude recognizes: filename contains \"Table\" → need Chapter 19\n// 3. Claude reads: TRAPID_BIBLE.md Chapter 19\n// 4. Claude sees: RULE #19.1 requires asking user for table type\n// 5. Claude asks: \"Should I use:\n  1. DataTable.jsx (read-only)\n  2. Full advanced table?\"\n// 6. User responds: \"2\"\n// 7. Claude creates: LexiconTableView.jsx with ALL Chapter 19 features\n\n// Component mapping reference:\nconst COMPONENT_CHAPTER_MAP = {\n  table: [19],\n  modal: [19],\n  form: [19],\n  gantt: [9, 19],\n  auth: [1],\n  contact: [3],\n  pricebook: [4],\n  job: [5],\n  estimate: [6],\n  po: [8],\n  xero: [15]\n} **Common Mistakes:**\n\n❌ Creating component immediately without reading Bible\n❌ Skipping user confirmation when rules require it\n❌ Reading only part of the chapter\n❌ Ignoring NEVER rules because they seem optional\n❌ Assuming best practices override Bible rules\n\n**Consequences:**\n- Non-compliant component\n- Requires refactoring\n- Wastes time and tokens\n- Violates RULE #0.1 TRAPID_BIBLE.md RULE #0.1 **Enforcement Workflow:**\n\n**Step 1: Identify Component Type**\nCheck filename pattern:\n- `*Table*.jsx` → Chapter 19 (UI/UX)\n- `*Modal*.jsx` → Chapter 19 (UI/UX)\n- `*Form*.jsx` → Chapter 19 (UI/UX)\n- `*Gantt*.jsx` → Chapter 9 (Gantt) + Chapter 19 (UI/UX)\n- `*Auth*.jsx` → Chapter 1 (Authentication)\n- `*Contact*.jsx` → Chapter 3 (Contacts)\n- See RULE #0.1 for full mapping table\n\n**Step 2: Read Required Chapters**\nUse Read tool to load:\n```\nRead: /Users/rob/Projects/trapid/TRAPID_DOCS/TRAPID_BIBLE.md\n  - offset: [chapter start]\n  - limit: [chapter length]\n```\n\n**Step 3: Follow ALL Rules**\nParse chapter for:\n- MUST directives\n- NEVER directives\n- ALWAYS directives\n- User confirmation requirements\n\n**Step 4: Ask User When Required**\nSome rules require asking (e.g., RULE #19.1 table type)\n\n**Step 5: Create Component**\nNow write the file following all discovered rules",
    "created_at": "2025-11-17 08:02:00 +1000",
    "updated_at": "2025-11-17 08:02:00 +1000",
    "entry_type": "component",
    "description": null,
    "details": "**Enforcement Workflow:**\n\n**Step 1: Identify Component Type**\nCheck filename pattern:\n- `*Table*.jsx` → Chapter 19 (UI/UX)\n- `*Modal*.jsx` → Chapter 19 (UI/UX)\n- `*Form*.jsx` → Chapter 19 (UI/UX)\n- `*Gantt*.jsx` → Chapter 9 (Gantt) + Chapter 19 (UI/UX)\n- `*Auth*.jsx` → Chapter 1 (Authentication)\n- `*Contact*.jsx` → Chapter 3 (Contacts)\n- See RULE #0.1 for full mapping table\n\n**Step 2: Read Required Chapters**\nUse Read tool to load:\n```\nRead: /Users/rob/Projects/trapid/TRAPID_DOCS/TRAPID_BIBLE.md\n  - offset: [chapter start]\n  - limit: [chapter length]\n```\n\n**Step 3: Follow ALL Rules**\nParse chapter for:\n- MUST directives\n- NEVER directives\n- ALWAYS directives\n- User confirmation requirements\n\n**Step 4: Ask User When Required**\nSome rules require asking (e.g., RULE #19.1 table type)\n\n**Step 5: Create Component**\nNow write the file following all discovered rules",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "0.4",
    "difficulty": null,
    "summary": "Automated workflow Claude Code must follow before creating any new component.",
    "code_example": "// Example: Creating LexiconTableView.jsx (CORRECT workflow)\n\n// 1. User requests: \"Create a table view for Lexicon\"\n// 2. Claude recognizes: filename contains \"Table\" → need Chapter 19\n// 3. Claude reads: TRAPID_BIBLE.md Chapter 19\n// 4. Claude sees: RULE #19.1 requires asking user for table type\n// 5. Claude asks: \"Should I use:\n  1. DataTable.jsx (read-only)\n  2. Full advanced table?\"\n// 6. User responds: \"2\"\n// 7. Claude creates: LexiconTableView.jsx with ALL Chapter 19 features\n\n// Component mapping reference:\nconst COMPONENT_CHAPTER_MAP = {\n  table: [19],\n  modal: [19],\n  form: [19],\n  gantt: [9, 19],\n  auth: [1],\n  contact: [3],\n  pricebook: [4],\n  job: [5],\n  estimate: [6],\n  po: [8],\n  xero: [15]\n}",
    "common_mistakes": "**Common Mistakes:**\n\n❌ Creating component immediately without reading Bible\n❌ Skipping user confirmation when rules require it\n❌ Reading only part of the chapter\n❌ Ignoring NEVER rules because they seem optional\n❌ Assuming best practices override Bible rules\n\n**Consequences:**\n- Non-compliant component\n- Requires refactoring\n- Wastes time and tokens\n- Violates RULE #0.1",
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #0.1"
  },
  {
    "id": 97,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "Bug Fix Documentation Workflow",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Bug Fix Documentation Workflow feature Complete workflow for documenting every bug fix in the Lexicon. # Example Lexicon Entry Fields (via UI)\n\n**Required:**\nchapter_number: 9\nchapter_name: \"Gantt & Schedule Master\"\nentry_type: \"bug\"\ntitle: \"Gantt Shaking During Cascade\"\n\n**Bug-Specific:**\nstatus: \"fixed\"\nseverity: \"high\"\nfirst_reported: \"2025-11-10\"\nfixed_date: \"2025-11-11\"\n\n**Content:**\ndescription: \"Visual shaking observed during dependency updates in Gantt chart\"\n\nscenario: \"When dragging a task with dependencies, the chart would visibly shake/flicker\"\n\nroot_cause: \"isLoadingData lock not properly set during cascade operations, causing re-renders mid-update\"\n\nsolution: \"Added proper isLoadingData.current = true at start of cascade, set to false after 300ms timeout to allow DOM to settle\"\n\nprevention: \"Always use isLoadingData lock for any batch Gantt updates. See RULE #9.2 for timing requirements\"\n\ncomponent: \"DHtmlxGanttView.jsx\"\n\nrule_reference: \"Chapter 9, RULE #9.2\"\n\n# After saving, export:\n# bin/rails trapid:export_lexicon **Testing the Documentation:**\n\n1. Verify entry appears in UI\n2. Check export generates correct markdown\n3. Confirm cross-references link properly\n4. Test search finds the entry\n5. Validate all fields populated TRAPID_BIBLE.md RULE #0 - Bug Fix Documentation **🔴 CRITICAL: Every bug fix MUST be documented**\n\n**Complete Workflow:**\n\n**1. Fix the Bug**\n- Write the code fix\n- Test locally\n- Verify fix works\n\n**2. Update Lexicon via UI**\nNavigate to Trapid app:\n- Go to Documentation page\n- Click \"📕 TRAPID Lexicon\"\n- Click \"Add Entry\"\n- Fill in all fields (see field guide below)\n- Save\n\n**3. Export Lexicon**\n```bash\ncd backend\nbin/rails trapid:export_lexicon\n```\n\n**4. Update Bible (if needed)**\nAdd new RULE if bug revealed:\n- Protected code pattern\n- Configuration requirement\n- Critical validation\n\n**5. Commit Everything**\n```bash\ngit add [code files] TRAPID_DOCS/TRAPID_LEXICON.md\ngit commit -m \"fix: [bug description]\n\n- Fixed [issue]\n- Added Lexicon entry\n- See TRAPID_LEXICON.md Chapter X\"\n```",
    "created_at": "2025-11-17 08:02:00 +1000",
    "updated_at": "2025-11-17 08:02:00 +1000",
    "entry_type": "feature",
    "description": null,
    "details": "**🔴 CRITICAL: Every bug fix MUST be documented**\n\n**Complete Workflow:**\n\n**1. Fix the Bug**\n- Write the code fix\n- Test locally\n- Verify fix works\n\n**2. Update Lexicon via UI**\nNavigate to Trapid app:\n- Go to Documentation page\n- Click \"📕 TRAPID Lexicon\"\n- Click \"Add Entry\"\n- Fill in all fields (see field guide below)\n- Save\n\n**3. Export Lexicon**\n```bash\ncd backend\nbin/rails trapid:export_lexicon\n```\n\n**4. Update Bible (if needed)**\nAdd new RULE if bug revealed:\n- Protected code pattern\n- Configuration requirement\n- Critical validation\n\n**5. Commit Everything**\n```bash\ngit add [code files] TRAPID_DOCS/TRAPID_LEXICON.md\ngit commit -m \"fix: [bug description]\n\n- Fixed [issue]\n- Added Lexicon entry\n- See TRAPID_LEXICON.md Chapter X\"\n```",
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "0.5",
    "difficulty": null,
    "summary": "Complete workflow for documenting every bug fix in the Lexicon.",
    "code_example": "# Example Lexicon Entry Fields (via UI)\n\n**Required:**\nchapter_number: 9\nchapter_name: \"Gantt & Schedule Master\"\nentry_type: \"bug\"\ntitle: \"Gantt Shaking During Cascade\"\n\n**Bug-Specific:**\nstatus: \"fixed\"\nseverity: \"high\"\nfirst_reported: \"2025-11-10\"\nfixed_date: \"2025-11-11\"\n\n**Content:**\ndescription: \"Visual shaking observed during dependency updates in Gantt chart\"\n\nscenario: \"When dragging a task with dependencies, the chart would visibly shake/flicker\"\n\nroot_cause: \"isLoadingData lock not properly set during cascade operations, causing re-renders mid-update\"\n\nsolution: \"Added proper isLoadingData.current = true at start of cascade, set to false after 300ms timeout to allow DOM to settle\"\n\nprevention: \"Always use isLoadingData lock for any batch Gantt updates. See RULE #9.2 for timing requirements\"\n\ncomponent: \"DHtmlxGanttView.jsx\"\n\nrule_reference: \"Chapter 9, RULE #9.2\"\n\n# After saving, export:\n# bin/rails trapid:export_lexicon",
    "common_mistakes": null,
    "testing_strategy": "**Testing the Documentation:**\n\n1. Verify entry appears in UI\n2. Check export generates correct markdown\n3. Confirm cross-references link properly\n4. Test search finds the entry\n5. Validate all fields populated",
    "related_rules": "TRAPID_BIBLE.md RULE #0 - Bug Fix Documentation"
  },
  {
    "id": 98,
    "chapter_number": 0,
    "chapter_name": "Overview & System-Wide Rules",
    "component": null,
    "title": "Chapter Relationship Map - Feature Dependencies",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Chapter Relationship Map - Feature Dependencies util Understanding how chapters relate and depend on each other for complete context. TRAPID_BIBLE.md Chapter 0 - Chapter Relationship Map **Feature Dependencies Overview:**\n\n**Core Infrastructure (Used by ALL):**\n- Chapter 1: Authentication & Users\n- Chapter 2: System Administration (timezone, company settings)\n\n**Data & Content Management:**\n- Chapter 3: Contacts → Used by Ch 4 (suppliers), Ch 5 (clients), Ch 6 (quotes), Ch 8 (POs), Ch 14 (chat), Ch 15 (Xero)\n- Chapter 4: Price Books → Used by Ch 6 (estimate pricing), Ch 8 (PO pricing), Ch 17 (automation)\n- Chapter 18: Custom Tables → Standalone\n\n**Project Execution Flow:**\n1. Ch 6: Estimates & Quoting\n2. Ch 5: Jobs & Construction (central)\n3. Ch 8: Purchase Orders (from estimates)\n4. Ch 9: Gantt (visual timeline)\n5. Ch 10: Project Tasks\n6. Ch 11: Weather (affects schedule)\n\n**AI & Automation:**\n- Ch 7: AI Plan Review → Uses Ch 12 (OneDrive)\n- Ch 17: Workflows → Orchestrates Ch 4, Ch 12\n\n**Integrations:**\n- Ch 12: OneDrive → Used by Ch 5, Ch 7, Ch 17\n- Ch 13: Outlook → Links to Ch 5\n- Ch 14: Chat → For Ch 5, Ch 10\n- Ch 15: Xero → Syncs Ch 3, links Ch 8\n- Ch 16: Payments → Tracks Ch 8, reconciles Ch 15\n\n**UI/UX:**\n- Ch 19: UI/UX Standards → Applies to ALL frontend **Example 1: Creating a Job (Chapter 5)**\nRequires:\n- User (Ch 1)\n- Client contact (Ch 3)\n- Company timezone (Ch 2)\n\nMay trigger:\n- OneDrive folders (Ch 12)\n- Gantt entry (Ch 9)\n- Tasks (Ch 10)\n- Chat channel (Ch 14)\n\n**Example 2: Generating Purchase Orders (Chapter 8)**\nSource: Estimate (Ch 6)\nUses: Supplier contacts (Ch 3), Pricebook items (Ch 4)\nMay create: Workflow approval (Ch 17), Xero bill (Ch 15), Payment tracking (Ch 16)\n\n**Example 3: Gantt Scheduling (Chapter 9)**\nRequires: Job (Ch 5), Tasks (Ch 10), Weather (Ch 11), Timezone (Ch 2)\nAffects: Task due dates (Ch 10), Workflow deadlines (Ch 17) **When Working on a Feature:**\n\n1. Identify primary chapter\n2. Check this map for dependencies\n3. Read ALL related chapters\n4. Consider cross-chapter impacts\n5. Test integration points",
    "created_at": "2025-11-17 08:02:27 +1000",
    "updated_at": "2025-11-17 08:02:27 +1000",
    "entry_type": "util",
    "description": null,
    "details": "**Feature Dependencies Overview:**\n\n**Core Infrastructure (Used by ALL):**\n- Chapter 1: Authentication & Users\n- Chapter 2: System Administration (timezone, company settings)\n\n**Data & Content Management:**\n- Chapter 3: Contacts → Used by Ch 4 (suppliers), Ch 5 (clients), Ch 6 (quotes), Ch 8 (POs), Ch 14 (chat), Ch 15 (Xero)\n- Chapter 4: Price Books → Used by Ch 6 (estimate pricing), Ch 8 (PO pricing), Ch 17 (automation)\n- Chapter 18: Custom Tables → Standalone\n\n**Project Execution Flow:**\n1. Ch 6: Estimates & Quoting\n2. Ch 5: Jobs & Construction (central)\n3. Ch 8: Purchase Orders (from estimates)\n4. Ch 9: Gantt (visual timeline)\n5. Ch 10: Project Tasks\n6. Ch 11: Weather (affects schedule)\n\n**AI & Automation:**\n- Ch 7: AI Plan Review → Uses Ch 12 (OneDrive)\n- Ch 17: Workflows → Orchestrates Ch 4, Ch 12\n\n**Integrations:**\n- Ch 12: OneDrive → Used by Ch 5, Ch 7, Ch 17\n- Ch 13: Outlook → Links to Ch 5\n- Ch 14: Chat → For Ch 5, Ch 10\n- Ch 15: Xero → Syncs Ch 3, links Ch 8\n- Ch 16: Payments → Tracks Ch 8, reconciles Ch 15\n\n**UI/UX:**\n- Ch 19: UI/UX Standards → Applies to ALL frontend",
    "examples": "**Example 1: Creating a Job (Chapter 5)**\nRequires:\n- User (Ch 1)\n- Client contact (Ch 3)\n- Company timezone (Ch 2)\n\nMay trigger:\n- OneDrive folders (Ch 12)\n- Gantt entry (Ch 9)\n- Tasks (Ch 10)\n- Chat channel (Ch 14)\n\n**Example 2: Generating Purchase Orders (Chapter 8)**\nSource: Estimate (Ch 6)\nUses: Supplier contacts (Ch 3), Pricebook items (Ch 4)\nMay create: Workflow approval (Ch 17), Xero bill (Ch 15), Payment tracking (Ch 16)\n\n**Example 3: Gantt Scheduling (Chapter 9)**\nRequires: Job (Ch 5), Tasks (Ch 10), Weather (Ch 11), Timezone (Ch 2)\nAffects: Task due dates (Ch 10), Workflow deadlines (Ch 17)",
    "recommendations": "**When Working on a Feature:**\n\n1. Identify primary chapter\n2. Check this map for dependencies\n3. Read ALL related chapters\n4. Consider cross-chapter impacts\n5. Test integration points",
    "rule_reference": null,
    "section_number": "0.6",
    "difficulty": null,
    "summary": "Understanding how chapters relate and depend on each other for complete context.",
    "code_example": null,
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md Chapter 0 - Chapter Relationship Map"
  },
  {
    "id": 99,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "JWT Token Handling Implementation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "JWT Token Handling Implementation integration Complete JWT authentication pattern using JsonWebToken service for encoding and decoding tokens. # backend/app/services/json_web_token.rb\nclass JsonWebToken\n  SECRET_KEY = Rails.application.secrets.secret_key_base.to_s\n\n  def self.encode(payload, exp = 24.hours.from_now)\n    payload[:exp] = exp.to_i\n    JWT.encode(payload, SECRET_KEY)\n  end\n\n  def self.decode(token)\n    decoded = JWT.decode(token, SECRET_KEY)[0]\n    HashWithIndifferentAccess.new decoded\n  rescue JWT::DecodeError, JWT::ExpiredSignature\n    nil\n  end\nend\n\n# ApplicationController authorization\nbefore_action :authorize_request\n\ndef authorize_request\n  header = request.headers['Authorization']\n  header = header.split(' ').last if header\n\n  decoded = JsonWebToken.decode(header)\n  @current_user = User.find(decoded[:user_id]) if decoded\nrescue ActiveRecord::RecordNotFound, JWT::DecodeError\n  render json: { error: 'Unauthorized' }, status: :unauthorized\nend\n TRAPID_BIBLE.md RULE #1.1",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.1",
    "difficulty": "intermediate",
    "summary": "Complete JWT authentication pattern using JsonWebToken service for encoding and decoding tokens.",
    "code_example": "# backend/app/services/json_web_token.rb\nclass JsonWebToken\n  SECRET_KEY = Rails.application.secrets.secret_key_base.to_s\n\n  def self.encode(payload, exp = 24.hours.from_now)\n    payload[:exp] = exp.to_i\n    JWT.encode(payload, SECRET_KEY)\n  end\n\n  def self.decode(token)\n    decoded = JWT.decode(token, SECRET_KEY)[0]\n    HashWithIndifferentAccess.new decoded\n  rescue JWT::DecodeError, JWT::ExpiredSignature\n    nil\n  end\nend\n\n# ApplicationController authorization\nbefore_action :authorize_request\n\ndef authorize_request\n  header = request.headers['Authorization']\n  header = header.split(' ').last if header\n\n  decoded = JsonWebToken.decode(header)\n  @current_user = User.find(decoded[:user_id]) if decoded\nrescue ActiveRecord::RecordNotFound, JWT::DecodeError\n  render json: { error: 'Unauthorized' }, status: :unauthorized\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.1"
  },
  {
    "id": 100,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "Password Complexity Validation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Password Complexity Validation util 12-character minimum password with complexity rules using custom validation. # app/models/user.rb\nhas_secure_password\n\nvalidates :password, length: { minimum: 12 }, if: :password_required?\nvalidate :password_complexity, if: :password_required?\n\nprivate\n\ndef password_complexity\n  return unless password.present?\n\n  rules = [\n    [/[A-Z]/, 'uppercase letter'],\n    [/[a-z]/, 'lowercase letter'],\n    [/[0-9]/, 'number'],\n    [/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/, 'special character']\n  ]\n\n  rules.each do |regex, description|\n    unless password.match?(regex)\n      errors.add(:password, \"must include at least one #{description}\")\n    end\n  end\nend\n\ndef password_required?\n  password_digest.nil? || password.present?\nend\n TRAPID_BIBLE.md RULE #1.2",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.2",
    "difficulty": "beginner",
    "summary": "12-character minimum password with complexity rules using custom validation.",
    "code_example": "# app/models/user.rb\nhas_secure_password\n\nvalidates :password, length: { minimum: 12 }, if: :password_required?\nvalidate :password_complexity, if: :password_required?\n\nprivate\n\ndef password_complexity\n  return unless password.present?\n\n  rules = [\n    [/[A-Z]/, 'uppercase letter'],\n    [/[a-z]/, 'lowercase letter'],\n    [/[0-9]/, 'number'],\n    [/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/, 'special character']\n  ]\n\n  rules.each do |regex, description|\n    unless password.match?(regex)\n      errors.add(:password, \"must include at least one #{description}\")\n    end\n  end\nend\n\ndef password_required?\n  password_digest.nil? || password.present?\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.2"
  },
  {
    "id": 101,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "Role-Based Access Control",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Role-Based Access Control feature Permission system using hardcoded roles and model-based permission methods. # app/models/user.rb\nROLES = %w[user admin product_owner estimator supervisor builder].freeze\n\ndef admin?\n  role == 'admin'\nend\n\ndef can_create_templates?\n  admin? || product_owner?\nend\n\ndef can_edit_schedule?\n  admin? || product_owner? || estimator?\nend\n\n# Controller usage:\nbefore_action :check_can_edit_templates\n\ndef check_can_edit_templates\n  unless @current_user.can_create_templates?\n    render json: { error: 'Unauthorized' }, status: :forbidden\n  end\nend\n TRAPID_BIBLE.md RULE #1.3",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.3",
    "difficulty": "intermediate",
    "summary": "Permission system using hardcoded roles and model-based permission methods.",
    "code_example": "# app/models/user.rb\nROLES = %w[user admin product_owner estimator supervisor builder].freeze\n\ndef admin?\n  role == 'admin'\nend\n\ndef can_create_templates?\n  admin? || product_owner?\nend\n\ndef can_edit_schedule?\n  admin? || product_owner? || estimator?\nend\n\n# Controller usage:\nbefore_action :check_can_edit_templates\n\ndef check_can_edit_templates\n  unless @current_user.can_create_templates?\n    render json: { error: 'Unauthorized' }, status: :forbidden\n  end\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.3"
  },
  {
    "id": 102,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "Rate Limiting with Rack::Attack",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Rate Limiting with Rack::Attack integration Configure rate limiting on auth endpoints using Rack::Attack middleware. # config/initializers/rack_attack.rb\nRack::Attack.throttle('auth/ip', limit: 5, period: 20.seconds) do |req|\n  req.ip if req.path.start_with?('/api/v1/auth/')\nend\n\nRack::Attack.throttle('password_reset/email', limit: 3, period: 1.hour) do |req|\n  if req.path == '/api/v1/users/reset_password' && req.post?\n    req.params['email'].to_s.downcase.presence\n  end\nend\n\nRack::Attack.throttle('general/ip', limit: 300, period: 5.minutes) do |req|\n  req.ip\nend\n TRAPID_BIBLE.md RULE #1.4",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.4",
    "difficulty": "intermediate",
    "summary": "Configure rate limiting on auth endpoints using Rack::Attack middleware.",
    "code_example": "# config/initializers/rack_attack.rb\nRack::Attack.throttle('auth/ip', limit: 5, period: 20.seconds) do |req|\n  req.ip if req.path.start_with?('/api/v1/auth/')\nend\n\nRack::Attack.throttle('password_reset/email', limit: 3, period: 1.hour) do |req|\n  if req.path == '/api/v1/users/reset_password' && req.post?\n    req.params['email'].to_s.downcase.presence\n  end\nend\n\nRack::Attack.throttle('general/ip', limit: 300, period: 5.minutes) do |req|\n  req.ip\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.4"
  },
  {
    "id": 103,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "OAuth Integration with OmniAuth",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OAuth Integration with OmniAuth integration Microsoft Office 365 OAuth integration using OmniAuth gem. # config/initializers/omniauth.rb\nRails.application.config.middleware.use OmniAuth::Builder do\n  provider :microsoft_office365,\n    ENV['ONEDRIVE_CLIENT_ID'],\n    ENV['ONEDRIVE_CLIENT_SECRET'],\n    scope: 'openid profile email User.Read'\nend\n\n# app/models/user.rb\ndef self.from_omniauth(auth)\n  where(provider: auth.provider, uid: auth.uid).first_or_create do |user|\n    user.email = auth.info.email\n    user.name = auth.info.name\n    user.password = SecureRandom.hex(16)\n    user.oauth_token = auth.credentials.token\n    user.oauth_expires_at = Time.at(auth.credentials.expires_at)\n  end\nend\n TRAPID_BIBLE.md RULE #1.5",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.5",
    "difficulty": "advanced",
    "summary": "Microsoft Office 365 OAuth integration using OmniAuth gem.",
    "code_example": "# config/initializers/omniauth.rb\nRails.application.config.middleware.use OmniAuth::Builder do\n  provider :microsoft_office365,\n    ENV['ONEDRIVE_CLIENT_ID'],\n    ENV['ONEDRIVE_CLIENT_SECRET'],\n    scope: 'openid profile email User.Read'\nend\n\n# app/models/user.rb\ndef self.from_omniauth(auth)\n  where(provider: auth.provider, uid: auth.uid).first_or_create do |user|\n    user.email = auth.info.email\n    user.name = auth.info.name\n    user.password = SecureRandom.hex(16)\n    user.oauth_token = auth.credentials.token\n    user.oauth_expires_at = Time.at(auth.credentials.expires_at)\n  end\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.5"
  },
  {
    "id": 104,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "Password Reset Flow with Secure Tokens",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Password Reset Flow with Secure Tokens feature Secure password reset using hashed tokens with 2-hour expiration. # Generate reset token\ndef reset_password\n  token = SecureRandom.urlsafe_base64(32)\n  @user.update!(\n    reset_password_token: Digest::SHA256.hexdigest(token),\n    reset_password_sent_at: Time.current\n  )\n  # Send token via email (not API response)\nend\n\n# Validate and update password\ndef update_password_with_token\n  hashed_token = Digest::SHA256.hexdigest(params[:token])\n  user = User.find_by(reset_password_token: hashed_token)\n\n  if user && user.reset_password_sent_at > 2.hours.ago\n    user.update!(\n      password: params[:password],\n      reset_password_token: nil,\n      reset_password_sent_at: nil\n    )\n    render json: { message: 'Password updated' }\n  else\n    render json: { error: 'Token expired' }, status: :unprocessable_entity\n  end\nend\n TRAPID_BIBLE.md RULE #1.6",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.6",
    "difficulty": "intermediate",
    "summary": "Secure password reset using hashed tokens with 2-hour expiration.",
    "code_example": "# Generate reset token\ndef reset_password\n  token = SecureRandom.urlsafe_base64(32)\n  @user.update!(\n    reset_password_token: Digest::SHA256.hexdigest(token),\n    reset_password_sent_at: Time.current\n  )\n  # Send token via email (not API response)\nend\n\n# Validate and update password\ndef update_password_with_token\n  hashed_token = Digest::SHA256.hexdigest(params[:token])\n  user = User.find_by(reset_password_token: hashed_token)\n\n  if user && user.reset_password_sent_at > 2.hours.ago\n    user.update!(\n      password: params[:password],\n      reset_password_token: nil,\n      reset_password_sent_at: nil\n    )\n    render json: { message: 'Password updated' }\n  else\n    render json: { error: 'Token expired' }, status: :unprocessable_entity\n  end\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.6"
  },
  {
    "id": 105,
    "chapter_number": 1,
    "chapter_name": "Authentication & Users",
    "component": null,
    "title": "Portal User Separation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Portal User Separation feature Isolated portal_users table with activity logging and account lockout. # app/models/portal_user.rb\nclass PortalUser < ApplicationRecord\n  belongs_to :contact\n  has_secure_password\n\n  enum portal_type: { supplier: 'supplier', customer: 'customer' }\n\n  def lock_account!\n    update!(locked_until: 30.minutes.from_now)\n  end\n\n  def record_failed_login!\n    increment!(:failed_login_attempts)\n    lock_account! if failed_login_attempts >= 5\n  end\n\n  def record_successful_login!\n    update!(\n      failed_login_attempts: 0,\n      locked_until: nil,\n      last_login_at: Time.current\n    )\n  end\nend\n\n# app/models/portal_access_log.rb\ndef self.log(portal_user:, action:, ip:, user_agent:)\n  create!(\n    portal_user: portal_user,\n    action_type: action,\n    ip_address: ip,\n    user_agent: user_agent,\n    occurred_at: Time.current\n  )\nend\n TRAPID_BIBLE.md RULE #1.7",
    "created_at": "2025-11-17 08:04:40 +1000",
    "updated_at": "2025-11-17 08:04:40 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "1.7",
    "difficulty": "advanced",
    "summary": "Isolated portal_users table with activity logging and account lockout.",
    "code_example": "# app/models/portal_user.rb\nclass PortalUser < ApplicationRecord\n  belongs_to :contact\n  has_secure_password\n\n  enum portal_type: { supplier: 'supplier', customer: 'customer' }\n\n  def lock_account!\n    update!(locked_until: 30.minutes.from_now)\n  end\n\n  def record_failed_login!\n    increment!(:failed_login_attempts)\n    lock_account! if failed_login_attempts >= 5\n  end\n\n  def record_successful_login!\n    update!(\n      failed_login_attempts: 0,\n      locked_until: nil,\n      last_login_at: Time.current\n    )\n  end\nend\n\n# app/models/portal_access_log.rb\ndef self.log(portal_user:, action:, ip:, user_agent:)\n  create!(\n    portal_user: portal_user,\n    action_type: action,\n    ip_address: ip,\n    user_agent: user_agent,\n    occurred_at: Time.current\n  )\nend\n",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #1.7"
  },
  {
    "id": 106,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Company Settings Singleton Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Company Settings Singleton Pattern util  # app/models/company_setting.rb\nclass CompanySetting < ApplicationRecord\n  def self.instance\n    first_or_create!(\n      company_name: \"Trapid Construction\",\n      timezone: \"Australia/Brisbane\",\n      working_days: {\n        \"monday\" => true,\n        \"tuesday\" => true,\n        \"wednesday\" => true,\n        \"thursday\" => true,\n        \"friday\" => true,\n        \"saturday\" => false,\n        \"sunday\" => true  # Note: Sunday = true by default\n      }\n    )\n  end\nend\n\n# ---\n\n# In controllers, services, models:\nsettings = CompanySetting.instance\n\n# Access fields:\ntimezone = settings.timezone\nworking_days = settings.working_days\ncompany_name = settings.company_name TRAPID_BIBLE.md RULE #2.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/company_setting.rb\nclass CompanySetting < ApplicationRecord\n  def self.instance\n    first_or_create!(\n      company_name: \"Trapid Construction\",\n      timezone: \"Australia/Brisbane\",\n      working_days: {\n        \"monday\" => true,\n        \"tuesday\" => true,\n        \"wednesday\" => true,\n        \"thursday\" => true,\n        \"friday\" => true,\n        \"saturday\" => false,\n        \"sunday\" => true  # Note: Sunday = true by default\n      }\n    )\n  end\nend\n\n# ---\n\n# In controllers, services, models:\nsettings = CompanySetting.instance\n\n# Access fields:\ntimezone = settings.timezone\nworking_days = settings.working_days\ncompany_name = settings.company_name",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.1"
  },
  {
    "id": 111,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Assignable Roles for Task Assignment",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Assignable Roles for Task Assignment util  # app/models/user.rb\nenum assignable_role: {\n  admin: 0,\n  sales: 1,\n  site: 2,\n  supervisor: 3,\n  builder: 4,\n  estimator: 5,\n  none: 6\n}, _prefix: :assignable\n\n# ---\n\n# app/controllers/api/v1/schedule_tasks_controller.rb\ndef my_tasks\n  # Filter by assignable_role, not system role\n  tasks = ScheduleTask.where(assignable_role: current_user.assignable_role)\n  render json: tasks\nend TRAPID_BIBLE.md RULE #2.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/user.rb\nenum assignable_role: {\n  admin: 0,\n  sales: 1,\n  site: 2,\n  supervisor: 3,\n  builder: 4,\n  estimator: 5,\n  none: 6\n}, _prefix: :assignable\n\n# ---\n\n# app/controllers/api/v1/schedule_tasks_controller.rb\ndef my_tasks\n  # Filter by assignable_role, not system role\n  tasks = ScheduleTask.where(assignable_role: current_user.assignable_role)\n  render json: tasks\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.6"
  },
  {
    "id": 107,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Timezone Handling - Backend Time Calculations",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Timezone Handling - Backend Time Calculations util  # app/models/company_setting.rb\ndef today\n  Time.use_zone(timezone) { Time.zone.today }\nend\n\ndef now\n  Time.use_zone(timezone) { Time.zone.now }\nend\n\n# Usage in services/models:\nsettings = CompanySetting.instance\ncurrent_date = settings.today  # NOT Date.today!\ncurrent_time = settings.now    # NOT Time.now!\n\n# ---\n\n# When calculating dates for a job:\nsettings = CompanySetting.instance\n\nTime.use_zone(settings.timezone) do\n  job_start = Time.zone.parse(\"2025-01-15 08:00:00\")\n  job_end = job_start + 5.days\n\n  # All calculations within this block use company timezone\nend TRAPID_BIBLE.md RULE #2.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/company_setting.rb\ndef today\n  Time.use_zone(timezone) { Time.zone.today }\nend\n\ndef now\n  Time.use_zone(timezone) { Time.zone.now }\nend\n\n# Usage in services/models:\nsettings = CompanySetting.instance\ncurrent_date = settings.today  # NOT Date.today!\ncurrent_time = settings.now    # NOT Time.now!\n\n# ---\n\n# When calculating dates for a job:\nsettings = CompanySetting.instance\n\nTime.use_zone(settings.timezone) do\n  job_start = Time.zone.parse(\"2025-01-15 08:00:00\")\n  job_end = job_start + 5.days\n\n  # All calculations within this block use company timezone\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.2"
  },
  {
    "id": 108,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Timezone Handling - Frontend Time Display",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Timezone Handling - Frontend Time Display integration  // frontend/src/utils/timezoneUtils.js\nimport { companySettings } from '../contexts/CompanySettingsContext';\n\nexport const formatDate = (dateString) => {\n  const timezone = companySettings.timezone; // e.g., \"Australia/Brisbane\"\n\n  const formatter = new Intl.DateTimeFormat('en-AU', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  });\n\n  return formatter.format(new Date(dateString));\n};\n\nexport const formatDateTime = (dateString) => {\n  const timezone = companySettings.timezone;\n\n  const formatter = new Intl.DateTimeFormat('en-AU', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n  });\n\n  return formatter.format(new Date(dateString));\n};\n\n# ---\n\n// GanttChart.jsx\nimport { formatDate, formatDateTime } from '../utils/timezoneUtils';\n\nconst TaskRow = ({ task }) => (\n  <div>\n    <span>Start: {formatDate(task.planned_start_date)}</span>\n    <span>End: {formatDate(task.planned_end_date)}</span>\n  </div>\n); TRAPID_BIBLE.md RULE #2.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "// frontend/src/utils/timezoneUtils.js\nimport { companySettings } from '../contexts/CompanySettingsContext';\n\nexport const formatDate = (dateString) => {\n  const timezone = companySettings.timezone; // e.g., \"Australia/Brisbane\"\n\n  const formatter = new Intl.DateTimeFormat('en-AU', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  });\n\n  return formatter.format(new Date(dateString));\n};\n\nexport const formatDateTime = (dateString) => {\n  const timezone = companySettings.timezone;\n\n  const formatter = new Intl.DateTimeFormat('en-AU', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n  });\n\n  return formatter.format(new Date(dateString));\n};\n\n# ---\n\n// GanttChart.jsx\nimport { formatDate, formatDateTime } from '../utils/timezoneUtils';\n\nconst TaskRow = ({ task }) => (\n  <div>\n    <span>Start: {formatDate(task.planned_start_date)}</span>\n    <span>End: {formatDate(task.planned_end_date)}</span>\n  </div>\n);",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.3"
  },
  {
    "id": 109,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Working Days Configuration & Business Day Calculations",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Working Days Configuration & Business Day Calculations util  # db/schema.rb\ncreate_table :company_settings do |t|\n  t.jsonb :working_days, default: {\n    \"monday\" => true,\n    \"tuesday\" => true,\n    \"wednesday\" => true,\n    \"thursday\" => true,\n    \"friday\" => true,\n    \"saturday\" => false,\n    \"sunday\" => true  # Default includes Sunday (construction industry)\n  }\nend\n\n# ---\n\n# app/models/company_setting.rb\ndef working_day?(date)\n  day_name = date.strftime('%A').downcase  # \"monday\", \"tuesday\", etc.\n  working_days[day_name] == true\nend\n\ndef business_day?(date)\n  # Business day = working day AND not a public holiday\n  working_day?(date) && !PublicHoliday.on_date(date).exists?\nend\n\n# ---\n\n# app/services/schedule/cascade_calculator.rb\ndef next_business_day(date)\n  settings = CompanySetting.instance\n  current = date + 1.day\n\n  while !settings.business_day?(current)\n    current += 1.day\n  end\n\n  current\nend\n\ndef add_business_days(start_date, days_to_add)\n  settings = CompanySetting.instance\n  current = start_date\n  days_added = 0\n\n  while days_added < days_to_add\n    current += 1.day\n    days_added += 1 if settings.business_day?(current)\n  end\n\n  current\nend TRAPID_BIBLE.md RULE #2.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# db/schema.rb\ncreate_table :company_settings do |t|\n  t.jsonb :working_days, default: {\n    \"monday\" => true,\n    \"tuesday\" => true,\n    \"wednesday\" => true,\n    \"thursday\" => true,\n    \"friday\" => true,\n    \"saturday\" => false,\n    \"sunday\" => true  # Default includes Sunday (construction industry)\n  }\nend\n\n# ---\n\n# app/models/company_setting.rb\ndef working_day?(date)\n  day_name = date.strftime('%A').downcase  # \"monday\", \"tuesday\", etc.\n  working_days[day_name] == true\nend\n\ndef business_day?(date)\n  # Business day = working day AND not a public holiday\n  working_day?(date) && !PublicHoliday.on_date(date).exists?\nend\n\n# ---\n\n# app/services/schedule/cascade_calculator.rb\ndef next_business_day(date)\n  settings = CompanySetting.instance\n  current = date + 1.day\n\n  while !settings.business_day?(current)\n    current += 1.day\n  end\n\n  current\nend\n\ndef add_business_days(start_date, days_to_add)\n  settings = CompanySetting.instance\n  current = start_date\n  days_added = 0\n\n  while days_added < days_to_add\n    current += 1.day\n    days_added += 1 if settings.business_day?(current)\n  end\n\n  current\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.4"
  },
  {
    "id": 110,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "User Roles & Permission System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "User Roles & Permission System component  # app/models/user.rb\nenum role: {\n  user: 0,           # Basic access (view-only for most features)\n  admin: 1,          # Full system access\n  product_owner: 2,  # Full access + product backlog management\n  estimator: 3,      # Estimate/quote creation and editing\n  supervisor: 4,     # Field supervisor (task completion, checklists)\n  builder: 5         # Builder/contractor (task viewing, updates)\n}\n\n# ---\n\n# app/models/user.rb\ndef can_create_templates?\n  admin? || product_owner?\nend\n\ndef can_edit_schedule?\n  admin? || product_owner? || estimator?\nend\n\ndef can_view_supervisor_tasks?\n  supervisor? || admin? || product_owner?\nend\n\ndef can_view_builder_tasks?\n  builder? || admin? || product_owner?\nend\n\ndef can_manage_users?\n  admin? || product_owner?\nend\n\n# ---\n\n# app/controllers/api/v1/schedule_templates_controller.rb\nbefore_action :require_template_permissions, only: [:create, :update, :destroy]\n\ndef require_template_permissions\n  unless current_user.can_create_templates?\n    render json: { error: \"Insufficient permissions\" }, status: :forbidden\n  end\nend TRAPID_BIBLE.md RULE #2.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.5",
    "difficulty": "beginner",
    "summary": "",
    "code_example": "# app/models/user.rb\nenum role: {\n  user: 0,           # Basic access (view-only for most features)\n  admin: 1,          # Full system access\n  product_owner: 2,  # Full access + product backlog management\n  estimator: 3,      # Estimate/quote creation and editing\n  supervisor: 4,     # Field supervisor (task completion, checklists)\n  builder: 5         # Builder/contractor (task viewing, updates)\n}\n\n# ---\n\n# app/models/user.rb\ndef can_create_templates?\n  admin? || product_owner?\nend\n\ndef can_edit_schedule?\n  admin? || product_owner? || estimator?\nend\n\ndef can_view_supervisor_tasks?\n  supervisor? || admin? || product_owner?\nend\n\ndef can_view_builder_tasks?\n  builder? || admin? || product_owner?\nend\n\ndef can_manage_users?\n  admin? || product_owner?\nend\n\n# ---\n\n# app/controllers/api/v1/schedule_templates_controller.rb\nbefore_action :require_template_permissions, only: [:create, :update, :destroy]\n\ndef require_template_permissions\n  unless current_user.can_create_templates?\n    render json: { error: \"Insufficient permissions\" }, status: :forbidden\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.5"
  },
  {
    "id": 157,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Price Drift Monitoring",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Price Drift Monitoring util ✅ def price_drift\n  return 0 if pricebook_item.nil?\n  ((unit_price - pricebook_item.price) / pricebook_item.price) * 100\nend TRAPID_BIBLE.md RULE #8.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.7",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "def price_drift\n  return 0 if pricebook_item.nil?\n  ((unit_price - pricebook_item.price) / pricebook_item.price) * 100\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.7"
  },
  {
    "id": 112,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Password Complexity Requirements",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Password Complexity Requirements integration  # app/models/user.rb\nvalidates :password, presence: true, if: :password_required?\nvalidates :password, length: { minimum: 12 }, if: :password_required?\nvalidate :password_complexity, if: :password_required?\n\ndef password_complexity\n  return if password.blank?\n\n  rules = []\n  rules << \"must include at least one uppercase letter\" unless password.match?(/[A-Z]/)\n  rules << \"must include at least one lowercase letter\" unless password.match?(/[a-z]/)\n  rules << \"must include at least one digit\" unless password.match?(/\\d/)\n  rules << \"must include at least one special character\" unless password.match?(/[@$!%*?&]/)\n\n  if rules.any?\n    errors.add(:password, rules.join(\", \"))\n  end\nend\n\ndef password_required?\n  !oauth_uid.present?  # OAuth users skip password validation\nend\n\n# ---\n\n# app/services/oauth_user_creator.rb\ndef create_from_oauth(oauth_data)\n  User.create!(\n    email: oauth_data[:email],\n    name: oauth_data[:name],\n    oauth_uid: oauth_data[:uid],\n    oauth_provider: oauth_data[:provider],\n    password: SecureRandom.urlsafe_base64(32),  # Random, unused password\n    role: :user\n  )\nend TRAPID_BIBLE.md RULE #2.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/user.rb\nvalidates :password, presence: true, if: :password_required?\nvalidates :password, length: { minimum: 12 }, if: :password_required?\nvalidate :password_complexity, if: :password_required?\n\ndef password_complexity\n  return if password.blank?\n\n  rules = []\n  rules << \"must include at least one uppercase letter\" unless password.match?(/[A-Z]/)\n  rules << \"must include at least one lowercase letter\" unless password.match?(/[a-z]/)\n  rules << \"must include at least one digit\" unless password.match?(/\\d/)\n  rules << \"must include at least one special character\" unless password.match?(/[@$!%*?&]/)\n\n  if rules.any?\n    errors.add(:password, rules.join(\", \"))\n  end\nend\n\ndef password_required?\n  !oauth_uid.present?  # OAuth users skip password validation\nend\n\n# ---\n\n# app/services/oauth_user_creator.rb\ndef create_from_oauth(oauth_data)\n  User.create!(\n    email: oauth_data[:email],\n    name: oauth_data[:name],\n    oauth_uid: oauth_data[:uid],\n    oauth_provider: oauth_data[:provider],\n    password: SecureRandom.urlsafe_base64(32),  # Random, unused password\n    role: :user\n  )\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.7"
  },
  {
    "id": 113,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Timezone Options Limitation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Timezone Options Limitation component  // frontend/src/components/settings/CompanySettingsTab.jsx\nconst TIMEZONE_OPTIONS = [\n  'Australia/Sydney',     // NSW, VIC, TAS\n  'Australia/Melbourne',  // VIC\n  'Australia/Brisbane',   // QLD (no DST)\n  'Australia/Adelaide',   // SA\n  'Australia/Perth',      // WA\n  'Australia/Darwin',     // NT (no DST)\n  'Australia/Hobart',     // TAS\n  'Australia/Canberra',   // ACT\n  'Australia/Lord_Howe',  // Lord Howe Island\n  'Pacific/Auckland',     // NZ\n  'Pacific/Chatham',      // Chatham Islands\n  'Australia/Eucla'       // WA (rare)\n];\n\n# ---\n\n<select\n  value={settings.timezone}\n  onChange={(e) => updateTimezone(e.target.value)}\n  className=\"form-select\"\n>\n  {TIMEZONE_OPTIONS.map(tz => (\n    <option key={tz} value={tz}>{tz}</option>\n  ))}\n</select> TRAPID_BIBLE.md RULE #2.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "// frontend/src/components/settings/CompanySettingsTab.jsx\nconst TIMEZONE_OPTIONS = [\n  'Australia/Sydney',     // NSW, VIC, TAS\n  'Australia/Melbourne',  // VIC\n  'Australia/Brisbane',   // QLD (no DST)\n  'Australia/Adelaide',   // SA\n  'Australia/Perth',      // WA\n  'Australia/Darwin',     // NT (no DST)\n  'Australia/Hobart',     // TAS\n  'Australia/Canberra',   // ACT\n  'Australia/Lord_Howe',  // Lord Howe Island\n  'Pacific/Auckland',     // NZ\n  'Pacific/Chatham',      // Chatham Islands\n  'Australia/Eucla'       // WA (rare)\n];\n\n# ---\n\n<select\n  value={settings.timezone}\n  onChange={(e) => updateTimezone(e.target.value)}\n  className=\"form-select\"\n>\n  {TIMEZONE_OPTIONS.map(tz => (\n    <option key={tz} value={tz}>{tz}</option>\n  ))}\n</select>",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.8"
  },
  {
    "id": 114,
    "chapter_number": 2,
    "chapter_name": "System Administration",
    "component": null,
    "title": "Working Days UI - Sunday Default True",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Working Days UI - Sunday Default True component  # app/models/company_setting.rb\nDEFAULT_WORKING_DAYS = {\n  \"monday\" => true,\n  \"tuesday\" => true,\n  \"wednesday\" => true,\n  \"thursday\" => true,\n  \"friday\" => true,\n  \"saturday\" => false,   # Most crews don't work Saturdays\n  \"sunday\" => true       # Sunday work common in construction\n}.freeze\n\n# ---\n\n// CompanySettingsTab.jsx\nconst DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n\n{DAYS.map(day => (\n  <label key={day} className=\"flex items-center gap-2\">\n    <input\n      type=\"checkbox\"\n      checked={settings.working_days[day] || false}\n      onChange={(e) => updateWorkingDay(day, e.target.checked)}\n    />\n    <span className=\"capitalize\">{day}</span>\n  </label>\n))} TRAPID_BIBLE.md RULE #2.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "2.9",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/company_setting.rb\nDEFAULT_WORKING_DAYS = {\n  \"monday\" => true,\n  \"tuesday\" => true,\n  \"wednesday\" => true,\n  \"thursday\" => true,\n  \"friday\" => true,\n  \"saturday\" => false,   # Most crews don't work Saturdays\n  \"sunday\" => true       # Sunday work common in construction\n}.freeze\n\n# ---\n\n// CompanySettingsTab.jsx\nconst DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n\n{DAYS.map(day => (\n  <label key={day} className=\"flex items-center gap-2\">\n    <input\n      type=\"checkbox\"\n      checked={settings.working_days[day] || false}\n      onChange={(e) => updateWorkingDay(day, e.target.checked)}\n    />\n    <span className=\"capitalize\">{day}</span>\n  </label>\n))}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #2.9"
  },
  {
    "id": 115,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": null,
    "title": "Contact Types are Multi-Select Arrays",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Contact Types are Multi-Select Arrays util - Use `contact_types` as PostgreSQL array column - Allow multiple types: `['customer', 'supplier']` for hybrid contacts - Set `primary_contact_type` automatically if blank (first type in array) - Vali # app/models/contact.rb\nCONTACT_TYPES = ['customer', 'supplier', 'sales', 'land_agent'].freeze\n\nvalidates :primary_contact_type, inclusion: { in: CONTACT_TYPES }, allow_nil: true\nvalidate :contact_types_must_be_valid\n\nbefore_save :set_primary_contact_type_if_blank\n\ndef is_supplier?\n  contact_types&.include?('supplier')\nend\n\nprivate\n\ndef contact_types_must_be_valid\n  return if contact_types.blank?\n  invalid_types = contact_types - CONTACT_TYPES\n  if invalid_types.any?\n    errors.add(:contact_types, \"contains invalid types: #{invalid_types.join(', ')}\")\n  end\nend\n\n# ---\n\n# Find all suppliers\nContact.where(\"'supplier' = ANY(contact_types)\")\n\n# Find contacts that are BOTH customer AND supplier\nContact.where(\"contact_types @> ARRAY['customer', 'supplier']::varchar[]\")\n\n# Filter by type in controller\ncase params[:type]\nwhen 'customers'\n  @contacts = @contacts.where(\"'customer' = ANY(contact_types)\")\nwhen 'suppliers'\n  @contacts = @contacts.where(\"'supplier' = ANY(contact_types)\")\nwhen 'both'\n  @contacts = @contacts.where(\"contact_types @> ARRAY['customer', 'supplier']::varchar[]\")\nend TRAPID_BIBLE.md RULE #3.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "3.1",
    "difficulty": "intermediate",
    "summary": "- Use `contact_types` as PostgreSQL array column - Allow multiple types: `['customer', 'supplier']` for hybrid contacts - Set `primary_contact_type` automatically if blank (first type in array) - Vali",
    "code_example": "# app/models/contact.rb\nCONTACT_TYPES = ['customer', 'supplier', 'sales', 'land_agent'].freeze\n\nvalidates :primary_contact_type, inclusion: { in: CONTACT_TYPES }, allow_nil: true\nvalidate :contact_types_must_be_valid\n\nbefore_save :set_primary_contact_type_if_blank\n\ndef is_supplier?\n  contact_types&.include?('supplier')\nend\n\nprivate\n\ndef contact_types_must_be_valid\n  return if contact_types.blank?\n  invalid_types = contact_types - CONTACT_TYPES\n  if invalid_types.any?\n    errors.add(:contact_types, \"contains invalid types: #{invalid_types.join(', ')}\")\n  end\nend\n\n# ---\n\n# Find all suppliers\nContact.where(\"'supplier' = ANY(contact_types)\")\n\n# Find contacts that are BOTH customer AND supplier\nContact.where(\"contact_types @> ARRAY['customer', 'supplier']::varchar[]\")\n\n# Filter by type in controller\ncase params[:type]\nwhen 'customers'\n  @contacts = @contacts.where(\"'customer' = ANY(contact_types)\")\nwhen 'suppliers'\n  @contacts = @contacts.where(\"'supplier' = ANY(contact_types)\")\nwhen 'both'\n  @contacts = @contacts.where(\"contact_types @> ARRAY['customer', 'supplier']::varchar[]\")\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #3.1"
  },
  {
    "id": 158,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "Predecessor ID Conversion",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Predecessor ID Conversion feature ✅ # Backend: Finding dependents\npredecessor_id = predecessor_task.sequence_order + 1  # 0-based → 1-based TRAPID_BIBLE.md RULE #9.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.1",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "# Backend: Finding dependents\npredecessor_id = predecessor_task.sequence_order + 1  # 0-based → 1-based",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.1"
  },
  {
    "id": 116,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": null,
    "title": "Bidirectional Relationships Require Reverse Sync",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Bidirectional Relationships Require Reverse Sync util - Create reverse relationship after creating forward relationship - Update reverse relationship when forward is updated - Delete reverse relationship when forward is deleted - Use Thread-local flags t # app/models/contact_relationship.rb\nRELATIONSHIP_TYPES = [\n  'previous_client', 'parent_company', 'subsidiary', 'partner',\n  'referral', 'supplier_alternate', 'related_project', 'family_member', 'other'\n].freeze\n\nvalidates :relationship_type, inclusion: { in: RELATIONSHIP_TYPES }\nvalidate :cannot_relate_to_self\nvalidate :unique_relationship_pair\n\nafter_create :create_reverse_relationship\nafter_update :update_reverse_relationship\nafter_destroy :destroy_reverse_relationship\n\nprivate\n\ndef create_reverse_relationship\n  return if Thread.current[:creating_reverse_relationship]\n\n  Thread.current[:creating_reverse_relationship] = true\n\n  ContactRelationship.create!(\n    source_contact_id: related_contact_id,\n    related_contact_id: source_contact_id,\n    relationship_type: relationship_type,\n    notes: notes\n  )\nensure\n  Thread.current[:creating_reverse_relationship] = false\nend\n\ndef cannot_relate_to_self\n  if source_contact_id == related_contact_id\n    errors.add(:base, \"Cannot create relationship to same contact\")\n  end\nend\n\ndef unique_relationship_pair\n  existing = ContactRelationship.where(\n    source_contact_id: source_contact_id,\n    related_contact_id: related_contact_id\n  ).where.not(id: id)\n\n  if existing.exists?\n    errors.add(:base, \"Relationship already exists\")\n  end\nend TRAPID_BIBLE.md RULE #3.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "3.2",
    "difficulty": "intermediate",
    "summary": "- Create reverse relationship after creating forward relationship - Update reverse relationship when forward is updated - Delete reverse relationship when forward is deleted - Use Thread-local flags t",
    "code_example": "# app/models/contact_relationship.rb\nRELATIONSHIP_TYPES = [\n  'previous_client', 'parent_company', 'subsidiary', 'partner',\n  'referral', 'supplier_alternate', 'related_project', 'family_member', 'other'\n].freeze\n\nvalidates :relationship_type, inclusion: { in: RELATIONSHIP_TYPES }\nvalidate :cannot_relate_to_self\nvalidate :unique_relationship_pair\n\nafter_create :create_reverse_relationship\nafter_update :update_reverse_relationship\nafter_destroy :destroy_reverse_relationship\n\nprivate\n\ndef create_reverse_relationship\n  return if Thread.current[:creating_reverse_relationship]\n\n  Thread.current[:creating_reverse_relationship] = true\n\n  ContactRelationship.create!(\n    source_contact_id: related_contact_id,\n    related_contact_id: source_contact_id,\n    relationship_type: relationship_type,\n    notes: notes\n  )\nensure\n  Thread.current[:creating_reverse_relationship] = false\nend\n\ndef cannot_relate_to_self\n  if source_contact_id == related_contact_id\n    errors.add(:base, \"Cannot create relationship to same contact\")\n  end\nend\n\ndef unique_relationship_pair\n  existing = ContactRelationship.where(\n    source_contact_id: source_contact_id,\n    related_contact_id: related_contact_id\n  ).where.not(id: id)\n\n  if existing.exists?\n    errors.add(:base, \"Relationship already exists\")\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #3.2"
  },
  {
    "id": 117,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": null,
    "title": "Xero Sync Uses Priority-Based Fuzzy Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Xero Sync Uses Priority-Based Fuzzy Matching integration - # app/services/xero_contact_sync_service.rb\ndef match_contact(xero_contact)\n  # Priority 1: Exact xero_id match\n  if xero_contact.contact_id.present?\n    match = Contact.find_by(xero_id: xero_contact.contact_id)\n    return { contact: match, match_type: 'xero_id' } if match\n  end\n\n  # Priority 2: Tax number match (ABN/ACN)\n  if xero_contact.tax_number.present?\n    normalized_tax = xero_contact.tax_number.gsub(/\\D/, '')\n    if normalized_tax.length == 11\n      match = Contact.where(\"regexp_replace(tax_number, '[^0-9]', '', 'g') = ?\", normalized_tax).first\n      return { contact: match, match_type: 'tax_number' } if match\n    end\n  end\n\n  # Priority 3: Email match\n  if xero_contact.email_address.present?\n    match = Contact.find_by('LOWER(email) = ?', xero_contact.email_address.downcase)\n    return { contact: match, match_type: 'email' } if match\n  end\n\n  # Priority 4: Fuzzy name match (>85% similarity)\n  if xero_contact.name.present?\n    contact_names = Contact.pluck(:full_name, :id).to_h\n    fuzzy_matcher = FuzzyMatch.new(contact_names.keys)\n    matched_name = fuzzy_matcher.find(xero_contact.name, threshold: 0.85)\n\n    if matched_name\n      match = Contact.find(contact_names[matched_name])\n      return { contact: match, match_type: 'fuzzy_name' }\n    end\n  end\n\n  { contact: nil, match_type: 'no_match' }\nend TRAPID_BIBLE.md RULE #3.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "3.3",
    "difficulty": "intermediate",
    "summary": "-",
    "code_example": "# app/services/xero_contact_sync_service.rb\ndef match_contact(xero_contact)\n  # Priority 1: Exact xero_id match\n  if xero_contact.contact_id.present?\n    match = Contact.find_by(xero_id: xero_contact.contact_id)\n    return { contact: match, match_type: 'xero_id' } if match\n  end\n\n  # Priority 2: Tax number match (ABN/ACN)\n  if xero_contact.tax_number.present?\n    normalized_tax = xero_contact.tax_number.gsub(/\\D/, '')\n    if normalized_tax.length == 11\n      match = Contact.where(\"regexp_replace(tax_number, '[^0-9]', '', 'g') = ?\", normalized_tax).first\n      return { contact: match, match_type: 'tax_number' } if match\n    end\n  end\n\n  # Priority 3: Email match\n  if xero_contact.email_address.present?\n    match = Contact.find_by('LOWER(email) = ?', xero_contact.email_address.downcase)\n    return { contact: match, match_type: 'email' } if match\n  end\n\n  # Priority 4: Fuzzy name match (>85% similarity)\n  if xero_contact.name.present?\n    contact_names = Contact.pluck(:full_name, :id).to_h\n    fuzzy_matcher = FuzzyMatch.new(contact_names.keys)\n    matched_name = fuzzy_matcher.find(xero_contact.name, threshold: 0.85)\n\n    if matched_name\n      match = Contact.find(contact_names[matched_name])\n      return { contact: match, match_type: 'fuzzy_name' }\n    end\n  end\n\n  { contact: nil, match_type: 'no_match' }\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #3.3"
  },
  {
    "id": 118,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": null,
    "title": "Contact Deletion MUST Check Purchase Order Dependencies",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Contact Deletion MUST Check Purchase Order Dependencies util - Check for linked suppliers via `contact.suppliers` association - Check if suppliers have purchase orders: `suppliers.joins(:purchase_orders).distinct` - Block deletion if ANY purchase orders exist - # app/controllers/api/v1/contacts_controller.rb\ndef destroy\n  # Check for linked suppliers with purchase orders\n  if @contact.suppliers.any?\n    suppliers_with_pos = @contact.suppliers.joins(:purchase_orders).distinct\n\n    if suppliers_with_pos.any?\n      # Check for paid/invoiced POs\n      paid_pos = PurchaseOrder\n        .where(supplier_id: suppliers_with_pos.pluck(:id))\n        .where(\"status IN (?) OR amount_paid > 0 OR amount_invoiced > 0\",\n               ['paid', 'partially_paid', 'invoiced'])\n\n      if paid_pos.exists?\n        return render json: {\n          success: false,\n          error: \"Cannot delete contact with suppliers that have paid or invoiced purchase orders\"\n        }, status: :unprocessable_entity\n      end\n    end\n  end\n\n  @contact.destroy\nend TRAPID_BIBLE.md RULE #3.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "3.4",
    "difficulty": "intermediate",
    "summary": "- Check for linked suppliers via `contact.suppliers` association - Check if suppliers have purchase orders: `suppliers.joins(:purchase_orders).distinct` - Block deletion if ANY purchase orders exist -",
    "code_example": "# app/controllers/api/v1/contacts_controller.rb\ndef destroy\n  # Check for linked suppliers with purchase orders\n  if @contact.suppliers.any?\n    suppliers_with_pos = @contact.suppliers.joins(:purchase_orders).distinct\n\n    if suppliers_with_pos.any?\n      # Check for paid/invoiced POs\n      paid_pos = PurchaseOrder\n        .where(supplier_id: suppliers_with_pos.pluck(:id))\n        .where(\"status IN (?) OR amount_paid > 0 OR amount_invoiced > 0\",\n               ['paid', 'partially_paid', 'invoiced'])\n\n      if paid_pos.exists?\n        return render json: {\n          success: false,\n          error: \"Cannot delete contact with suppliers that have paid or invoiced purchase orders\"\n        }, status: :unprocessable_entity\n      end\n    end\n  end\n\n  @contact.destroy\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #3.4"
  },
  {
    "id": 119,
    "chapter_number": 3,
    "chapter_name": "Contacts & Relationships",
    "component": null,
    "title": "Portal Users MUST Have Secure Password Requirements",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Portal Users MUST Have Secure Password Requirements util - Minimum 12 characters - At least one uppercase, lowercase, digit, and special character - Lock account after 5 failed login attempts - Lockout duration: 30 minutes - Reset failed attempts counter on # app/models/portal_user.rb\nPASSWORD_REGEX = /\\A\n  (?=.*[a-z])           # At least one lowercase\n  (?=.*[A-Z])           # At least one uppercase\n  (?=.*\\d)              # At least one digit\n  (?=.*[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?])  # At least one special char\n  .{12,}                # At least 12 characters\n\\z/x\n\nvalidates :password, length: { minimum: 12 }, format: PASSWORD_REGEX, on: :create TRAPID_BIBLE.md RULE #3.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "3.6",
    "difficulty": "intermediate",
    "summary": "- Minimum 12 characters - At least one uppercase, lowercase, digit, and special character - Lock account after 5 failed login attempts - Lockout duration: 30 minutes - Reset failed attempts counter on",
    "code_example": "# app/models/portal_user.rb\nPASSWORD_REGEX = /\\A\n  (?=.*[a-z])           # At least one lowercase\n  (?=.*[A-Z])           # At least one uppercase\n  (?=.*\\d)              # At least one digit\n  (?=.*[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?])  # At least one special char\n  .{12,}                # At least 12 characters\n\\z/x\n\nvalidates :password, length: { minimum: 12 }, format: PASSWORD_REGEX, on: :create",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #3.6"
  },
  {
    "id": 159,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "isLoadingData Lock Timing",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "isLoadingData Lock Timing util ✅ // In onAfterTaskDrag:\ngantt.attachEvent('onAfterTaskDrag', (id, mode, event) => {\n  isDragging.current = true\n  isLoadingData.current = true  // Set immediately\n\n  // Set timeout to release lock after 5000ms\n  loadingDataTimeout.current = setTimeout(() => {\n    isLoadingData.current = false\n    loadingDataTimeout.current = null\n  }, 5000)\n\n  isDragging.current = false\n  // DO NOT reset isLoadingData synchronously!\n}) TRAPID_BIBLE.md RULE #9.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.2",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "// In onAfterTaskDrag:\ngantt.attachEvent('onAfterTaskDrag', (id, mode, event) => {\n  isDragging.current = true\n  isLoadingData.current = true  // Set immediately\n\n  // Set timeout to release lock after 5000ms\n  loadingDataTimeout.current = setTimeout(() => {\n    isLoadingData.current = false\n    loadingDataTimeout.current = null\n  }, 5000)\n\n  isDragging.current = false\n  // DO NOT reset isLoadingData synchronously!\n})",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.2"
  },
  {
    "id": 120,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Price Changes MUST Create Price History Automatically",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Price Changes MUST Create Price History Automatically util - Use `after_update` callback to detect price changes - Create PriceHistory with `old_price`, `new_price`, `change_reason` - Set `price_last_updated_at` to current timestamp - Track `changed_by_user_i # app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  attr_accessor :skip_price_history_callback\n\n  before_save :update_price_timestamp, if: :current_price_changed?\n  after_update :track_price_change, if: :saved_change_to_current_price?\n\n  private\n\n  def update_price_timestamp\n    self.price_last_updated_at = Time.current\n  end\n\n  def track_price_change\n    return if skip_price_history_callback\n\n    old_price = saved_changes['current_price'][0]\n    new_price = saved_changes['current_price'][1]\n\n    price_histories.create!(\n      old_price: old_price,\n      new_price: new_price,\n      change_reason: 'manual_edit',\n      supplier_id: default_supplier_id,\n      changed_by_user_id: Current.user&.id,\n      user_name: Current.user&.full_name,\n      date_effective: Date.current\n    )\n  end\nend\n\n# ---\n\n# Only when bulk importing historical data\nitem.skip_price_history_callback = true\nitem.update!(current_price: 450.00) TRAPID_BIBLE.md RULE #4.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.1",
    "difficulty": "intermediate",
    "summary": "- Use `after_update` callback to detect price changes - Create PriceHistory with `old_price`, `new_price`, `change_reason` - Set `price_last_updated_at` to current timestamp - Track `changed_by_user_i",
    "code_example": "# app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  attr_accessor :skip_price_history_callback\n\n  before_save :update_price_timestamp, if: :current_price_changed?\n  after_update :track_price_change, if: :saved_change_to_current_price?\n\n  private\n\n  def update_price_timestamp\n    self.price_last_updated_at = Time.current\n  end\n\n  def track_price_change\n    return if skip_price_history_callback\n\n    old_price = saved_changes['current_price'][0]\n    new_price = saved_changes['current_price'][1]\n\n    price_histories.create!(\n      old_price: old_price,\n      new_price: new_price,\n      change_reason: 'manual_edit',\n      supplier_id: default_supplier_id,\n      changed_by_user_id: Current.user&.id,\n      user_name: Current.user&.full_name,\n      date_effective: Date.current\n    )\n  end\nend\n\n# ---\n\n# Only when bulk importing historical data\nitem.skip_price_history_callback = true\nitem.update!(current_price: 450.00)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.1"
  },
  {
    "id": 121,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Prevent Duplicate Price History - Unique Constraint + Time Window",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Prevent Duplicate Price History - Unique Constraint + Time Window feature - Use unique index: `(pricebook_item_id, supplier_id, new_price, created_at)` - Add custom validation preventing entries within 5 seconds - Handle race conditions gracefully (return existing record) - # Migration\nadd_index :price_histories,\n  [:pricebook_item_id, :supplier_id, :new_price, :created_at],\n  unique: true,\n  name: 'index_price_histories_on_unique_combination'\n\n# Model validation\nclass PriceHistory < ApplicationRecord\n  validate :prevent_duplicate_price_history\n\n  private\n\n  def prevent_duplicate_price_history\n    # Check for recent identical entry (< 5 seconds ago)\n    recent = PriceHistory.where(\n      pricebook_item_id: pricebook_item_id,\n      supplier_id: supplier_id,\n      new_price: new_price\n    ).where('created_at > ?', 5.seconds.ago).exists?\n\n    if recent\n      errors.add(:base, 'Duplicate price history entry within 5 seconds')\n    end\n  end\nend\n\n# ---\n\ndef add_price\n  @item = PricebookItem.find(params[:id])\n\n  history = @item.price_histories.create(price_params)\n\n  if history.persisted?\n    render json: { success: true, history: history }\n  elsif history.errors[:base].include?('Duplicate price history')\n    # Graceful: return existing entry\n    existing = @item.price_histories\n      .where(new_price: params[:price])\n      .order(created_at: :desc)\n      .first\n    render json: { success: true, history: existing, duplicate: true }\n  else\n    render json: { success: false, errors: history.errors.full_messages }, status: :unprocessable_entity\n  end\nend TRAPID_BIBLE.md RULE #4.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.2",
    "difficulty": "intermediate",
    "summary": "- Use unique index: `(pricebook_item_id, supplier_id, new_price, created_at)` - Add custom validation preventing entries within 5 seconds - Handle race conditions gracefully (return existing record) -",
    "code_example": "# Migration\nadd_index :price_histories,\n  [:pricebook_item_id, :supplier_id, :new_price, :created_at],\n  unique: true,\n  name: 'index_price_histories_on_unique_combination'\n\n# Model validation\nclass PriceHistory < ApplicationRecord\n  validate :prevent_duplicate_price_history\n\n  private\n\n  def prevent_duplicate_price_history\n    # Check for recent identical entry (< 5 seconds ago)\n    recent = PriceHistory.where(\n      pricebook_item_id: pricebook_item_id,\n      supplier_id: supplier_id,\n      new_price: new_price\n    ).where('created_at > ?', 5.seconds.ago).exists?\n\n    if recent\n      errors.add(:base, 'Duplicate price history entry within 5 seconds')\n    end\n  end\nend\n\n# ---\n\ndef add_price\n  @item = PricebookItem.find(params[:id])\n\n  history = @item.price_histories.create(price_params)\n\n  if history.persisted?\n    render json: { success: true, history: history }\n  elsif history.errors[:base].include?('Duplicate price history')\n    # Graceful: return existing entry\n    existing = @item.price_histories\n      .where(new_price: params[:price])\n      .order(created_at: :desc)\n      .first\n    render json: { success: true, history: existing, duplicate: true }\n  else\n    render json: { success: false, errors: history.errors.full_messages }, status: :unprocessable_entity\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.2"
  },
  {
    "id": 122,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "SmartPoLookupService - 6-Strategy Cascading Fallback",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "SmartPoLookupService - 6-Strategy Cascading Fallback feature - Execute strategies in priority order (most specific → most general) - Stop immediately on first match (don't continue searching) - Track which strategy succeeded for analytics - Collect warnings for # app/services/smart_po_lookup_service.rb\nclass SmartPoLookupService\n  STRATEGIES = [\n    :exact_match_with_supplier,\n    :fuzzy_match_with_supplier,\n    :fulltext_with_supplier,\n    :exact_match_without_supplier,\n    :fuzzy_match_without_supplier,\n    :fulltext_without_supplier\n  ].freeze\n\n  def lookup(task_description:, category:, quantity: 1, supplier_preference: nil)\n    @task_description = task_description\n    @category = category.to_s.downcase\n    @quantity = quantity\n    @warnings = []\n\n    # Find supplier first\n    @supplier = find_supplier(supplier_preference)\n\n    # Cascade through strategies\n    @price_book_item = find_pricebook_item\n\n    unless @price_book_item\n      @warnings << \"No pricebook entry found for '#{task_description}'\"\n    end\n\n    build_result\n  end\n\n  private\n\n  def find_pricebook_item\n    STRATEGIES.each do |strategy|\n      result = send(strategy)\n      if result\n        Rails.logger.info(\"SmartPoLookup: #{strategy} matched item #{result.id}\")\n        return result\n      end\n    end\n    nil\n  end\n\n  def exact_match_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where('LOWER(item_name) = ?', @task_description.downcase)\n      .first\n  end\n\n  def fuzzy_match_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where('LOWER(item_name) LIKE ?', \"%#{@task_description.downcase}%\")\n      .first\n  end\n\n  def fulltext_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where(\"searchable_text @@ plainto_tsquery('english', ?)\", @task_description)\n      .first\n  end\n\n  def exact_match_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where('LOWER(item_name) = ?', @task_description.downcase)\n      .first\n  end\n\n  def fuzzy_match_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where('LOWER(item_name) LIKE ?', \"%#{@task_description.downcase}%\")\n      .first\n  end\n\n  def fulltext_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where(\"searchable_text @@ plainto_tsquery('english', ?)\", @task_description)\n      .first\n  end\nend TRAPID_BIBLE.md RULE #4.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.3",
    "difficulty": "intermediate",
    "summary": "- Execute strategies in priority order (most specific → most general) - Stop immediately on first match (don't continue searching) - Track which strategy succeeded for analytics - Collect warnings for",
    "code_example": "# app/services/smart_po_lookup_service.rb\nclass SmartPoLookupService\n  STRATEGIES = [\n    :exact_match_with_supplier,\n    :fuzzy_match_with_supplier,\n    :fulltext_with_supplier,\n    :exact_match_without_supplier,\n    :fuzzy_match_without_supplier,\n    :fulltext_without_supplier\n  ].freeze\n\n  def lookup(task_description:, category:, quantity: 1, supplier_preference: nil)\n    @task_description = task_description\n    @category = category.to_s.downcase\n    @quantity = quantity\n    @warnings = []\n\n    # Find supplier first\n    @supplier = find_supplier(supplier_preference)\n\n    # Cascade through strategies\n    @price_book_item = find_pricebook_item\n\n    unless @price_book_item\n      @warnings << \"No pricebook entry found for '#{task_description}'\"\n    end\n\n    build_result\n  end\n\n  private\n\n  def find_pricebook_item\n    STRATEGIES.each do |strategy|\n      result = send(strategy)\n      if result\n        Rails.logger.info(\"SmartPoLookup: #{strategy} matched item #{result.id}\")\n        return result\n      end\n    end\n    nil\n  end\n\n  def exact_match_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where('LOWER(item_name) = ?', @task_description.downcase)\n      .first\n  end\n\n  def fuzzy_match_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where('LOWER(item_name) LIKE ?', \"%#{@task_description.downcase}%\")\n      .first\n  end\n\n  def fulltext_with_supplier\n    return nil unless @supplier\n\n    PricebookItem.active\n      .where(category: @category)\n      .where(supplier_id: @supplier.id)\n      .where(\"searchable_text @@ plainto_tsquery('english', ?)\", @task_description)\n      .first\n  end\n\n  def exact_match_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where('LOWER(item_name) = ?', @task_description.downcase)\n      .first\n  end\n\n  def fuzzy_match_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where('LOWER(item_name) LIKE ?', \"%#{@task_description.downcase}%\")\n      .first\n  end\n\n  def fulltext_without_supplier\n    PricebookItem.active\n      .where(category: @category)\n      .where(\"searchable_text @@ plainto_tsquery('english', ?)\", @task_description)\n      .first\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.3"
  },
  {
    "id": 123,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Supplier Matching - Normalized Name Comparison with Business Suffix Removal",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Supplier Matching - Normalized Name Comparison with Business Suffix Removal feature - Remove business entity types: \"Pty Ltd\", \"Limited\", \"Inc\", \"Corporation\", \"Co\" - Remove location identifiers: \"Australia\", \"Australian\", \"Qld\", \"Queensland\" - Remove organizational terms: \"Group\", \" # app/services/supplier_matcher.rb\nclass SupplierMatcher\n  BUSINESS_SUFFIXES = [\n    'pty ltd', 'pty. ltd.', 'limited', 'ltd', 'ltd.',\n    'incorporated', 'inc', 'inc.',\n    'corporation', 'corp', 'corp.',\n    'company', 'co', 'co.',\n    'services', 'service',\n    'group',\n    'australia', 'australian',\n    'queensland', 'qld',\n    '& associates', '& sons'\n  ].freeze\n\n  def normalize_name(name)\n    normalized = name.to_s.downcase.strip\n\n    # Remove business suffixes\n    BUSINESS_SUFFIXES.each do |suffix|\n      normalized = normalized.gsub(/\\b#{Regexp.escape(suffix)}\\b/, '')\n    end\n\n    # Remove special characters and collapse spaces\n    normalized.gsub(/[^a-z0-9\\s]/, ' ').squeeze(' ').strip\n  end\n\n  def find_match(supplier_name)\n    normalized_search = normalize_name(supplier_name)\n\n    contacts = Contact.where(contact_types: ['supplier']).active\n\n    best_match = nil\n    best_score = 0.0\n\n    contacts.each do |contact|\n      normalized_contact = normalize_name(contact.full_name)\n      score = similarity_score(normalized_search, normalized_contact)\n\n      if score > best_score\n        best_score = score\n        best_match = contact\n      end\n    end\n\n    {\n      contact: best_match,\n      score: best_score,\n      match_type: categorize_match(best_score)\n    }\n  end\n\n  private\n\n  def similarity_score(str1, str2)\n    return 1.0 if str1 == str2\n    return 0.0 if str1.empty? || str2.empty?\n\n    distance = levenshtein_distance(str1, str2)\n    max_length = [str1.length, str2.length].max\n\n    1.0 - (distance.to_f / max_length)\n  end\n\n  def categorize_match(score)\n    case score\n    when 1.0        then :exact\n    when 0.9..0.99  then :high\n    when 0.7..0.89  then :fuzzy\n    else                 :unmatched\n    end\n  end\n\n  def levenshtein_distance(s1, s2)\n    # Dynamic programming algorithm\n    matrix = Array.new(s1.length + 1) { Array.new(s2.length + 1) }\n\n    (0..s1.length).each { |i| matrix[i][0] = i }\n    (0..s2.length).each { |j| matrix[0][j] = j }\n\n    (1..s1.length).each do |i|\n      (1..s2.length).each do |j|\n        cost = s1[i - 1] == s2[j - 1] ? 0 : 1\n        matrix[i][j] = [\n          matrix[i - 1][j] + 1,      # deletion\n          matrix[i][j - 1] + 1,      # insertion\n          matrix[i - 1][j - 1] + cost # substitution\n        ].min\n      end\n    end\n\n    matrix[s1.length][s2.length]\n  end\nend\n\n# ---\n\n\"Water Supplies Pty Ltd\" → \"water supplies\"\n\"ABC Electrical Services Queensland\" → \"abc electrical\"\n\"Smith & Associates Inc.\" → \"smith\" TRAPID_BIBLE.md RULE #4.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.4",
    "difficulty": "intermediate",
    "summary": "- Remove business entity types: \"Pty Ltd\", \"Limited\", \"Inc\", \"Corporation\", \"Co\" - Remove location identifiers: \"Australia\", \"Australian\", \"Qld\", \"Queensland\" - Remove organizational terms: \"Group\", \"",
    "code_example": "# app/services/supplier_matcher.rb\nclass SupplierMatcher\n  BUSINESS_SUFFIXES = [\n    'pty ltd', 'pty. ltd.', 'limited', 'ltd', 'ltd.',\n    'incorporated', 'inc', 'inc.',\n    'corporation', 'corp', 'corp.',\n    'company', 'co', 'co.',\n    'services', 'service',\n    'group',\n    'australia', 'australian',\n    'queensland', 'qld',\n    '& associates', '& sons'\n  ].freeze\n\n  def normalize_name(name)\n    normalized = name.to_s.downcase.strip\n\n    # Remove business suffixes\n    BUSINESS_SUFFIXES.each do |suffix|\n      normalized = normalized.gsub(/\\b#{Regexp.escape(suffix)}\\b/, '')\n    end\n\n    # Remove special characters and collapse spaces\n    normalized.gsub(/[^a-z0-9\\s]/, ' ').squeeze(' ').strip\n  end\n\n  def find_match(supplier_name)\n    normalized_search = normalize_name(supplier_name)\n\n    contacts = Contact.where(contact_types: ['supplier']).active\n\n    best_match = nil\n    best_score = 0.0\n\n    contacts.each do |contact|\n      normalized_contact = normalize_name(contact.full_name)\n      score = similarity_score(normalized_search, normalized_contact)\n\n      if score > best_score\n        best_score = score\n        best_match = contact\n      end\n    end\n\n    {\n      contact: best_match,\n      score: best_score,\n      match_type: categorize_match(best_score)\n    }\n  end\n\n  private\n\n  def similarity_score(str1, str2)\n    return 1.0 if str1 == str2\n    return 0.0 if str1.empty? || str2.empty?\n\n    distance = levenshtein_distance(str1, str2)\n    max_length = [str1.length, str2.length].max\n\n    1.0 - (distance.to_f / max_length)\n  end\n\n  def categorize_match(score)\n    case score\n    when 1.0        then :exact\n    when 0.9..0.99  then :high\n    when 0.7..0.89  then :fuzzy\n    else                 :unmatched\n    end\n  end\n\n  def levenshtein_distance(s1, s2)\n    # Dynamic programming algorithm\n    matrix = Array.new(s1.length + 1) { Array.new(s2.length + 1) }\n\n    (0..s1.length).each { |i| matrix[i][0] = i }\n    (0..s2.length).each { |j| matrix[0][j] = j }\n\n    (1..s1.length).each do |i|\n      (1..s2.length).each do |j|\n        cost = s1[i - 1] == s2[j - 1] ? 0 : 1\n        matrix[i][j] = [\n          matrix[i - 1][j] + 1,      # deletion\n          matrix[i][j - 1] + 1,      # insertion\n          matrix[i - 1][j - 1] + cost # substitution\n        ].min\n      end\n    end\n\n    matrix[s1.length][s2.length]\n  end\nend\n\n# ---\n\n\"Water Supplies Pty Ltd\" → \"water supplies\"\n\"ABC Electrical Services Queensland\" → \"abc electrical\"\n\"Smith & Associates Inc.\" → \"smith\"",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.4"
  },
  {
    "id": 124,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Price Volatility Detection - Coefficient of Variation on 6-Month Window",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Price Volatility Detection - Coefficient of Variation on 6-Month Window util - Use rolling 6-month window of prices - Calculate CV = (Standard Deviation / Mean) × 100 - Classify: stable (<5%), moderate (5-15%), volatile (>15%) - Require minimum 3 data points for valid calculat # app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  def price_volatility\n    # Get last 6 months of price history\n    recent_prices = price_histories\n      .where('created_at >= ?', 6.months.ago)\n      .order(created_at: :desc)\n      .pluck(:new_price)\n      .compact\n\n    return { status: 'unknown', cv: nil, risk_score: 10 } if recent_prices.length < 3\n\n    # Calculate mean\n    mean = recent_prices.sum / recent_prices.length.to_f\n\n    # Calculate standard deviation\n    variance = recent_prices.map { |p| (p - mean) ** 2 }.sum / recent_prices.length.to_f\n    std_dev = Math.sqrt(variance)\n\n    # Coefficient of Variation\n    cv = (std_dev / mean) * 100\n\n    # Classify volatility\n    status = case cv\n      when 0..4.99    then 'stable'\n      when 5..14.99   then 'moderate'\n      else                 'volatile'\n    end\n\n    # Risk score (0-50)\n    risk_score = case status\n      when 'stable'   then 0\n      when 'moderate' then 25\n      when 'volatile' then 50\n      else                 10  # unknown\n    end\n\n    { status: status, cv: cv.round(2), risk_score: risk_score }\n  end\nend\n\n# ---\n\n# Stable pricing\nprices = [100, 103, 102, 105, 104]\nmean = 102.8, std_dev = 1.92, CV = 1.87% → \"stable\"\n\n# Volatile pricing\nprices = [100, 150, 80, 160, 90]\nmean = 116, std_dev = 35.8, CV = 30.9% → \"volatile\" TRAPID_BIBLE.md RULE #4.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.5",
    "difficulty": "intermediate",
    "summary": "- Use rolling 6-month window of prices - Calculate CV = (Standard Deviation / Mean) × 100 - Classify: stable (<5%), moderate (5-15%), volatile (>15%) - Require minimum 3 data points for valid calculat",
    "code_example": "# app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  def price_volatility\n    # Get last 6 months of price history\n    recent_prices = price_histories\n      .where('created_at >= ?', 6.months.ago)\n      .order(created_at: :desc)\n      .pluck(:new_price)\n      .compact\n\n    return { status: 'unknown', cv: nil, risk_score: 10 } if recent_prices.length < 3\n\n    # Calculate mean\n    mean = recent_prices.sum / recent_prices.length.to_f\n\n    # Calculate standard deviation\n    variance = recent_prices.map { |p| (p - mean) ** 2 }.sum / recent_prices.length.to_f\n    std_dev = Math.sqrt(variance)\n\n    # Coefficient of Variation\n    cv = (std_dev / mean) * 100\n\n    # Classify volatility\n    status = case cv\n      when 0..4.99    then 'stable'\n      when 5..14.99   then 'moderate'\n      else                 'volatile'\n    end\n\n    # Risk score (0-50)\n    risk_score = case status\n      when 'stable'   then 0\n      when 'moderate' then 25\n      when 'volatile' then 50\n      else                 10  # unknown\n    end\n\n    { status: status, cv: cv.round(2), risk_score: risk_score }\n  end\nend\n\n# ---\n\n# Stable pricing\nprices = [100, 103, 102, 105, 104]\nmean = 102.8, std_dev = 1.92, CV = 1.87% → \"stable\"\n\n# Volatile pricing\nprices = [100, 150, 80, 160, 90]\nmean = 116, std_dev = 35.8, CV = 30.9% → \"volatile\"",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.5"
  },
  {
    "id": 125,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Risk Scoring - Multi-Factor Weighted Calculation (0-100 Scale)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Risk Scoring - Multi-Factor Weighted Calculation (0-100 Scale) component - Calculate all 4 components independently - Apply fixed weights (freshness=40%, reliability=20%, volatility=20%, missing=20%) - Return score 0-100 with level: low/medium/high/critical - Use database- # app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  def risk_score\n    Rails.cache.fetch(\"pricebook_item:#{id}:risk_score\", expires_in: 1.hour) do\n      calculate_risk_score\n    end\n  end\n\n  private\n\n  def calculate_risk_score\n    # Component 1: Price Freshness (0-40 points)\n    freshness_score = case price_freshness_status\n      when 'fresh'               then 0\n      when 'needs_confirmation'  then 20\n      when 'outdated', 'unknown' then 40\n      when 'missing'             then 40\n      else                            20\n    end\n\n    # Component 2: Supplier Reliability (0-20 points - inverse)\n    reliability_score = if supplier\n      # Higher supplier metrics = lower risk\n      supplier_score = (supplier.rating.to_f * 8) +           # 0-40\n                       (supplier.response_rate.to_f * 0.3) +  # 0-30\n                       ([30, 30 - (supplier.avg_response_time.to_f / 2)].min) # 0-30\n\n      # Convert 0-100 to 0-20 (inverse: high score = low risk)\n      20 - (supplier_score / 5.0)\n    else\n      20  # No supplier = max risk\n    end\n\n    # Component 3: Price Volatility (0-20 points)\n    volatility_data = price_volatility\n    volatility_score = volatility_data[:risk_score] * 0.4  # Scale 0-50 to 0-20\n\n    # Component 4: Missing Information (0-20 points)\n    missing_score = 0\n    missing_score += 10 if supplier_id.nil?\n    missing_score += 7  if brand.blank?\n    missing_score += 3  if category.blank?\n\n    # Total (0-100)\n    total = freshness_score +\n            reliability_score.clamp(0, 20) +\n            volatility_score +\n            missing_score\n\n    # Determine level\n    level = case total\n      when 0..24   then 'low'\n      when 25..49  then 'medium'\n      when 50..74  then 'high'\n      else              'critical'\n    end\n\n    {\n      score: total.round,\n      level: level,\n      components: {\n        freshness: freshness_score,\n        reliability: reliability_score.round,\n        volatility: volatility_score.round,\n        missing: missing_score\n      }\n    }\n  end\nend\n\n# ---\n\n# app/models/pricebook_item.rb\nscope :by_risk_level, ->(level) {\n  case level\n  when 'critical'\n    # No price OR price >6 months old\n    where('current_price IS NULL OR current_price = 0 OR price_last_updated_at < ?', 6.months.ago)\n  when 'high'\n    # 3-6 months old\n    where('price_last_updated_at >= ? AND price_last_updated_at < ?', 6.months.ago, 3.months.ago)\n  when 'medium'\n    # <3 months BUT missing supplier/brand/category\n    where('price_last_updated_at >= ?', 3.months.ago)\n      .where('supplier_id IS NULL OR brand IS NULL OR category IS NULL')\n  when 'low'\n    # Recent price AND has supplier\n    where('price_last_updated_at >= ? AND supplier_id IS NOT NULL', 3.months.ago)\n  end\n} TRAPID_BIBLE.md RULE #4.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.6",
    "difficulty": "intermediate",
    "summary": "- Calculate all 4 components independently - Apply fixed weights (freshness=40%, reliability=20%, volatility=20%, missing=20%) - Return score 0-100 with level: low/medium/high/critical - Use database-",
    "code_example": "# app/models/pricebook_item.rb\nclass PricebookItem < ApplicationRecord\n  def risk_score\n    Rails.cache.fetch(\"pricebook_item:#{id}:risk_score\", expires_in: 1.hour) do\n      calculate_risk_score\n    end\n  end\n\n  private\n\n  def calculate_risk_score\n    # Component 1: Price Freshness (0-40 points)\n    freshness_score = case price_freshness_status\n      when 'fresh'               then 0\n      when 'needs_confirmation'  then 20\n      when 'outdated', 'unknown' then 40\n      when 'missing'             then 40\n      else                            20\n    end\n\n    # Component 2: Supplier Reliability (0-20 points - inverse)\n    reliability_score = if supplier\n      # Higher supplier metrics = lower risk\n      supplier_score = (supplier.rating.to_f * 8) +           # 0-40\n                       (supplier.response_rate.to_f * 0.3) +  # 0-30\n                       ([30, 30 - (supplier.avg_response_time.to_f / 2)].min) # 0-30\n\n      # Convert 0-100 to 0-20 (inverse: high score = low risk)\n      20 - (supplier_score / 5.0)\n    else\n      20  # No supplier = max risk\n    end\n\n    # Component 3: Price Volatility (0-20 points)\n    volatility_data = price_volatility\n    volatility_score = volatility_data[:risk_score] * 0.4  # Scale 0-50 to 0-20\n\n    # Component 4: Missing Information (0-20 points)\n    missing_score = 0\n    missing_score += 10 if supplier_id.nil?\n    missing_score += 7  if brand.blank?\n    missing_score += 3  if category.blank?\n\n    # Total (0-100)\n    total = freshness_score +\n            reliability_score.clamp(0, 20) +\n            volatility_score +\n            missing_score\n\n    # Determine level\n    level = case total\n      when 0..24   then 'low'\n      when 25..49  then 'medium'\n      when 50..74  then 'high'\n      else              'critical'\n    end\n\n    {\n      score: total.round,\n      level: level,\n      components: {\n        freshness: freshness_score,\n        reliability: reliability_score.round,\n        volatility: volatility_score.round,\n        missing: missing_score\n      }\n    }\n  end\nend\n\n# ---\n\n# app/models/pricebook_item.rb\nscope :by_risk_level, ->(level) {\n  case level\n  when 'critical'\n    # No price OR price >6 months old\n    where('current_price IS NULL OR current_price = 0 OR price_last_updated_at < ?', 6.months.ago)\n  when 'high'\n    # 3-6 months old\n    where('price_last_updated_at >= ? AND price_last_updated_at < ?', 6.months.ago, 3.months.ago)\n  when 'medium'\n    # <3 months BUT missing supplier/brand/category\n    where('price_last_updated_at >= ?', 3.months.ago)\n      .where('supplier_id IS NULL OR brand IS NULL OR category IS NULL')\n  when 'low'\n    # Recent price AND has supplier\n    where('price_last_updated_at >= ? AND supplier_id IS NOT NULL', 3.months.ago)\n  end\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.6"
  },
  {
    "id": 126,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "Bulk Updates - Transaction Wrapper with Price History Batch Creation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Bulk Updates - Transaction Wrapper with Price History Batch Creation optimization - Wrap all updates in `ActiveRecord::Base.transaction` - Batch create price histories in single insert - Rollback entirely on any validation error - Return detailed success/failure report per item - U # app/controllers/api/v1/pricebook_items_controller.rb\ndef bulk_update\n  updates = params[:updates] || []\n  results = { success: [], failed: [], price_histories_created: 0 }\n\n  ActiveRecord::Base.transaction do\n    price_histories_batch = []\n\n    updates.each do |update_params|\n      item = PricebookItem.find_by(id: update_params[:id])\n\n      unless item\n        results[:failed] << { id: update_params[:id], error: 'Item not found' }\n        next\n      end\n\n      # Track price change for history\n      old_price = item.current_price\n      new_price = update_params[:current_price]\n\n      # Skip auto price history creation\n      item.skip_price_history_callback = true\n\n      # Update item\n      if item.update(update_params.except(:id, :create_or_update_price, :new_price))\n        results[:success] << { id: item.id, item_code: item.item_code }\n\n        # Prepare price history for batch insert\n        if new_price && new_price != old_price\n          price_histories_batch << {\n            pricebook_item_id: item.id,\n            old_price: old_price,\n            new_price: new_price,\n            change_reason: 'bulk_update',\n            supplier_id: item.default_supplier_id,\n            changed_by_user_id: current_user.id,\n            user_name: current_user.full_name,\n            date_effective: Date.current,\n            created_at: Time.current,\n            updated_at: Time.current\n          }\n        end\n      else\n        results[:failed] << {\n          id: item.id,\n          item_code: item.item_code,\n          errors: item.errors.full_messages\n        }\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    # Batch insert price histories\n    if price_histories_batch.any?\n      PriceHistory.insert_all!(price_histories_batch)\n      results[:price_histories_created] = price_histories_batch.length\n    end\n\n    # Commit transaction (implicit)\n  end\n\n  render json: {\n    success: true,\n    updated_count: results[:success].length,\n    failed_count: results[:failed].length,\n    price_histories_created: results[:price_histories_created],\n    results: results\n  }\nrescue ActiveRecord::Rollback\n  render json: {\n    success: false,\n    error: 'Bulk update failed - all changes rolled back',\n    results: results\n  }, status: :unprocessable_entity\nend\n\n# ---\n\nIndividual Updates (100 items):\n- 100 UPDATE queries\n- 100 INSERT queries (price history)\n= 200 queries, ~5 seconds\n\nBulk Update with Transaction:\n- 100 UPDATE queries\n- 1 INSERT query (batch)\n= 101 queries, ~1 second TRAPID_BIBLE.md RULE #4.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "optimization",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.7",
    "difficulty": "intermediate",
    "summary": "- Wrap all updates in `ActiveRecord::Base.transaction` - Batch create price histories in single insert - Rollback entirely on any validation error - Return detailed success/failure report per item - U",
    "code_example": "# app/controllers/api/v1/pricebook_items_controller.rb\ndef bulk_update\n  updates = params[:updates] || []\n  results = { success: [], failed: [], price_histories_created: 0 }\n\n  ActiveRecord::Base.transaction do\n    price_histories_batch = []\n\n    updates.each do |update_params|\n      item = PricebookItem.find_by(id: update_params[:id])\n\n      unless item\n        results[:failed] << { id: update_params[:id], error: 'Item not found' }\n        next\n      end\n\n      # Track price change for history\n      old_price = item.current_price\n      new_price = update_params[:current_price]\n\n      # Skip auto price history creation\n      item.skip_price_history_callback = true\n\n      # Update item\n      if item.update(update_params.except(:id, :create_or_update_price, :new_price))\n        results[:success] << { id: item.id, item_code: item.item_code }\n\n        # Prepare price history for batch insert\n        if new_price && new_price != old_price\n          price_histories_batch << {\n            pricebook_item_id: item.id,\n            old_price: old_price,\n            new_price: new_price,\n            change_reason: 'bulk_update',\n            supplier_id: item.default_supplier_id,\n            changed_by_user_id: current_user.id,\n            user_name: current_user.full_name,\n            date_effective: Date.current,\n            created_at: Time.current,\n            updated_at: Time.current\n          }\n        end\n      else\n        results[:failed] << {\n          id: item.id,\n          item_code: item.item_code,\n          errors: item.errors.full_messages\n        }\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    # Batch insert price histories\n    if price_histories_batch.any?\n      PriceHistory.insert_all!(price_histories_batch)\n      results[:price_histories_created] = price_histories_batch.length\n    end\n\n    # Commit transaction (implicit)\n  end\n\n  render json: {\n    success: true,\n    updated_count: results[:success].length,\n    failed_count: results[:failed].length,\n    price_histories_created: results[:price_histories_created],\n    results: results\n  }\nrescue ActiveRecord::Rollback\n  render json: {\n    success: false,\n    error: 'Bulk update failed - all changes rolled back',\n    results: results\n  }, status: :unprocessable_entity\nend\n\n# ---\n\nIndividual Updates (100 items):\n- 100 UPDATE queries\n- 100 INSERT queries (price history)\n= 200 queries, ~5 seconds\n\nBulk Update with Transaction:\n- 100 UPDATE queries\n- 1 INSERT query (batch)\n= 101 queries, ~1 second",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.7"
  },
  {
    "id": 127,
    "chapter_number": 4,
    "chapter_name": "Price Books & Suppliers",
    "component": null,
    "title": "OneDrive Image Proxy - Cache Control with 1-Hour Expiry",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OneDrive Image Proxy - Cache Control with 1-Hour Expiry integration - Set `Cache-Control: public, max-age=3600` (1 hour) - Store OneDrive `file_id` permanently (not URL) - Refresh URL on each request via Microsoft Graph API - Handle expired credentials gracefully (503 # app/controllers/api/v1/pricebook_items_controller.rb\ndef proxy_image\n  @item = PricebookItem.find(params[:id])\n  file_type = params[:file_type] # 'image', 'spec', or 'qr_code'\n\n  file_id = case file_type\n    when 'image'    then @item.image_file_id\n    when 'spec'     then @item.spec_file_id\n    when 'qr_code'  then @item.qr_code_file_id\n  end\n\n  unless file_id\n    render json: { error: 'File not found' }, status: :not_found\n    return\n  end\n\n  # Get OneDrive credential\n  credential = OrganizationOneDriveCredential.active.first\n  unless credential\n    render json: { error: 'OneDrive not configured' }, status: :service_unavailable\n    return\n  end\n\n  # Fetch file content from OneDrive\n  graph_client = MicrosoftGraphClient.new(credential)\n\n  begin\n    file_content = graph_client.download_file(file_id)\n    file_metadata = graph_client.get_file_metadata(file_id)\n\n    # Determine Content-Type\n    content_type = file_metadata['file']['mimeType'] || 'application/octet-stream'\n\n    # Send file with caching\n    send_data file_content,\n      type: content_type,\n      disposition: 'inline',\n      cache_control: 'public, max-age=3600'  # 1 hour cache\n\n  rescue MicrosoftGraphClient::FileNotFoundError\n    render json: { error: 'File not found in OneDrive' }, status: :not_found\n  rescue MicrosoftGraphClient::AuthenticationError\n    render json: { error: 'OneDrive credential expired' }, status: :service_unavailable\n  end\nend\n\n# ---\n\nget 'pricebook/:id/proxy_image/:file_type', to: 'pricebook_items#proxy_image' TRAPID_BIBLE.md RULE #4.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "4.8",
    "difficulty": "intermediate",
    "summary": "- Set `Cache-Control: public, max-age=3600` (1 hour) - Store OneDrive `file_id` permanently (not URL) - Refresh URL on each request via Microsoft Graph API - Handle expired credentials gracefully (503",
    "code_example": "# app/controllers/api/v1/pricebook_items_controller.rb\ndef proxy_image\n  @item = PricebookItem.find(params[:id])\n  file_type = params[:file_type] # 'image', 'spec', or 'qr_code'\n\n  file_id = case file_type\n    when 'image'    then @item.image_file_id\n    when 'spec'     then @item.spec_file_id\n    when 'qr_code'  then @item.qr_code_file_id\n  end\n\n  unless file_id\n    render json: { error: 'File not found' }, status: :not_found\n    return\n  end\n\n  # Get OneDrive credential\n  credential = OrganizationOneDriveCredential.active.first\n  unless credential\n    render json: { error: 'OneDrive not configured' }, status: :service_unavailable\n    return\n  end\n\n  # Fetch file content from OneDrive\n  graph_client = MicrosoftGraphClient.new(credential)\n\n  begin\n    file_content = graph_client.download_file(file_id)\n    file_metadata = graph_client.get_file_metadata(file_id)\n\n    # Determine Content-Type\n    content_type = file_metadata['file']['mimeType'] || 'application/octet-stream'\n\n    # Send file with caching\n    send_data file_content,\n      type: content_type,\n      disposition: 'inline',\n      cache_control: 'public, max-age=3600'  # 1 hour cache\n\n  rescue MicrosoftGraphClient::FileNotFoundError\n    render json: { error: 'File not found in OneDrive' }, status: :not_found\n  rescue MicrosoftGraphClient::AuthenticationError\n    render json: { error: 'OneDrive credential expired' }, status: :service_unavailable\n  end\nend\n\n# ---\n\nget 'pricebook/:id/proxy_image/:file_type', to: 'pricebook_items#proxy_image'",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #4.8"
  },
  {
    "id": 128,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Construction MUST Have At Least One Contact",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Construction MUST Have At Least One Contact util - Validate `must_have_at_least_one_contact` on update - Allow creation without contacts (initial save) - Require at least one contact before job can be used - Show validation error if all contacts rem # app/models/construction.rb\nclass Construction < ApplicationRecord\n  has_many :construction_contacts, dependent: :destroy\n  has_many :contacts, through: :construction_contacts\n\n  validates :title, presence: true\n  validates :status, presence: true\n  validates :site_supervisor_name, presence: true\n  validate :must_have_at_least_one_contact, on: :update\n\n  private\n\n  def must_have_at_least_one_contact\n    if construction_contacts.empty?\n      errors.add(:base, 'Construction must have at least one contact')\n    end\n  end\nend TRAPID_BIBLE.md RULE #5.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.1",
    "difficulty": "intermediate",
    "summary": "- Validate `must_have_at_least_one_contact` on update - Allow creation without contacts (initial save) - Require at least one contact before job can be used - Show validation error if all contacts rem",
    "code_example": "# app/models/construction.rb\nclass Construction < ApplicationRecord\n  has_many :construction_contacts, dependent: :destroy\n  has_many :contacts, through: :construction_contacts\n\n  validates :title, presence: true\n  validates :status, presence: true\n  validates :site_supervisor_name, presence: true\n  validate :must_have_at_least_one_contact, on: :update\n\n  private\n\n  def must_have_at_least_one_contact\n    if construction_contacts.empty?\n      errors.add(:base, 'Construction must have at least one contact')\n    end\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.1"
  },
  {
    "id": 129,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Live Profit Calculation - Dynamic Not Cached",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Live Profit Calculation - Dynamic Not Cached integration - Calculate `live_profit = contract_value - sum(all_purchase_orders.total)` - Recalculate `profit_percentage = (live_profit / contract_value) * 100` - Use `calculate_live_profit` and `calculate_profit # app/models/construction.rb\nclass Construction < ApplicationRecord\n  has_many :purchase_orders\n\n  def calculate_live_profit\n    return 0 if contract_value.nil?\n\n    total_po_cost = purchase_orders.sum(:total) || 0\n    contract_value - total_po_cost\n  end\n\n  def calculate_profit_percentage\n    return 0 if contract_value.nil? || contract_value.zero?\n\n    (calculate_live_profit / contract_value) * 100\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/constructions_controller.rb\ndef show\n  @construction = Construction.find(params[:id])\n  render json: @construction.as_json.merge(\n    live_profit: @construction.calculate_live_profit,\n    profit_percentage: @construction.calculate_profit_percentage\n  )\nend TRAPID_BIBLE.md RULE #5.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.2",
    "difficulty": "intermediate",
    "summary": "- Calculate `live_profit = contract_value - sum(all_purchase_orders.total)` - Recalculate `profit_percentage = (live_profit / contract_value) * 100` - Use `calculate_live_profit` and `calculate_profit",
    "code_example": "# app/models/construction.rb\nclass Construction < ApplicationRecord\n  has_many :purchase_orders\n\n  def calculate_live_profit\n    return 0 if contract_value.nil?\n\n    total_po_cost = purchase_orders.sum(:total) || 0\n    contract_value - total_po_cost\n  end\n\n  def calculate_profit_percentage\n    return 0 if contract_value.nil? || contract_value.zero?\n\n    (calculate_live_profit / contract_value) * 100\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/constructions_controller.rb\ndef show\n  @construction = Construction.find(params[:id])\n  render json: @construction.as_json.merge(\n    live_profit: @construction.calculate_live_profit,\n    profit_percentage: @construction.calculate_profit_percentage\n  )\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.2"
  },
  {
    "id": 130,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Task Dependencies - No Circular References",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Dependencies - No Circular References util - Validate `no_circular_dependencies` before saving TaskDependency - Use graph traversal (BFS) to detect cycles - Check entire predecessor chain for successor_task - Reject dependency if circular refe # app/models/task_dependency.rb\nclass TaskDependency < ApplicationRecord\n  belongs_to :successor_task, class_name: 'ProjectTask'\n  belongs_to :predecessor_task, class_name: 'ProjectTask'\n\n  validate :no_circular_dependencies\n  validate :no_self_dependency\n  validate :same_project_tasks\n\n  private\n\n  def no_circular_dependencies\n    return if creates_circular_dependency? == false\n\n    errors.add(:base, 'Cannot create circular dependency')\n  end\n\n  def no_self_dependency\n    if successor_task_id == predecessor_task_id\n      errors.add(:base, 'Task cannot depend on itself')\n    end\n  end\n\n  def same_project_tasks\n    if successor_task && predecessor_task &&\n       successor_task.project_id != predecessor_task.project_id\n      errors.add(:base, 'Both tasks must belong to the same project')\n    end\n  end\n\n  def creates_circular_dependency?\n    # BFS to find all predecessors of predecessor_task\n    visited = Set.new\n    queue = [predecessor_task_id]\n\n    while queue.any?\n      current_id = queue.shift\n      next if visited.include?(current_id)\n\n      visited.add(current_id)\n\n      # If we find successor_task in the chain, it's circular\n      return true if current_id == successor_task_id\n\n      # Add all predecessors of current task to queue\n      TaskDependency.where(successor_task_id: current_id).pluck(:predecessor_task_id).each do |pred_id|\n        queue << pred_id unless visited.include?(pred_id)\n      end\n    end\n\n    false\n  end\nend TRAPID_BIBLE.md RULE #5.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.3",
    "difficulty": "intermediate",
    "summary": "- Validate `no_circular_dependencies` before saving TaskDependency - Use graph traversal (BFS) to detect cycles - Check entire predecessor chain for successor_task - Reject dependency if circular refe",
    "code_example": "# app/models/task_dependency.rb\nclass TaskDependency < ApplicationRecord\n  belongs_to :successor_task, class_name: 'ProjectTask'\n  belongs_to :predecessor_task, class_name: 'ProjectTask'\n\n  validate :no_circular_dependencies\n  validate :no_self_dependency\n  validate :same_project_tasks\n\n  private\n\n  def no_circular_dependencies\n    return if creates_circular_dependency? == false\n\n    errors.add(:base, 'Cannot create circular dependency')\n  end\n\n  def no_self_dependency\n    if successor_task_id == predecessor_task_id\n      errors.add(:base, 'Task cannot depend on itself')\n    end\n  end\n\n  def same_project_tasks\n    if successor_task && predecessor_task &&\n       successor_task.project_id != predecessor_task.project_id\n      errors.add(:base, 'Both tasks must belong to the same project')\n    end\n  end\n\n  def creates_circular_dependency?\n    # BFS to find all predecessors of predecessor_task\n    visited = Set.new\n    queue = [predecessor_task_id]\n\n    while queue.any?\n      current_id = queue.shift\n      next if visited.include?(current_id)\n\n      visited.add(current_id)\n\n      # If we find successor_task in the chain, it's circular\n      return true if current_id == successor_task_id\n\n      # Add all predecessors of current task to queue\n      TaskDependency.where(successor_task_id: current_id).pluck(:predecessor_task_id).each do |pred_id|\n        queue << pred_id unless visited.include?(pred_id)\n      end\n    end\n\n    false\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.3"
  },
  {
    "id": 131,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Task Status Transitions - Automatic Date Setting",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Status Transitions - Automatic Date Setting util - Set `actual_start_date = Date.current` when status → `in_progress` (if nil) - Set `actual_end_date = Date.current` when status → `complete` - Set `progress_percentage = 100` when status → `complete` # app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  before_save :update_actual_dates\n\n  private\n\n  def update_actual_dates\n    if status_changed?\n      case status\n      when 'in_progress'\n        self.actual_start_date ||= Date.current\n      when 'complete'\n        self.actual_end_date = Date.current\n        self.progress_percentage = 100\n      end\n    end\n  end\nend TRAPID_BIBLE.md RULE #5.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.4",
    "difficulty": "intermediate",
    "summary": "- Set `actual_start_date = Date.current` when status → `in_progress` (if nil) - Set `actual_end_date = Date.current` when status → `complete` - Set `progress_percentage = 100` when status → `complete`",
    "code_example": "# app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  before_save :update_actual_dates\n\n  private\n\n  def update_actual_dates\n    if status_changed?\n      case status\n      when 'in_progress'\n        self.actual_start_date ||= Date.current\n      when 'complete'\n        self.actual_end_date = Date.current\n        self.progress_percentage = 100\n      end\n    end\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.4"
  },
  {
    "id": 132,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Task Spawning - Status-Based Child Task Creation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Spawning - Status-Based Child Task Creation feature - Spawn # app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  after_save :spawn_child_tasks_on_status_change\n\n  private\n\n  def spawn_child_tasks_on_status_change\n    return unless saved_change_to_status?\n    return unless schedule_template_row.present?\n\n    spawner = Schedule::TaskSpawner.new(self)\n\n    case status\n    when 'in_progress'\n      spawner.spawn_subtasks if schedule_template_row.has_subtasks?\n    when 'complete'\n      spawner.spawn_photo_task if schedule_template_row.require_photo?\n      spawner.spawn_certificate_task if schedule_template_row.require_certificate?\n    end\n  end\nend\n\n# ---\n\n# app/services/schedule/task_spawner.rb\nclass Schedule::TaskSpawner\n  def initialize(parent_task)\n    @parent_task = parent_task\n  end\n\n  def spawn_photo_task\n    ProjectTask.create!(\n      project: @parent_task.project,\n      name: \"Photo - #{@parent_task.name}\",\n      spawned_type: 'photo',\n      parent_task: @parent_task,\n      category: 'photo',\n      task_type: 'documentation',\n      status: 'not_started',\n      duration_days: 0,\n      planned_start_date: @parent_task.actual_end_date,\n      planned_end_date: @parent_task.actual_end_date\n    )\n  end\n\n  def spawn_certificate_task\n    lag_days = @parent_task.schedule_template_row&.cert_lag_days || 10\n\n    ProjectTask.create!(\n      project: @parent_task.project,\n      name: \"Certificate - #{@parent_task.name}\",\n      spawned_type: 'certificate',\n      parent_task: @parent_task,\n      category: 'certificate',\n      task_type: 'documentation',\n      status: 'not_started',\n      duration_days: 0,\n      planned_start_date: @parent_task.actual_end_date + lag_days.days,\n      planned_end_date: @parent_task.actual_end_date + lag_days.days\n    )\n  end\n\n  def spawn_subtasks\n    subtask_list = @parent_task.schedule_template_row.subtask_list || []\n\n    subtask_list.each_with_index do |subtask_name, index|\n      ProjectTask.create!(\n        project: @parent_task.project,\n        name: subtask_name,\n        spawned_type: 'subtask',\n        parent_task: @parent_task,\n        category: @parent_task.category,\n        task_type: @parent_task.task_type,\n        supplier_name: @parent_task.supplier_name,\n        status: 'not_started',\n        duration_days: 1,\n        sequence_order: (@parent_task.sequence_order || 0) + index + 1,\n        planned_start_date: @parent_task.planned_start_date,\n        planned_end_date: @parent_task.planned_start_date + 1.day\n      )\n    end\n  end\nend TRAPID_BIBLE.md RULE #5.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.5",
    "difficulty": "intermediate",
    "summary": "- Spawn",
    "code_example": "# app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  after_save :spawn_child_tasks_on_status_change\n\n  private\n\n  def spawn_child_tasks_on_status_change\n    return unless saved_change_to_status?\n    return unless schedule_template_row.present?\n\n    spawner = Schedule::TaskSpawner.new(self)\n\n    case status\n    when 'in_progress'\n      spawner.spawn_subtasks if schedule_template_row.has_subtasks?\n    when 'complete'\n      spawner.spawn_photo_task if schedule_template_row.require_photo?\n      spawner.spawn_certificate_task if schedule_template_row.require_certificate?\n    end\n  end\nend\n\n# ---\n\n# app/services/schedule/task_spawner.rb\nclass Schedule::TaskSpawner\n  def initialize(parent_task)\n    @parent_task = parent_task\n  end\n\n  def spawn_photo_task\n    ProjectTask.create!(\n      project: @parent_task.project,\n      name: \"Photo - #{@parent_task.name}\",\n      spawned_type: 'photo',\n      parent_task: @parent_task,\n      category: 'photo',\n      task_type: 'documentation',\n      status: 'not_started',\n      duration_days: 0,\n      planned_start_date: @parent_task.actual_end_date,\n      planned_end_date: @parent_task.actual_end_date\n    )\n  end\n\n  def spawn_certificate_task\n    lag_days = @parent_task.schedule_template_row&.cert_lag_days || 10\n\n    ProjectTask.create!(\n      project: @parent_task.project,\n      name: \"Certificate - #{@parent_task.name}\",\n      spawned_type: 'certificate',\n      parent_task: @parent_task,\n      category: 'certificate',\n      task_type: 'documentation',\n      status: 'not_started',\n      duration_days: 0,\n      planned_start_date: @parent_task.actual_end_date + lag_days.days,\n      planned_end_date: @parent_task.actual_end_date + lag_days.days\n    )\n  end\n\n  def spawn_subtasks\n    subtask_list = @parent_task.schedule_template_row.subtask_list || []\n\n    subtask_list.each_with_index do |subtask_name, index|\n      ProjectTask.create!(\n        project: @parent_task.project,\n        name: subtask_name,\n        spawned_type: 'subtask',\n        parent_task: @parent_task,\n        category: @parent_task.category,\n        task_type: @parent_task.task_type,\n        supplier_name: @parent_task.supplier_name,\n        status: 'not_started',\n        duration_days: 1,\n        sequence_order: (@parent_task.sequence_order || 0) + index + 1,\n        planned_start_date: @parent_task.planned_start_date,\n        planned_end_date: @parent_task.planned_start_date + 1.day\n      )\n    end\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.5"
  },
  {
    "id": 133,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Schedule Cascade - Dependency-Based Date Propagation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Schedule Cascade - Dependency-Based Date Propagation feature - Use `ScheduleCascadeService` to recalculate dependent task dates - Respect dependency types (FS/SS/FF/SF) - Apply lag_days to calculations - Skip manually_positioned tasks (user-set dates) - Recursi # app/services/schedule_cascade_service.rb\nclass ScheduleCascadeService\n  def initialize(changed_task)\n    @changed_task = changed_task\n    @project = changed_task.project\n    @timezone = CompanySetting.timezone || 'UTC'\n  end\n\n  def cascade!\n    # Find all tasks that depend on this task\n    dependent_tasks = TaskDependency\n      .where(predecessor_task_id: @changed_task.id)\n      .includes(:successor_task)\n      .map(&:successor_task)\n\n    dependent_tasks.each do |task|\n      next if task.manually_positioned? # Skip user-set dates\n\n      recalculate_task_dates(task)\n      task.save!\n\n      # Recursively cascade to downstream tasks\n      ScheduleCascadeService.new(task).cascade!\n    end\n  end\n\n  private\n\n  def recalculate_task_dates(task)\n    # Find all dependencies for this task\n    dependencies = TaskDependency.where(successor_task_id: task.id).includes(:predecessor_task)\n\n    # Calculate start date based on all predecessors\n    earliest_start = dependencies.map do |dep|\n      calculate_start_based_on_dependency(dep)\n    end.compact.max || @project.start_date\n\n    task.planned_start_date = earliest_start\n    task.planned_end_date = earliest_start + task.duration_days.days\n  end\n\n  def calculate_start_based_on_dependency(dependency)\n    pred_task = dependency.predecessor_task\n    lag = dependency.lag_days || 0\n\n    case dependency.dependency_type\n    when 'finish_to_start'\n      pred_task.planned_end_date + lag.days\n    when 'start_to_start'\n      pred_task.planned_start_date + lag.days\n    when 'finish_to_finish'\n      pred_task.planned_end_date - dependency.successor_task.duration_days.days + lag.days\n    when 'start_to_finish'\n      pred_task.planned_start_date + lag.days\n    end\n  end\nend\n\n# ---\n\n# app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  after_save :cascade_date_changes, if: :should_cascade?\n\n  private\n\n  def should_cascade?\n    saved_change_to_planned_start_date? ||\n    saved_change_to_planned_end_date? ||\n    saved_change_to_duration_days?\n  end\n\n  def cascade_date_changes\n    ScheduleCascadeService.new(self).cascade!\n  end\nend TRAPID_BIBLE.md RULE #5.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.6",
    "difficulty": "intermediate",
    "summary": "- Use `ScheduleCascadeService` to recalculate dependent task dates - Respect dependency types (FS/SS/FF/SF) - Apply lag_days to calculations - Skip manually_positioned tasks (user-set dates) - Recursi",
    "code_example": "# app/services/schedule_cascade_service.rb\nclass ScheduleCascadeService\n  def initialize(changed_task)\n    @changed_task = changed_task\n    @project = changed_task.project\n    @timezone = CompanySetting.timezone || 'UTC'\n  end\n\n  def cascade!\n    # Find all tasks that depend on this task\n    dependent_tasks = TaskDependency\n      .where(predecessor_task_id: @changed_task.id)\n      .includes(:successor_task)\n      .map(&:successor_task)\n\n    dependent_tasks.each do |task|\n      next if task.manually_positioned? # Skip user-set dates\n\n      recalculate_task_dates(task)\n      task.save!\n\n      # Recursively cascade to downstream tasks\n      ScheduleCascadeService.new(task).cascade!\n    end\n  end\n\n  private\n\n  def recalculate_task_dates(task)\n    # Find all dependencies for this task\n    dependencies = TaskDependency.where(successor_task_id: task.id).includes(:predecessor_task)\n\n    # Calculate start date based on all predecessors\n    earliest_start = dependencies.map do |dep|\n      calculate_start_based_on_dependency(dep)\n    end.compact.max || @project.start_date\n\n    task.planned_start_date = earliest_start\n    task.planned_end_date = earliest_start + task.duration_days.days\n  end\n\n  def calculate_start_based_on_dependency(dependency)\n    pred_task = dependency.predecessor_task\n    lag = dependency.lag_days || 0\n\n    case dependency.dependency_type\n    when 'finish_to_start'\n      pred_task.planned_end_date + lag.days\n    when 'start_to_start'\n      pred_task.planned_start_date + lag.days\n    when 'finish_to_finish'\n      pred_task.planned_end_date - dependency.successor_task.duration_days.days + lag.days\n    when 'start_to_finish'\n      pred_task.planned_start_date + lag.days\n    end\n  end\nend\n\n# ---\n\n# app/models/project_task.rb\nclass ProjectTask < ApplicationRecord\n  after_save :cascade_date_changes, if: :should_cascade?\n\n  private\n\n  def should_cascade?\n    saved_change_to_planned_start_date? ||\n    saved_change_to_planned_end_date? ||\n    saved_change_to_duration_days?\n  end\n\n  def cascade_date_changes\n    ScheduleCascadeService.new(self).cascade!\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.6"
  },
  {
    "id": 134,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "OneDrive Folder Creation - Async with Status Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OneDrive Folder Creation - Async with Status Tracking integration - Use `CreateJobFoldersJob` background job - Track status: `not_requested` → `pending` → `processing` → `completed` / `failed` - Use `onedrive_folder_creation_status` enum field - Set `onedrive_folder # app/controllers/api/v1/constructions_controller.rb\nclass Api::V1::ConstructionsController < ApplicationController\n  def create\n    @construction = Construction.new(construction_params)\n\n    if @construction.save\n      folder_creation_enqueued = false\n\n      if params[:create_onedrive_folders] && params[:template_id]\n        @construction.update(onedrive_folder_creation_status: :pending)\n        CreateJobFoldersJob.perform_later(@construction.id, params[:template_id])\n        folder_creation_enqueued = true\n      end\n\n      render json: @construction.as_json.merge(\n        folder_creation_enqueued: folder_creation_enqueued\n      ), status: :created\n    else\n      render json: { errors: @construction.errors.full_messages }, status: :unprocessable_entity\n    end\n  end\nend\n\n# ---\n\n# app/jobs/create_job_folders_job.rb\nclass CreateJobFoldersJob < ApplicationJob\n  queue_as :default\n\n  retry_on MicrosoftGraphClient::APIError, wait: :exponentially_longer, attempts: 3\n  retry_on MicrosoftGraphClient::AuthenticationError, wait: 5.seconds, attempts: 2\n\n  def perform(construction_id, template_id)\n    construction = Construction.find(construction_id)\n\n    # Update status to processing\n    construction.update!(onedrive_folder_creation_status: :processing)\n\n    # Get credential and template\n    credential = OrganizationOneDriveCredential.active.first\n    template = FolderTemplate.find(template_id)\n\n    # Check if folders already exist (idempotent)\n    graph_client = MicrosoftGraphClient.new(credential)\n    existing_folder = graph_client.find_folder_by_name(construction.title)\n\n    if existing_folder\n      construction.update!(\n        onedrive_folder_creation_status: :completed,\n        onedrive_folders_created_at: Time.current\n      )\n      return\n    end\n\n    # Create folder structure\n    root_folder = graph_client.create_folder(construction.title)\n    template.folder_structure.each do |subfolder|\n      graph_client.create_folder(subfolder['name'], parent_id: root_folder['id'])\n    end\n\n    # Mark as completed\n    construction.update!(\n      onedrive_folder_creation_status: :completed,\n      onedrive_folders_created_at: Time.current\n    )\n  rescue StandardError => e\n    construction.update!(onedrive_folder_creation_status: :failed)\n    raise e\n  end\nend\n\n# ---\n\n# app/models/construction.rb\nclass Construction < ApplicationRecord\n  enum onedrive_folder_creation_status: {\n    not_requested: 0,\n    pending: 1,\n    processing: 2,\n    completed: 3,\n    failed: 4\n  }\nend TRAPID_BIBLE.md RULE #5.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.7",
    "difficulty": "intermediate",
    "summary": "- Use `CreateJobFoldersJob` background job - Track status: `not_requested` → `pending` → `processing` → `completed` / `failed` - Use `onedrive_folder_creation_status` enum field - Set `onedrive_folder",
    "code_example": "# app/controllers/api/v1/constructions_controller.rb\nclass Api::V1::ConstructionsController < ApplicationController\n  def create\n    @construction = Construction.new(construction_params)\n\n    if @construction.save\n      folder_creation_enqueued = false\n\n      if params[:create_onedrive_folders] && params[:template_id]\n        @construction.update(onedrive_folder_creation_status: :pending)\n        CreateJobFoldersJob.perform_later(@construction.id, params[:template_id])\n        folder_creation_enqueued = true\n      end\n\n      render json: @construction.as_json.merge(\n        folder_creation_enqueued: folder_creation_enqueued\n      ), status: :created\n    else\n      render json: { errors: @construction.errors.full_messages }, status: :unprocessable_entity\n    end\n  end\nend\n\n# ---\n\n# app/jobs/create_job_folders_job.rb\nclass CreateJobFoldersJob < ApplicationJob\n  queue_as :default\n\n  retry_on MicrosoftGraphClient::APIError, wait: :exponentially_longer, attempts: 3\n  retry_on MicrosoftGraphClient::AuthenticationError, wait: 5.seconds, attempts: 2\n\n  def perform(construction_id, template_id)\n    construction = Construction.find(construction_id)\n\n    # Update status to processing\n    construction.update!(onedrive_folder_creation_status: :processing)\n\n    # Get credential and template\n    credential = OrganizationOneDriveCredential.active.first\n    template = FolderTemplate.find(template_id)\n\n    # Check if folders already exist (idempotent)\n    graph_client = MicrosoftGraphClient.new(credential)\n    existing_folder = graph_client.find_folder_by_name(construction.title)\n\n    if existing_folder\n      construction.update!(\n        onedrive_folder_creation_status: :completed,\n        onedrive_folders_created_at: Time.current\n      )\n      return\n    end\n\n    # Create folder structure\n    root_folder = graph_client.create_folder(construction.title)\n    template.folder_structure.each do |subfolder|\n      graph_client.create_folder(subfolder['name'], parent_id: root_folder['id'])\n    end\n\n    # Mark as completed\n    construction.update!(\n      onedrive_folder_creation_status: :completed,\n      onedrive_folders_created_at: Time.current\n    )\n  rescue StandardError => e\n    construction.update!(onedrive_folder_creation_status: :failed)\n    raise e\n  end\nend\n\n# ---\n\n# app/models/construction.rb\nclass Construction < ApplicationRecord\n  enum onedrive_folder_creation_status: {\n    not_requested: 0,\n    pending: 1,\n    processing: 2,\n    completed: 3,\n    failed: 4\n  }\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.7"
  },
  {
    "id": 135,
    "chapter_number": 5,
    "chapter_name": "Jobs & Construction Management",
    "component": null,
    "title": "Schedule Template Instantiation - All-or-Nothing Transaction",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Schedule Template Instantiation - All-or-Nothing Transaction util - Use `ActiveRecord::Base.transaction` for all template instantiation - Rollback entire operation if any task fails to create - Rollback if dependency creation fails - Rollback if date calculation fai # app/services/schedule/template_instantiator.rb\nclass Schedule::TemplateInstantiator\n  def initialize(project:, template:)\n    @project = project\n    @template = template\n    @task_map = {} # Maps template_row_id → created ProjectTask\n  end\n\n  def call\n    ActiveRecord::Base.transaction do\n      create_tasks_from_template\n      create_dependencies\n      calculate_dates_forward_pass\n      create_auto_purchase_orders\n      update_project_dates\n\n      { success: true, tasks: @task_map.values }\n    end\n  rescue StandardError => e\n    { success: false, errors: [e.message] }\n  end\n\n  private\n\n  def create_tasks_from_template\n    @template.schedule_template_rows.order(:sequence_order).each do |row|\n      task = ProjectTask.create!(\n        project: @project,\n        name: row.task_name,\n        task_type: row.task_type,\n        category: row.category,\n        duration_days: row.duration_days,\n        sequence_order: row.sequence_order,\n        schedule_template_row: row,\n        status: 'not_started',\n        is_milestone: row.is_milestone,\n        is_critical_path: row.is_critical_path\n      )\n\n      @task_map[row.id] = task\n    end\n  end\n\n  def create_dependencies\n    @template.schedule_template_rows.each do |row|\n      next if row.predecessors.blank?\n\n      row.predecessors.each do |pred_config|\n        predecessor_task = @task_map[pred_config['template_row_id']]\n        successor_task = @task_map[row.id]\n\n        TaskDependency.create!(\n          predecessor_task: predecessor_task,\n          successor_task: successor_task,\n          dependency_type: pred_config['type'] || 'finish_to_start',\n          lag_days: pred_config['lag_days'] || 0\n        )\n      end\n    end\n  end\n\n  def calculate_dates_forward_pass\n    # Forward pass algorithm to calculate all task dates\n    # ... (implementation details)\n  end\n\n  def create_auto_purchase_orders\n    # Create POs for tasks marked with creates_schedule_tasks\n    # ... (implementation details)\n  end\n\n  def update_project_dates\n    earliest_start = @task_map.values.map(&:planned_start_date).compact.min\n    latest_end = @task_map.values.map(&:planned_end_date).compact.max\n\n    @project.update!(\n      start_date: earliest_start,\n      planned_end_date: latest_end\n    )\n  end\nend TRAPID_BIBLE.md RULE #5.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "5.8",
    "difficulty": "intermediate",
    "summary": "- Use `ActiveRecord::Base.transaction` for all template instantiation - Rollback entire operation if any task fails to create - Rollback if dependency creation fails - Rollback if date calculation fai",
    "code_example": "# app/services/schedule/template_instantiator.rb\nclass Schedule::TemplateInstantiator\n  def initialize(project:, template:)\n    @project = project\n    @template = template\n    @task_map = {} # Maps template_row_id → created ProjectTask\n  end\n\n  def call\n    ActiveRecord::Base.transaction do\n      create_tasks_from_template\n      create_dependencies\n      calculate_dates_forward_pass\n      create_auto_purchase_orders\n      update_project_dates\n\n      { success: true, tasks: @task_map.values }\n    end\n  rescue StandardError => e\n    { success: false, errors: [e.message] }\n  end\n\n  private\n\n  def create_tasks_from_template\n    @template.schedule_template_rows.order(:sequence_order).each do |row|\n      task = ProjectTask.create!(\n        project: @project,\n        name: row.task_name,\n        task_type: row.task_type,\n        category: row.category,\n        duration_days: row.duration_days,\n        sequence_order: row.sequence_order,\n        schedule_template_row: row,\n        status: 'not_started',\n        is_milestone: row.is_milestone,\n        is_critical_path: row.is_critical_path\n      )\n\n      @task_map[row.id] = task\n    end\n  end\n\n  def create_dependencies\n    @template.schedule_template_rows.each do |row|\n      next if row.predecessors.blank?\n\n      row.predecessors.each do |pred_config|\n        predecessor_task = @task_map[pred_config['template_row_id']]\n        successor_task = @task_map[row.id]\n\n        TaskDependency.create!(\n          predecessor_task: predecessor_task,\n          successor_task: successor_task,\n          dependency_type: pred_config['type'] || 'finish_to_start',\n          lag_days: pred_config['lag_days'] || 0\n        )\n      end\n    end\n  end\n\n  def calculate_dates_forward_pass\n    # Forward pass algorithm to calculate all task dates\n    # ... (implementation details)\n  end\n\n  def create_auto_purchase_orders\n    # Create POs for tasks marked with creates_schedule_tasks\n    # ... (implementation details)\n  end\n\n  def update_project_dates\n    earliest_start = @task_map.values.map(&:planned_start_date).compact.min\n    latest_end = @task_map.values.map(&:planned_end_date).compact.max\n\n    @project.update!(\n      start_date: earliest_start,\n      planned_end_date: latest_end\n    )\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #5.8"
  },
  {
    "id": 136,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Fuzzy Job Matching - Three-Tier Confidence Thresholds",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Fuzzy Job Matching - Three-Tier Confidence Thresholds feature - Use Levenshtein distance + word matching + substring bonuses - Auto-match at # app/services/job_matcher_service.rb\nclass JobMatcherService\n  AUTO_MATCH_THRESHOLD = 70.0\n  SUGGEST_THRESHOLD = 50.0\n\n  def initialize(job_name_from_estimate)\n    @job_name = job_name_from_estimate\n    @normalized_search = normalize_string(job_name)\n  end\n\n  def call\n    matches = Construction.all.map do |construction|\n      {\n        construction: construction,\n        score: calculate_similarity_score(construction.title)\n      }\n    end.sort_by { |m| -m[:score] }\n\n    best_match = matches.first\n\n    if best_match[:score] >= AUTO_MATCH_THRESHOLD\n      {\n        success: true,\n        status: :auto_matched,\n        matched_job: {\n          id: best_match[:construction].id,\n          title: best_match[:construction].title,\n          confidence_score: best_match[:score]\n        }\n      }\n    elsif best_match[:score] >= SUGGEST_THRESHOLD\n      {\n        success: true,\n        status: :suggest_candidates,\n        candidate_jobs: matches.first(5).select { |m| m[:score] >= SUGGEST_THRESHOLD }\n      }\n    else\n      {\n        success: true,\n        status: :no_match,\n        job_name_searched: @job_name\n      }\n    end\n  end\n\n  private\n\n  def calculate_similarity_score(construction_title)\n    normalized_title = normalize_string(construction_title)\n\n    # Base: Levenshtein distance\n    distance = levenshtein_distance(@normalized_search, normalized_title)\n    max_length = [@normalized_search.length, normalized_title.length].max\n    base_score = (1.0 - (distance.to_f / max_length)) * 100\n\n    # Bonus: Substring match\n    if normalized_title.include?(@normalized_search) || @normalized_search.include?(normalized_title)\n      base_score += 20\n    end\n\n    # Bonus: Word matching\n    search_words = @normalized_search.split\n    title_words = normalized_title.split\n    matching_words = (search_words & title_words).length\n    base_score += (matching_words * 15)\n\n    # Cap at 99% (never 100% unless exact)\n    [base_score, 99.0].min.round(1)\n  end\n\n  def normalize_string(str)\n    str.downcase.strip.gsub(/[^a-z0-9\\s]/, '').squeeze(' ')\n  end\n\n  def levenshtein_distance(s1, s2)\n    # Dynamic programming algorithm\n    matrix = Array.new(s1.length + 1) { Array.new(s2.length + 1) }\n\n    (0..s1.length).each { |i| matrix[i][0] = i }\n    (0..s2.length).each { |j| matrix[0][j] = j }\n\n    (1..s1.length).each do |i|\n      (1..s2.length).each do |j|\n        cost = s1[i - 1] == s2[j - 1] ? 0 : 1\n        matrix[i][j] = [\n          matrix[i - 1][j] + 1,      # deletion\n          matrix[i][j - 1] + 1,      # insertion\n          matrix[i - 1][j - 1] + cost # substitution\n        ].min\n      end\n    end\n\n    matrix[s1.length][s2.length]\n  end\nend TRAPID_BIBLE.md RULE #6.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.1",
    "difficulty": "intermediate",
    "summary": "- Use Levenshtein distance + word matching + substring bonuses - Auto-match at",
    "code_example": "# app/services/job_matcher_service.rb\nclass JobMatcherService\n  AUTO_MATCH_THRESHOLD = 70.0\n  SUGGEST_THRESHOLD = 50.0\n\n  def initialize(job_name_from_estimate)\n    @job_name = job_name_from_estimate\n    @normalized_search = normalize_string(job_name)\n  end\n\n  def call\n    matches = Construction.all.map do |construction|\n      {\n        construction: construction,\n        score: calculate_similarity_score(construction.title)\n      }\n    end.sort_by { |m| -m[:score] }\n\n    best_match = matches.first\n\n    if best_match[:score] >= AUTO_MATCH_THRESHOLD\n      {\n        success: true,\n        status: :auto_matched,\n        matched_job: {\n          id: best_match[:construction].id,\n          title: best_match[:construction].title,\n          confidence_score: best_match[:score]\n        }\n      }\n    elsif best_match[:score] >= SUGGEST_THRESHOLD\n      {\n        success: true,\n        status: :suggest_candidates,\n        candidate_jobs: matches.first(5).select { |m| m[:score] >= SUGGEST_THRESHOLD }\n      }\n    else\n      {\n        success: true,\n        status: :no_match,\n        job_name_searched: @job_name\n      }\n    end\n  end\n\n  private\n\n  def calculate_similarity_score(construction_title)\n    normalized_title = normalize_string(construction_title)\n\n    # Base: Levenshtein distance\n    distance = levenshtein_distance(@normalized_search, normalized_title)\n    max_length = [@normalized_search.length, normalized_title.length].max\n    base_score = (1.0 - (distance.to_f / max_length)) * 100\n\n    # Bonus: Substring match\n    if normalized_title.include?(@normalized_search) || @normalized_search.include?(normalized_title)\n      base_score += 20\n    end\n\n    # Bonus: Word matching\n    search_words = @normalized_search.split\n    title_words = normalized_title.split\n    matching_words = (search_words & title_words).length\n    base_score += (matching_words * 15)\n\n    # Cap at 99% (never 100% unless exact)\n    [base_score, 99.0].min.round(1)\n  end\n\n  def normalize_string(str)\n    str.downcase.strip.gsub(/[^a-z0-9\\s]/, '').squeeze(' ')\n  end\n\n  def levenshtein_distance(s1, s2)\n    # Dynamic programming algorithm\n    matrix = Array.new(s1.length + 1) { Array.new(s2.length + 1) }\n\n    (0..s1.length).each { |i| matrix[i][0] = i }\n    (0..s2.length).each { |j| matrix[0][j] = j }\n\n    (1..s1.length).each do |i|\n      (1..s2.length).each do |j|\n        cost = s1[i - 1] == s2[j - 1] ? 0 : 1\n        matrix[i][j] = [\n          matrix[i - 1][j] + 1,      # deletion\n          matrix[i][j - 1] + 1,      # insertion\n          matrix[i - 1][j - 1] + cost # substitution\n        ].min\n      end\n    end\n\n    matrix[s1.length][s2.length]\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.1"
  },
  {
    "id": 137,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "External API Key Security - SHA256 Hashing Only",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "External API Key Security - SHA256 Hashing Only integration - Hash API keys with SHA256 before storage - Validate incoming keys by hashing and comparing digests - Store keys in `external_integrations` table - Track usage with `last_used_at` timestamp - Support # app/models/external_integration.rb\nclass ExternalIntegration < ApplicationRecord\n  validates :name, presence: true\n  validates :api_key_digest, presence: true\n\n  def self.authenticate(api_key)\n    digest = Digest::SHA256.hexdigest(api_key)\n    integration = find_by(api_key_digest: digest, active: true)\n\n    if integration\n      integration.touch(:last_used_at)  # Track usage\n      integration\n    else\n      nil\n    end\n  end\n\n  def generate_api_key\n    # Generate secure random key\n    new_key = SecureRandom.hex(32)\n\n    # Store digest only\n    self.api_key_digest = Digest::SHA256.hexdigest(new_key)\n    save!\n\n    # Return plaintext ONCE for user to save\n    new_key\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/external/unreal_estimates_controller.rb\nclass Api::V1::External::UnrealEstimatesController < ApplicationController\n  skip_before_action :verify_authenticity_token\n  before_action :authenticate_api_key\n\n  private\n\n  def authenticate_api_key\n    api_key = request.headers['X-API-Key']\n\n    unless api_key\n      render json: { error: 'Missing X-API-Key header' }, status: :unauthorized\n      return\n    end\n\n    @integration = ExternalIntegration.authenticate(api_key)\n\n    unless @integration\n      render json: { error: 'Invalid or inactive API key' }, status: :unauthorized\n      return\n    end\n  end\nend\n\n# ---\n\ncreate_table :external_integrations do |t|\n  t.string :name, null: false\n  t.string :api_key_digest, null: false  # SHA256 hash\n  t.boolean :active, default: true\n  t.datetime :last_used_at\n  t.timestamps\nend TRAPID_BIBLE.md RULE #6.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.2",
    "difficulty": "intermediate",
    "summary": "- Hash API keys with SHA256 before storage - Validate incoming keys by hashing and comparing digests - Store keys in `external_integrations` table - Track usage with `last_used_at` timestamp - Support",
    "code_example": "# app/models/external_integration.rb\nclass ExternalIntegration < ApplicationRecord\n  validates :name, presence: true\n  validates :api_key_digest, presence: true\n\n  def self.authenticate(api_key)\n    digest = Digest::SHA256.hexdigest(api_key)\n    integration = find_by(api_key_digest: digest, active: true)\n\n    if integration\n      integration.touch(:last_used_at)  # Track usage\n      integration\n    else\n      nil\n    end\n  end\n\n  def generate_api_key\n    # Generate secure random key\n    new_key = SecureRandom.hex(32)\n\n    # Store digest only\n    self.api_key_digest = Digest::SHA256.hexdigest(new_key)\n    save!\n\n    # Return plaintext ONCE for user to save\n    new_key\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/external/unreal_estimates_controller.rb\nclass Api::V1::External::UnrealEstimatesController < ApplicationController\n  skip_before_action :verify_authenticity_token\n  before_action :authenticate_api_key\n\n  private\n\n  def authenticate_api_key\n    api_key = request.headers['X-API-Key']\n\n    unless api_key\n      render json: { error: 'Missing X-API-Key header' }, status: :unauthorized\n      return\n    end\n\n    @integration = ExternalIntegration.authenticate(api_key)\n\n    unless @integration\n      render json: { error: 'Invalid or inactive API key' }, status: :unauthorized\n      return\n    end\n  end\nend\n\n# ---\n\ncreate_table :external_integrations do |t|\n  t.string :name, null: false\n  t.string :api_key_digest, null: false  # SHA256 hash\n  t.boolean :active, default: true\n  t.datetime :last_used_at\n  t.timestamps\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.2"
  },
  {
    "id": 138,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Estimate Import - Validate Before Auto-Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Estimate Import - Validate Before Auto-Matching integration - Validate `job_name` is present and non-empty - Validate `materials` array has at least 1 item - Validate each material has: `category`, `item`, `quantity` - Return 422 Unprocessable Entity for inval # app/controllers/api/v1/external/unreal_estimates_controller.rb\nclass Api::V1::External::UnrealEstimatesController < ApplicationController\n  def create\n    # Validate request parameters\n    unless params[:job_name].present?\n      render json: {\n        success: false,\n        error: 'Missing required field: job_name'\n      }, status: :unprocessable_entity\n      return\n    end\n\n    unless params[:materials].is_a?(Array) && params[:materials].any?\n      render json: {\n        success: false,\n        error: 'Missing or empty materials array'\n      }, status: :unprocessable_entity\n      return\n    end\n\n    # Validate each material\n    params[:materials].each_with_index do |material, index|\n      unless material[:item].present?\n        render json: {\n          success: false,\n          error: \"Material at index #{index} missing 'item' field\"\n        }, status: :unprocessable_entity\n        return\n      end\n\n      unless material[:quantity].present? && material[:quantity].to_f > 0\n        render json: {\n          success: false,\n          error: \"Material at index #{index} has invalid quantity\"\n        }, status: :unprocessable_entity\n        return\n      end\n    end\n\n    # Create estimate\n    @estimate = Estimate.new(\n      source: 'unreal_engine',\n      job_name_from_source: params[:job_name],\n      estimator_name: params[:estimator],\n      status: 'pending',\n      total_items: params[:materials].length\n    )\n\n    if @estimate.save\n      # Create line items\n      params[:materials].each do |material|\n        @estimate.estimate_line_items.create!(\n          category: material[:category],\n          item_description: material[:item],\n          quantity: material[:quantity],\n          unit: material[:unit] || 'ea',\n          notes: material[:notes]\n        )\n      end\n\n      # Attempt job matching\n      matcher = JobMatcherService.new(@estimate.job_name_from_source)\n      match_result = matcher.call\n\n      # ... handle match result\n    else\n      render json: {\n        success: false,\n        errors: @estimate.errors.full_messages\n      }, status: :unprocessable_entity\n    end\n  end\nend\n\n# ---\n\n{\n  \"success\": false,\n  \"error\": \"Material at index 0 missing 'item' field\"\n} TRAPID_BIBLE.md RULE #6.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.3",
    "difficulty": "intermediate",
    "summary": "- Validate `job_name` is present and non-empty - Validate `materials` array has at least 1 item - Validate each material has: `category`, `item`, `quantity` - Return 422 Unprocessable Entity for inval",
    "code_example": "# app/controllers/api/v1/external/unreal_estimates_controller.rb\nclass Api::V1::External::UnrealEstimatesController < ApplicationController\n  def create\n    # Validate request parameters\n    unless params[:job_name].present?\n      render json: {\n        success: false,\n        error: 'Missing required field: job_name'\n      }, status: :unprocessable_entity\n      return\n    end\n\n    unless params[:materials].is_a?(Array) && params[:materials].any?\n      render json: {\n        success: false,\n        error: 'Missing or empty materials array'\n      }, status: :unprocessable_entity\n      return\n    end\n\n    # Validate each material\n    params[:materials].each_with_index do |material, index|\n      unless material[:item].present?\n        render json: {\n          success: false,\n          error: \"Material at index #{index} missing 'item' field\"\n        }, status: :unprocessable_entity\n        return\n      end\n\n      unless material[:quantity].present? && material[:quantity].to_f > 0\n        render json: {\n          success: false,\n          error: \"Material at index #{index} has invalid quantity\"\n        }, status: :unprocessable_entity\n        return\n      end\n    end\n\n    # Create estimate\n    @estimate = Estimate.new(\n      source: 'unreal_engine',\n      job_name_from_source: params[:job_name],\n      estimator_name: params[:estimator],\n      status: 'pending',\n      total_items: params[:materials].length\n    )\n\n    if @estimate.save\n      # Create line items\n      params[:materials].each do |material|\n        @estimate.estimate_line_items.create!(\n          category: material[:category],\n          item_description: material[:item],\n          quantity: material[:quantity],\n          unit: material[:unit] || 'ea',\n          notes: material[:notes]\n        )\n      end\n\n      # Attempt job matching\n      matcher = JobMatcherService.new(@estimate.job_name_from_source)\n      match_result = matcher.call\n\n      # ... handle match result\n    else\n      render json: {\n        success: false,\n        errors: @estimate.errors.full_messages\n      }, status: :unprocessable_entity\n    end\n  end\nend\n\n# ---\n\n{\n  \"success\": false,\n  \"error\": \"Material at index 0 missing 'item' field\"\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.3"
  },
  {
    "id": 139,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "PO Generation from Estimate - Transaction Safety",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "PO Generation from Estimate - Transaction Safety feature - Wrap entire conversion in `ActiveRecord::Base.transaction` - Rollback if any PO creation fails - Rollback if any line item creation fails - Rollback if supplier lookup fails critically - Mark estima # app/services/estimate_to_purchase_order_service.rb\nclass EstimateToPurchaseOrderService\n  def initialize(estimate)\n    @estimate = estimate\n    @construction = estimate.construction\n    @created_pos = []\n    @warnings = []\n  end\n\n  def execute\n    # Validation\n    unless @estimate.status == 'matched'\n      return { success: false, error: 'Estimate must be matched to a job first' }\n    end\n\n    unless @estimate.estimate_line_items.any?\n      return { success: false, error: 'Estimate has no line items' }\n    end\n\n    # Transaction-wrapped conversion\n    ActiveRecord::Base.transaction do\n      # Group line items by category\n      @estimate.estimate_line_items.group_by(&:category).each do |category, items|\n        create_purchase_order_for_category(category, items)\n      end\n\n      # Mark estimate as imported\n      @estimate.update!(status: 'imported', imported_at: Time.current)\n\n      # Commit transaction (implicit)\n    end\n\n    # Success response\n    {\n      success: true,\n      estimate_id: @estimate.id,\n      purchase_orders_created: @created_pos.length,\n      purchase_orders: @created_pos.map(&:summary_hash),\n      warnings: @warnings\n    }\n\n  rescue ActiveRecord::RecordInvalid => e\n    # Transaction rolled back automatically\n    { success: false, error: \"Database validation failed: #{e.message}\" }\n  rescue StandardError => e\n    # Transaction rolled back automatically\n    Rails.logger.error(\"Estimate to PO conversion failed: #{e.message}\")\n    { success: false, error: 'Internal error during conversion' }\n  end\n\n  private\n\n  def create_purchase_order_for_category(category, items)\n    # Smart supplier lookup\n    lookup_result = SmartPoLookupService.new.lookup(\n      task_description: items.first.item_description,\n      category: category&.downcase\n    )\n\n    supplier = lookup_result[:supplier]\n\n    # Create PO\n    po = PurchaseOrder.create!(\n      construction: @construction,\n      estimate: @estimate,\n      supplier: supplier,\n      description: \"Auto-generated from #{@estimate.source} estimate\",\n      status: 'draft',\n      required_date: 14.days.from_now.to_date,\n      delivery_address: @construction.title,\n      special_instructions: build_special_instructions(category, supplier)\n    )\n\n    # Create line items\n    items.each_with_index do |item, index|\n      item_lookup = SmartPoLookupService.new.lookup(\n        task_description: item.item_description,\n        category: category&.downcase,\n        quantity: item.quantity\n      )\n\n      PurchaseOrderLineItem.create!(\n        purchase_order: po,\n        line_number: index + 1,\n        description: item.item_description,\n        quantity: item.quantity,\n        unit_price: item_lookup[:unit_price] || 0,\n        pricebook_item_id: item_lookup[:price_book_item]&.id,\n        notes: item.notes\n      )\n\n      # Track warnings\n      if item_lookup[:warnings].any?\n        @warnings.concat(item_lookup[:warnings])\n      end\n    end\n\n    # Calculate PO totals\n    po.calculate_totals\n    po.save!\n\n    @created_pos << po\n  end\nend TRAPID_BIBLE.md RULE #6.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.4",
    "difficulty": "intermediate",
    "summary": "- Wrap entire conversion in `ActiveRecord::Base.transaction` - Rollback if any PO creation fails - Rollback if any line item creation fails - Rollback if supplier lookup fails critically - Mark estima",
    "code_example": "# app/services/estimate_to_purchase_order_service.rb\nclass EstimateToPurchaseOrderService\n  def initialize(estimate)\n    @estimate = estimate\n    @construction = estimate.construction\n    @created_pos = []\n    @warnings = []\n  end\n\n  def execute\n    # Validation\n    unless @estimate.status == 'matched'\n      return { success: false, error: 'Estimate must be matched to a job first' }\n    end\n\n    unless @estimate.estimate_line_items.any?\n      return { success: false, error: 'Estimate has no line items' }\n    end\n\n    # Transaction-wrapped conversion\n    ActiveRecord::Base.transaction do\n      # Group line items by category\n      @estimate.estimate_line_items.group_by(&:category).each do |category, items|\n        create_purchase_order_for_category(category, items)\n      end\n\n      # Mark estimate as imported\n      @estimate.update!(status: 'imported', imported_at: Time.current)\n\n      # Commit transaction (implicit)\n    end\n\n    # Success response\n    {\n      success: true,\n      estimate_id: @estimate.id,\n      purchase_orders_created: @created_pos.length,\n      purchase_orders: @created_pos.map(&:summary_hash),\n      warnings: @warnings\n    }\n\n  rescue ActiveRecord::RecordInvalid => e\n    # Transaction rolled back automatically\n    { success: false, error: \"Database validation failed: #{e.message}\" }\n  rescue StandardError => e\n    # Transaction rolled back automatically\n    Rails.logger.error(\"Estimate to PO conversion failed: #{e.message}\")\n    { success: false, error: 'Internal error during conversion' }\n  end\n\n  private\n\n  def create_purchase_order_for_category(category, items)\n    # Smart supplier lookup\n    lookup_result = SmartPoLookupService.new.lookup(\n      task_description: items.first.item_description,\n      category: category&.downcase\n    )\n\n    supplier = lookup_result[:supplier]\n\n    # Create PO\n    po = PurchaseOrder.create!(\n      construction: @construction,\n      estimate: @estimate,\n      supplier: supplier,\n      description: \"Auto-generated from #{@estimate.source} estimate\",\n      status: 'draft',\n      required_date: 14.days.from_now.to_date,\n      delivery_address: @construction.title,\n      special_instructions: build_special_instructions(category, supplier)\n    )\n\n    # Create line items\n    items.each_with_index do |item, index|\n      item_lookup = SmartPoLookupService.new.lookup(\n        task_description: item.item_description,\n        category: category&.downcase,\n        quantity: item.quantity\n      )\n\n      PurchaseOrderLineItem.create!(\n        purchase_order: po,\n        line_number: index + 1,\n        description: item.item_description,\n        quantity: item.quantity,\n        unit_price: item_lookup[:unit_price] || 0,\n        pricebook_item_id: item_lookup[:price_book_item]&.id,\n        notes: item.notes\n      )\n\n      # Track warnings\n      if item_lookup[:warnings].any?\n        @warnings.concat(item_lookup[:warnings])\n      end\n    end\n\n    # Calculate PO totals\n    po.calculate_totals\n    po.save!\n\n    @created_pos << po\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.4"
  },
  {
    "id": 140,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "AI Plan Review - Async Processing Required",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "AI Plan Review - Async Processing Required integration - Enqueue `AiReviewJob` for all plan reviews - Create `EstimateReview` record with `status: 'pending'` immediately - Return review_id to client for polling - Update status to `processing` → `completed # app/controllers/api/v1/estimate_reviews_controller.rb\nclass Api::V1::EstimateReviewsController < ApplicationController\n  def create\n    @estimate = Estimate.find(params[:estimate_id])\n\n    # Validate estimate is matched\n    unless @estimate.construction\n      render json: { error: 'Estimate must be matched to a construction first' }, status: :unprocessable_entity\n      return\n    end\n\n    # Create review record\n    @review = @estimate.estimate_reviews.create!(\n      status: 'pending'\n    )\n\n    # Enqueue background job\n    AiReviewJob.perform_later(@estimate.id)\n\n    # Immediate response\n    render json: {\n      success: true,\n      review_id: @review.id,\n      status: 'processing',\n      message: 'AI review started. Poll /api/v1/estimate_reviews/:id for results.'\n    }, status: :accepted  # 202 Accepted\n  end\n\n  def show\n    @review = EstimateReview.find(params[:id])\n\n    render json: {\n      success: true,\n      review_id: @review.id,\n      status: @review.status,\n      reviewed_at: @review.reviewed_at,\n      confidence_score: @review.confidence_score,\n      summary: {\n        items_matched: @review.items_matched,\n        items_mismatched: @review.items_mismatched,\n        items_missing: @review.items_missing,\n        items_extra: @review.items_extra\n      },\n      discrepancies: @review.discrepancies,\n      ai_findings: @review.ai_findings\n    }\n  end\nend\n\n# ---\n\n# app/jobs/ai_review_job.rb\nclass AiReviewJob < ApplicationJob\n  queue_as :default\n\n  def perform(estimate_id)\n    estimate = Estimate.find(estimate_id)\n    review = estimate.estimate_reviews.pending.last\n\n    # Update status to processing\n    review.update!(status: 'processing')\n\n    # Execute AI review\n    service = PlanReviewService.new(estimate)\n    result = service.execute\n\n    if result[:success]\n      review.update!(\n        status: 'completed',\n        ai_findings: result[:ai_findings],\n        discrepancies: result[:discrepancies],\n        items_matched: result[:items_matched],\n        items_mismatched: result[:items_mismatched],\n        items_missing: result[:items_missing],\n        items_extra: result[:items_extra],\n        confidence_score: result[:confidence_score],\n        reviewed_at: Time.current\n      )\n    else\n      review.update!(status: 'failed')\n    end\n  rescue StandardError => e\n    review.update!(status: 'failed')\n    Rails.logger.error(\"AI Review Job failed: #{e.message}\")\n    raise e  # Re-raise for Solid Queue retry logic\n  end\nend\n\n# ---\n\n// Poll every 2 seconds until status changes from 'processing'\nconst pollReviewStatus = async (reviewId) => {\n  const response = await fetch(`/api/v1/estimate_reviews/${reviewId}`);\n  const data = await response.json();\n\n  if (data.status === 'processing') {\n    setTimeout(() => pollReviewStatus(reviewId), 2000);\n  } else {\n    // Display results\n    showReviewResults(data);\n  }\n}; TRAPID_BIBLE.md RULE #6.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.5",
    "difficulty": "intermediate",
    "summary": "- Enqueue `AiReviewJob` for all plan reviews - Create `EstimateReview` record with `status: 'pending'` immediately - Return review_id to client for polling - Update status to `processing` → `completed",
    "code_example": "# app/controllers/api/v1/estimate_reviews_controller.rb\nclass Api::V1::EstimateReviewsController < ApplicationController\n  def create\n    @estimate = Estimate.find(params[:estimate_id])\n\n    # Validate estimate is matched\n    unless @estimate.construction\n      render json: { error: 'Estimate must be matched to a construction first' }, status: :unprocessable_entity\n      return\n    end\n\n    # Create review record\n    @review = @estimate.estimate_reviews.create!(\n      status: 'pending'\n    )\n\n    # Enqueue background job\n    AiReviewJob.perform_later(@estimate.id)\n\n    # Immediate response\n    render json: {\n      success: true,\n      review_id: @review.id,\n      status: 'processing',\n      message: 'AI review started. Poll /api/v1/estimate_reviews/:id for results.'\n    }, status: :accepted  # 202 Accepted\n  end\n\n  def show\n    @review = EstimateReview.find(params[:id])\n\n    render json: {\n      success: true,\n      review_id: @review.id,\n      status: @review.status,\n      reviewed_at: @review.reviewed_at,\n      confidence_score: @review.confidence_score,\n      summary: {\n        items_matched: @review.items_matched,\n        items_mismatched: @review.items_mismatched,\n        items_missing: @review.items_missing,\n        items_extra: @review.items_extra\n      },\n      discrepancies: @review.discrepancies,\n      ai_findings: @review.ai_findings\n    }\n  end\nend\n\n# ---\n\n# app/jobs/ai_review_job.rb\nclass AiReviewJob < ApplicationJob\n  queue_as :default\n\n  def perform(estimate_id)\n    estimate = Estimate.find(estimate_id)\n    review = estimate.estimate_reviews.pending.last\n\n    # Update status to processing\n    review.update!(status: 'processing')\n\n    # Execute AI review\n    service = PlanReviewService.new(estimate)\n    result = service.execute\n\n    if result[:success]\n      review.update!(\n        status: 'completed',\n        ai_findings: result[:ai_findings],\n        discrepancies: result[:discrepancies],\n        items_matched: result[:items_matched],\n        items_mismatched: result[:items_mismatched],\n        items_missing: result[:items_missing],\n        items_extra: result[:items_extra],\n        confidence_score: result[:confidence_score],\n        reviewed_at: Time.current\n      )\n    else\n      review.update!(status: 'failed')\n    end\n  rescue StandardError => e\n    review.update!(status: 'failed')\n    Rails.logger.error(\"AI Review Job failed: #{e.message}\")\n    raise e  # Re-raise for Solid Queue retry logic\n  end\nend\n\n# ---\n\n// Poll every 2 seconds until status changes from 'processing'\nconst pollReviewStatus = async (reviewId) => {\n  const response = await fetch(`/api/v1/estimate_reviews/${reviewId}`);\n  const data = await response.json();\n\n  if (data.status === 'processing') {\n    setTimeout(() => pollReviewStatus(reviewId), 2000);\n  } else {\n    // Display results\n    showReviewResults(data);\n  }\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.5"
  },
  {
    "id": 141,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Line Item Categorization - Normalized Category Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Line Item Categorization - Normalized Category Matching integration - Normalize categories to lowercase before grouping - Map common variations: \"plumbing\" = \"plumber\" = \"plumb\" - Use category normalization service - Handle nil/blank categories with \"Uncategorized\" gr # app/services/estimate_to_purchase_order_service.rb\ndef normalized_category(category)\n  return 'uncategorized' if category.blank?\n\n  normalized = category.downcase.strip\n\n  # Common variations mapping\n  CATEGORY_MAPPINGS = {\n    'plumber' => 'plumbing',\n    'plumb' => 'plumbing',\n    'electrician' => 'electrical',\n    'elect' => 'electrical',\n    'carpenter' => 'carpentry',\n    'carp' => 'carpentry',\n    'paint' => 'painting',\n    'concrete' => 'concreting',\n    'concret' => 'concreting'\n  }.freeze\n\n  CATEGORY_MAPPINGS[normalized] || normalized\nend\n\n# Group line items with normalized categories\ngrouped_items = @estimate.estimate_line_items.group_by do |item|\n  normalized_category(item.category)\nend\n\n# ---\n\n# app/services/smart_po_lookup_service.rb\ndef lookup(task_description:, category:, quantity: 1)\n  normalized_cat = CategoryNormalizationService.normalize(category)\n\n  # Find supplier by normalized category\n  supplier = find_supplier_for_category(normalized_cat)\n\n  # ... rest of lookup logic\nend TRAPID_BIBLE.md RULE #6.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.6",
    "difficulty": "intermediate",
    "summary": "- Normalize categories to lowercase before grouping - Map common variations: \"plumbing\" = \"plumber\" = \"plumb\" - Use category normalization service - Handle nil/blank categories with \"Uncategorized\" gr",
    "code_example": "# app/services/estimate_to_purchase_order_service.rb\ndef normalized_category(category)\n  return 'uncategorized' if category.blank?\n\n  normalized = category.downcase.strip\n\n  # Common variations mapping\n  CATEGORY_MAPPINGS = {\n    'plumber' => 'plumbing',\n    'plumb' => 'plumbing',\n    'electrician' => 'electrical',\n    'elect' => 'electrical',\n    'carpenter' => 'carpentry',\n    'carp' => 'carpentry',\n    'paint' => 'painting',\n    'concrete' => 'concreting',\n    'concret' => 'concreting'\n  }.freeze\n\n  CATEGORY_MAPPINGS[normalized] || normalized\nend\n\n# Group line items with normalized categories\ngrouped_items = @estimate.estimate_line_items.group_by do |item|\n  normalized_category(item.category)\nend\n\n# ---\n\n# app/services/smart_po_lookup_service.rb\ndef lookup(task_description:, category:, quantity: 1)\n  normalized_cat = CategoryNormalizationService.normalize(category)\n\n  # Find supplier by normalized category\n  supplier = find_supplier_for_category(normalized_cat)\n\n  # ... rest of lookup logic\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.6"
  },
  {
    "id": 142,
    "chapter_number": 6,
    "chapter_name": "Estimates & Quoting",
    "component": null,
    "title": "Estimate Status State Machine - Strict Transitions",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Estimate Status State Machine - Strict Transitions util - Start at `pending` status on creation - Transition to `matched` when linked to construction - Transition to `imported` when POs generated - Allow `rejected` from any state - Prevent reverse transiti pending ─┬─> matched ──> imported\n         │\n         └─> rejected (terminal)\n\n# ---\n\n# app/models/estimate.rb\nclass Estimate < ApplicationRecord\n  STATUSES = %w[pending matched imported rejected].freeze\n\n  validates :status, inclusion: { in: STATUSES }\n  validate :valid_status_transition, on: :update\n\n  def match_to_construction!(construction, confidence_score)\n    raise \"Cannot match from status: #{status}\" unless status == 'pending'\n\n    update!(\n      construction: construction,\n      match_confidence_score: confidence_score,\n      status: 'matched'\n    )\n  end\n\n  def mark_imported!\n    raise \"Cannot import from status: #{status}\" unless status == 'matched'\n\n    update!(\n      status: 'imported',\n      imported_at: Time.current\n    )\n  end\n\n  def reject!\n    update!(status: 'rejected')\n  end\n\n  private\n\n  def valid_status_transition\n    return unless status_changed?\n\n    old_status = status_was\n    new_status = status\n\n    invalid_transitions = {\n      'matched' => ['pending'],\n      'imported' => ['pending', 'matched'],\n      'rejected' => []  # Can transition to rejected from anywhere\n    }\n\n    if invalid_transitions[new_status]&.include?(old_status)\n      errors.add(:status, \"cannot transition from #{old_status} to #{new_status}\")\n    end\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/estimates_controller.rb\ndef match\n  @estimate = Estimate.find(params[:id])\n  construction = Construction.find(params[:construction_id])\n\n  begin\n    @estimate.match_to_construction!(construction, 100.0)  # Manual match = 100%\n    render json: { success: true, estimate: @estimate }\n  rescue => e\n    render json: { error: e.message }, status: :unprocessable_entity\n  end\nend TRAPID_BIBLE.md RULE #6.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "6.7",
    "difficulty": "intermediate",
    "summary": "- Start at `pending` status on creation - Transition to `matched` when linked to construction - Transition to `imported` when POs generated - Allow `rejected` from any state - Prevent reverse transiti",
    "code_example": "pending ─┬─> matched ──> imported\n         │\n         └─> rejected (terminal)\n\n# ---\n\n# app/models/estimate.rb\nclass Estimate < ApplicationRecord\n  STATUSES = %w[pending matched imported rejected].freeze\n\n  validates :status, inclusion: { in: STATUSES }\n  validate :valid_status_transition, on: :update\n\n  def match_to_construction!(construction, confidence_score)\n    raise \"Cannot match from status: #{status}\" unless status == 'pending'\n\n    update!(\n      construction: construction,\n      match_confidence_score: confidence_score,\n      status: 'matched'\n    )\n  end\n\n  def mark_imported!\n    raise \"Cannot import from status: #{status}\" unless status == 'matched'\n\n    update!(\n      status: 'imported',\n      imported_at: Time.current\n    )\n  end\n\n  def reject!\n    update!(status: 'rejected')\n  end\n\n  private\n\n  def valid_status_transition\n    return unless status_changed?\n\n    old_status = status_was\n    new_status = status\n\n    invalid_transitions = {\n      'matched' => ['pending'],\n      'imported' => ['pending', 'matched'],\n      'rejected' => []  # Can transition to rejected from anywhere\n    }\n\n    if invalid_transitions[new_status]&.include?(old_status)\n      errors.add(:status, \"cannot transition from #{old_status} to #{new_status}\")\n    end\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/estimates_controller.rb\ndef match\n  @estimate = Estimate.find(params[:id])\n  construction = Construction.find(params[:construction_id])\n\n  begin\n    @estimate.match_to_construction!(construction, 100.0)  # Manual match = 100%\n    render json: { success: true, estimate: @estimate }\n  rescue => e\n    render json: { error: e.message }, status: :unprocessable_entity\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #6.7"
  },
  {
    "id": 143,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Estimate Must Be Matched to Construction",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Estimate Must Be Matched to Construction component - Validate `estimate.construction_id` is present before starting review - Return 422 status with clear error message if not matched - Show \"Match to Job\" button in UI if unmatched # app/services/plan_review_service.rb\ndef validate_estimate_matched!\n  unless @estimate.construction\n    raise NoConstructionError, \"Estimate must be matched to a construction/job before AI review\"\n  end\nend TRAPID_BIBLE.md RULE #7.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.1",
    "difficulty": "intermediate",
    "summary": "- Validate `estimate.construction_id` is present before starting review - Return 422 status with clear error message if not matched - Show \"Match to Job\" button in UI if unmatched",
    "code_example": "# app/services/plan_review_service.rb\ndef validate_estimate_matched!\n  unless @estimate.construction\n    raise NoConstructionError, \"Estimate must be matched to a construction/job before AI review\"\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.1"
  },
  {
    "id": 144,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "OneDrive Plan Folder Structure",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OneDrive Plan Folder Structure util 1. `01 - Plans` 2. `02 - Engineering` 3. `03 - Specifications` # app/services/plan_review_service.rb\nPLAN_FOLDER_PATHS = ['01 - Plans', '02 - Engineering', '03 - Specifications'].freeze\n\ndef fetch_pdf_plans_from_onedrive\n  PLAN_FOLDER_PATHS.each do |folder_name|\n    folder = find_folder_by_name(folder_name)\n    next unless folder\n\n    files = list_files_in_folder(folder['id'])\n    pdf_files += files.select { |f| f['name'].end_with?('.pdf') }\n  end\nend TRAPID_BIBLE.md RULE #7.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.2",
    "difficulty": "intermediate",
    "summary": "1. `01 - Plans` 2. `02 - Engineering` 3. `03 - Specifications`",
    "code_example": "# app/services/plan_review_service.rb\nPLAN_FOLDER_PATHS = ['01 - Plans', '02 - Engineering', '03 - Specifications'].freeze\n\ndef fetch_pdf_plans_from_onedrive\n  PLAN_FOLDER_PATHS.each do |folder_name|\n    folder = find_folder_by_name(folder_name)\n    next unless folder\n\n    files = list_files_in_folder(folder['id'])\n    pdf_files += files.select { |f| f['name'].end_with?('.pdf') }\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.2"
  },
  {
    "id": 145,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "PDF File Size Limit",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "PDF File Size Limit integration - Check file size before download - Skip files > 20MB - Return error if NO valid PDFs found after filtering # app/services/plan_review_service.rb\nMAX_FILE_SIZE = 20.megabytes\n\ndef fetch_pdf_plans_from_onedrive\n  pdf_files.each do |file|\n    if file['size'] > MAX_FILE_SIZE\n      Rails.logger.warn \"Skipping #{file['name']} - too large (#{file['size']} bytes)\"\n      next\n    end\n\n    content = download_file(file['id'])\n    valid_pdfs << { name: file['name'], size: file['size'], content: content }\n  end\n\n  raise PDFNotFoundError if valid_pdfs.empty?\nend TRAPID_BIBLE.md RULE #7.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.3",
    "difficulty": "intermediate",
    "summary": "- Check file size before download - Skip files > 20MB - Return error if NO valid PDFs found after filtering",
    "code_example": "# app/services/plan_review_service.rb\nMAX_FILE_SIZE = 20.megabytes\n\ndef fetch_pdf_plans_from_onedrive\n  pdf_files.each do |file|\n    if file['size'] > MAX_FILE_SIZE\n      Rails.logger.warn \"Skipping #{file['name']} - too large (#{file['size']} bytes)\"\n      next\n    end\n\n    content = download_file(file['id'])\n    valid_pdfs << { name: file['name'], size: file['size'], content: content }\n  end\n\n  raise PDFNotFoundError if valid_pdfs.empty?\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.3"
  },
  {
    "id": 146,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Async Processing with Background Jobs",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Async Processing with Background Jobs integration - Return 202 Accepted immediately with review_id - Enqueue AiReviewJob with estimate_id - Set initial status to 'pending', update to 'processing' in job - Frontend MUST poll for status (every 5 second # app/controllers/api/v1/estimate_reviews_controller.rb\ndef create\n  review = EstimateReview.create!(estimate: @estimate, status: :pending)\n  AiReviewJob.perform_later(@estimate.id)\n\n  render json: {\n    success: true,\n    review_id: review.id,\n    status: 'processing',\n    message: 'AI review started. This may take 30-60 seconds.'\n  }, status: :accepted\nend\n\n# ---\n\n// Poll every 5 seconds\nconst pollInterval = setInterval(async () => {\n  const response = await api.get(`/api/v1/estimate_reviews/${reviewId}`)\n  if (response.status === 'completed' || response.status === 'failed') {\n    clearInterval(pollInterval)\n    showResults(response)\n  }\n}, 5000) TRAPID_BIBLE.md RULE #7.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.4",
    "difficulty": "intermediate",
    "summary": "- Return 202 Accepted immediately with review_id - Enqueue AiReviewJob with estimate_id - Set initial status to 'pending', update to 'processing' in job - Frontend MUST poll for status (every 5 second",
    "code_example": "# app/controllers/api/v1/estimate_reviews_controller.rb\ndef create\n  review = EstimateReview.create!(estimate: @estimate, status: :pending)\n  AiReviewJob.perform_later(@estimate.id)\n\n  render json: {\n    success: true,\n    review_id: review.id,\n    status: 'processing',\n    message: 'AI review started. This may take 30-60 seconds.'\n  }, status: :accepted\nend\n\n# ---\n\n// Poll every 5 seconds\nconst pollInterval = setInterval(async () => {\n  const response = await api.get(`/api/v1/estimate_reviews/${reviewId}`)\n  if (response.status === 'completed' || response.status === 'failed') {\n    clearInterval(pollInterval)\n    showResults(response)\n  }\n}, 5000)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.4"
  },
  {
    "id": 147,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Claude API Model and Prompt Structure",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Claude API Model and Prompt Structure integration - Use exact model ID: `claude-3-5-sonnet-20241022` - Send PDFs as base64-encoded documents with MIME type `application/pdf` - Request JSON response format with specific schema - Include estimate line  # app/services/plan_review_service.rb\ndef send_to_claude_api(pdf_data, prompt)\n  client = Anthropic::Client.new(access_token: ENV['ANTHROPIC_API_KEY'])\n\n  content = pdf_data.map do |pdf|\n    {\n      type: 'document',\n      source: {\n        type: 'base64',\n        media_type: 'application/pdf',\n        data: pdf[:base64_content]\n      }\n    }\n  end\n\n  content << { type: 'text', text: prompt }\n\n  response = client.messages.create(\n    model: 'claude-3-5-sonnet-20241022',\n    max_tokens: 4096,\n    messages: [{ role: 'user', content: content }]\n  )\n\n  response.dig('content', 0, 'text')\nend\n\n# ---\n\ndef build_analysis_prompt\n  <<~PROMPT\n    Analyze these construction plan PDFs and extract ALL materials/items mentioned.\n\n    Compare against this estimate:\n    #{JSON.pretty_generate(estimate_line_items)}\n\n    Return ONLY a JSON object with this exact structure:\n    {\n      \"items_identified\": [\n        {\"category\": \"...\", \"item\": \"...\", \"quantity\": 10, \"unit\": \"ea\"}\n      ],\n      \"discrepancies\": [\n        {\n          \"type\": \"quantity_mismatch|missing|extra\",\n          \"severity\": \"high|medium|low\",\n          \"category\": \"...\",\n          \"item\": \"...\",\n          \"plan_quantity\": 10,\n          \"estimate_quantity\": 8,\n          \"recommendation\": \"...\"\n        }\n      ]\n    }\n\n    Severity levels:\n    - HIGH: > 20% quantity difference\n    - MEDIUM: 10-20% difference\n    - LOW: < 10% difference\n  PROMPT\nend TRAPID_BIBLE.md RULE #7.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.5",
    "difficulty": "intermediate",
    "summary": "- Use exact model ID: `claude-3-5-sonnet-20241022` - Send PDFs as base64-encoded documents with MIME type `application/pdf` - Request JSON response format with specific schema - Include estimate line ",
    "code_example": "# app/services/plan_review_service.rb\ndef send_to_claude_api(pdf_data, prompt)\n  client = Anthropic::Client.new(access_token: ENV['ANTHROPIC_API_KEY'])\n\n  content = pdf_data.map do |pdf|\n    {\n      type: 'document',\n      source: {\n        type: 'base64',\n        media_type: 'application/pdf',\n        data: pdf[:base64_content]\n      }\n    }\n  end\n\n  content << { type: 'text', text: prompt }\n\n  response = client.messages.create(\n    model: 'claude-3-5-sonnet-20241022',\n    max_tokens: 4096,\n    messages: [{ role: 'user', content: content }]\n  )\n\n  response.dig('content', 0, 'text')\nend\n\n# ---\n\ndef build_analysis_prompt\n  <<~PROMPT\n    Analyze these construction plan PDFs and extract ALL materials/items mentioned.\n\n    Compare against this estimate:\n    #{JSON.pretty_generate(estimate_line_items)}\n\n    Return ONLY a JSON object with this exact structure:\n    {\n      \"items_identified\": [\n        {\"category\": \"...\", \"item\": \"...\", \"quantity\": 10, \"unit\": \"ea\"}\n      ],\n      \"discrepancies\": [\n        {\n          \"type\": \"quantity_mismatch|missing|extra\",\n          \"severity\": \"high|medium|low\",\n          \"category\": \"...\",\n          \"item\": \"...\",\n          \"plan_quantity\": 10,\n          \"estimate_quantity\": 8,\n          \"recommendation\": \"...\"\n        }\n      ]\n    }\n\n    Severity levels:\n    - HIGH: > 20% quantity difference\n    - MEDIUM: 10-20% difference\n    - LOW: < 10% difference\n  PROMPT\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.5"
  },
  {
    "id": 148,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Discrepancy Detection Logic",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Discrepancy Detection Logic util 1. # app/services/plan_review_service.rb\ndef identify_discrepancies(parsed_analysis)\n  plan_items = parsed_analysis['items_identified'] || []\n  estimate_items = @estimate.estimate_line_items\n\n  matched = []\n  mismatched = []\n  missing = []\n  extra = []\n\n  plan_items.each do |plan_item|\n    est_item = estimate_items.find do |e|\n      fuzzy_match?(e.category, plan_item['category']) &&\n      fuzzy_match?(e.item_description, plan_item['item'])\n    end\n\n    if est_item\n      diff_pct = ((plan_item['quantity'] - est_item.quantity).abs.to_f / plan_item['quantity']) * 100\n\n      if diff_pct <= 10\n        matched << plan_item\n      else\n        severity = diff_pct > 20 ? 'high' : 'medium'\n        mismatched << {\n          type: 'quantity_mismatch',\n          severity: severity,\n          category: plan_item['category'],\n          item: plan_item['item'],\n          plan_quantity: plan_item['quantity'],\n          estimate_quantity: est_item.quantity,\n          difference_percent: diff_pct.round(1),\n          recommendation: \"Verify with plans - estimate may be #{diff_pct > 0 ? 'short' : 'over'} by #{(plan_item['quantity'] - est_item.quantity).abs} units\"\n        }\n      end\n    else\n      missing << {\n        type: 'missing',\n        severity: 'info',\n        category: plan_item['category'],\n        item: plan_item['item'],\n        plan_quantity: plan_item['quantity'],\n        recommendation: 'Item appears in plans but missing from estimate'\n      }\n    end\n  end\n\n  # Find extra items in estimate\n  estimate_items.each do |est_item|\n    unless plan_items.any? { |p| fuzzy_match?(p['item'], est_item.item_description) }\n      extra << {\n        type: 'extra',\n        severity: 'info',\n        estimate_quantity: est_item.quantity,\n        recommendation: 'Item in estimate but not found in plans - verify if needed'\n      }\n    end\n  end\n\n  {\n    matched: matched,\n    mismatched: mismatched,\n    missing: missing,\n    extra: extra\n  }\nend\n\ndef fuzzy_match?(str1, str2)\n  normalize(str1) == normalize(str2)\nend\n\ndef normalize(str)\n  str.to_s.downcase.gsub(/[^a-z0-9]/, '')\nend TRAPID_BIBLE.md RULE #7.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.6",
    "difficulty": "intermediate",
    "summary": "1.",
    "code_example": "# app/services/plan_review_service.rb\ndef identify_discrepancies(parsed_analysis)\n  plan_items = parsed_analysis['items_identified'] || []\n  estimate_items = @estimate.estimate_line_items\n\n  matched = []\n  mismatched = []\n  missing = []\n  extra = []\n\n  plan_items.each do |plan_item|\n    est_item = estimate_items.find do |e|\n      fuzzy_match?(e.category, plan_item['category']) &&\n      fuzzy_match?(e.item_description, plan_item['item'])\n    end\n\n    if est_item\n      diff_pct = ((plan_item['quantity'] - est_item.quantity).abs.to_f / plan_item['quantity']) * 100\n\n      if diff_pct <= 10\n        matched << plan_item\n      else\n        severity = diff_pct > 20 ? 'high' : 'medium'\n        mismatched << {\n          type: 'quantity_mismatch',\n          severity: severity,\n          category: plan_item['category'],\n          item: plan_item['item'],\n          plan_quantity: plan_item['quantity'],\n          estimate_quantity: est_item.quantity,\n          difference_percent: diff_pct.round(1),\n          recommendation: \"Verify with plans - estimate may be #{diff_pct > 0 ? 'short' : 'over'} by #{(plan_item['quantity'] - est_item.quantity).abs} units\"\n        }\n      end\n    else\n      missing << {\n        type: 'missing',\n        severity: 'info',\n        category: plan_item['category'],\n        item: plan_item['item'],\n        plan_quantity: plan_item['quantity'],\n        recommendation: 'Item appears in plans but missing from estimate'\n      }\n    end\n  end\n\n  # Find extra items in estimate\n  estimate_items.each do |est_item|\n    unless plan_items.any? { |p| fuzzy_match?(p['item'], est_item.item_description) }\n      extra << {\n        type: 'extra',\n        severity: 'info',\n        estimate_quantity: est_item.quantity,\n        recommendation: 'Item in estimate but not found in plans - verify if needed'\n      }\n    end\n  end\n\n  {\n    matched: matched,\n    mismatched: mismatched,\n    missing: missing,\n    extra: extra\n  }\nend\n\ndef fuzzy_match?(str1, str2)\n  normalize(str1) == normalize(str2)\nend\n\ndef normalize(str)\n  str.to_s.downcase.gsub(/[^a-z0-9]/, '')\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.6"
  },
  {
    "id": 149,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Confidence Score Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Confidence Score Calculation util ```ruby base_score = (items_matched / total_items) * 100 penalty = (items_mismatched * 5) + (items_missing * 3) + (items_extra * 2) confidence_score = [base_score - penalty, 0].max  # Clamp to 0 minim base_score = (items_matched / total_items) * 100\npenalty = (items_mismatched * 5) + (items_missing * 3) + (items_extra * 2)\nconfidence_score = [base_score - penalty, 0].max  # Clamp to 0 minimum\n\n# ---\n\n# app/services/plan_review_service.rb\ndef calculate_confidence_score(discrepancies)\n  matched = discrepancies[:matched].count\n  mismatched = discrepancies[:mismatched].count\n  missing = discrepancies[:missing].count\n  extra = discrepancies[:extra].count\n\n  total = matched + mismatched + missing\n  return 0 if total.zero?\n\n  base_score = (matched.to_f / total) * 100\n  penalty = (mismatched * 5) + (missing * 3) + (extra * 2)\n\n  [base_score - penalty, 0].max.round(2)\nend TRAPID_BIBLE.md RULE #7.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.7",
    "difficulty": "intermediate",
    "summary": "```ruby base_score = (items_matched / total_items) * 100 penalty = (items_mismatched * 5) + (items_missing * 3) + (items_extra * 2) confidence_score = [base_score - penalty, 0].max  # Clamp to 0 minim",
    "code_example": "base_score = (items_matched / total_items) * 100\npenalty = (items_mismatched * 5) + (items_missing * 3) + (items_extra * 2)\nconfidence_score = [base_score - penalty, 0].max  # Clamp to 0 minimum\n\n# ---\n\n# app/services/plan_review_service.rb\ndef calculate_confidence_score(discrepancies)\n  matched = discrepancies[:matched].count\n  mismatched = discrepancies[:mismatched].count\n  missing = discrepancies[:missing].count\n  extra = discrepancies[:extra].count\n\n  total = matched + mismatched + missing\n  return 0 if total.zero?\n\n  base_score = (matched.to_f / total) * 100\n  penalty = (mismatched * 5) + (missing * 3) + (extra * 2)\n\n  [base_score - penalty, 0].max.round(2)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.7"
  },
  {
    "id": 150,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Error Handling and Status Updates",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Error Handling and Status Updates integration - `NoConstructionError` - Estimate not matched - `OneDriveNotConnectedError` - OneDrive credential missing - `PDFNotFoundError` - No valid PDFs in plan folders - `FileTooLargeError` - All PDFs exceed  review.update!(\n  status: :failed,\n  ai_findings: { error: error_message },\n  reviewed_at: Time.current\n)\n\n# ---\n\n# app/services/plan_review_service.rb\ndef handle_error(message)\n  @review.update!(\n    status: :failed,\n    ai_findings: { error: message },\n    reviewed_at: Time.current\n  )\n\n  { success: false, error: message }\nend\n\n# Usage\nbegin\n  validate_estimate_matched!\n  pdf_files = fetch_pdf_plans_from_onedrive\n  # ... rest of processing\nrescue NoConstructionError => e\n  handle_error(\"Estimate must be matched to a job before AI review\")\nrescue PDFNotFoundError => e\n  handle_error(\"No plan documents found in OneDrive folders: 01-Plans, 02-Engineering, 03-Specifications\")\nrescue Anthropic::Error => e\n  handle_error(\"Claude API error: #{e.message}\")\nrescue StandardError => e\n  Rails.logger.error(\"AI Review failed: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\")\n  handle_error(\"Analysis failed. Please try again or contact support.\")\nend TRAPID_BIBLE.md RULE #7.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.8",
    "difficulty": "intermediate",
    "summary": "- `NoConstructionError` - Estimate not matched - `OneDriveNotConnectedError` - OneDrive credential missing - `PDFNotFoundError` - No valid PDFs in plan folders - `FileTooLargeError` - All PDFs exceed ",
    "code_example": "review.update!(\n  status: :failed,\n  ai_findings: { error: error_message },\n  reviewed_at: Time.current\n)\n\n# ---\n\n# app/services/plan_review_service.rb\ndef handle_error(message)\n  @review.update!(\n    status: :failed,\n    ai_findings: { error: message },\n    reviewed_at: Time.current\n  )\n\n  { success: false, error: message }\nend\n\n# Usage\nbegin\n  validate_estimate_matched!\n  pdf_files = fetch_pdf_plans_from_onedrive\n  # ... rest of processing\nrescue NoConstructionError => e\n  handle_error(\"Estimate must be matched to a job before AI review\")\nrescue PDFNotFoundError => e\n  handle_error(\"No plan documents found in OneDrive folders: 01-Plans, 02-Engineering, 03-Specifications\")\nrescue Anthropic::Error => e\n  handle_error(\"Claude API error: #{e.message}\")\nrescue StandardError => e\n  Rails.logger.error(\"AI Review failed: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\")\n  handle_error(\"Analysis failed. Please try again or contact support.\")\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.8"
  },
  {
    "id": 151,
    "chapter_number": 7,
    "chapter_name": "AI Plan Review",
    "component": null,
    "title": "Prevent Duplicate Processing Reviews",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Prevent Duplicate Processing Reviews integration - Query for existing review with `status: processing` - Return 422 error if found - Allow new review only if previous is completed/failed # app/controllers/api/v1/estimate_reviews_controller.rb\ndef create\n  # Check for existing processing review\n  existing_review = @estimate.estimate_reviews.find_by(status: 'processing')\n\n  if existing_review\n    return render json: {\n      success: false,\n      error: 'AI review already in progress for this estimate'\n    }, status: :unprocessable_entity\n  end\n\n  review = EstimateReview.create!(estimate: @estimate, status: :pending)\n  AiReviewJob.perform_later(@estimate.id)\n\n  render json: { success: true, review_id: review.id, status: 'processing' }, status: :accepted\nend TRAPID_BIBLE.md RULE #7.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "7.9",
    "difficulty": "intermediate",
    "summary": "- Query for existing review with `status: processing` - Return 422 error if found - Allow new review only if previous is completed/failed",
    "code_example": "# app/controllers/api/v1/estimate_reviews_controller.rb\ndef create\n  # Check for existing processing review\n  existing_review = @estimate.estimate_reviews.find_by(status: 'processing')\n\n  if existing_review\n    return render json: {\n      success: false,\n      error: 'AI review already in progress for this estimate'\n    }, status: :unprocessable_entity\n  end\n\n  review = EstimateReview.create!(estimate: @estimate, status: :pending)\n  AiReviewJob.perform_later(@estimate.id)\n\n  render json: { success: true, review_id: review.id, status: 'processing' }, status: :accepted\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #7.9"
  },
  {
    "id": 152,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "PO Number Generation - Race Condition Protection",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "PO Number Generation - Race Condition Protection util ✅ def generate_purchase_order_number\n  ActiveRecord::Base.transaction do\n    ActiveRecord::Base.connection.execute('SELECT pg_advisory_xact_lock(123456789)')\n\n    last_po = PurchaseOrder.order(:purchase_order_number).last\n    next_number = last_po ? last_po.purchase_order_number.gsub(/\\D/, '').to_i + 1 : 1\n    self.purchase_order_number = format('PO-%06d', next_number)\n  end\nend TRAPID_BIBLE.md RULE #8.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.1",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "def generate_purchase_order_number\n  ActiveRecord::Base.transaction do\n    ActiveRecord::Base.connection.execute('SELECT pg_advisory_xact_lock(123456789)')\n\n    last_po = PurchaseOrder.order(:purchase_order_number).last\n    next_number = last_po ? last_po.purchase_order_number.gsub(/\\D/, '').to_i + 1 : 1\n    self.purchase_order_number = format('PO-%06d', next_number)\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.1"
  },
  {
    "id": 153,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Status State Machine",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Status State Machine util ✅ draft → pending → approved → sent → received → invoiced → paid\n  ↘                                                         ↗\n   cancelled (can cancel any non-paid status)\n\n# ---\n\ndef can_edit?         # Only draft/pending\ndef can_approve?      # Only pending\ndef can_cancel?       # Any except paid/cancelled TRAPID_BIBLE.md RULE #8.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.2",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "draft → pending → approved → sent → received → invoiced → paid\n  ↘                                                         ↗\n   cancelled (can cancel any non-paid status)\n\n# ---\n\ndef can_edit?         # Only draft/pending\ndef can_approve?      # Only pending\ndef can_cancel?       # Any except paid/cancelled",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.2"
  },
  {
    "id": 154,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Payment Status Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Status Calculation util ✅ def determine_payment_status(invoice_amount)\n  return :manual_review if total.zero? || invoice_amount > total + 1\n  return :pending if invoice_amount.zero?\n\n  percentage = (invoice_amount / total) * 100\n  return :complete if percentage >= 95 && percentage <= 105\n  return :part_payment\nend TRAPID_BIBLE.md RULE #8.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.3",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "def determine_payment_status(invoice_amount)\n  return :manual_review if total.zero? || invoice_amount > total + 1\n  return :pending if invoice_amount.zero?\n\n  percentage = (invoice_amount / total) * 100\n  return :complete if percentage >= 95 && percentage <= 105\n  return :part_payment\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.3"
  },
  {
    "id": 155,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Line Items - Totals Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Line Items - Totals Calculation util ✅ before_save :calculate_totals\n\ndef calculate_totals\n  self.sub_total = line_items.sum { |li| li.quantity * li.unit_price }\n  self.tax = sub_total * 0.10  # 10% GST\n  self.total = sub_total + tax\nend TRAPID_BIBLE.md RULE #8.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.5",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "before_save :calculate_totals\n\ndef calculate_totals\n  self.sub_total = line_items.sum { |li| li.quantity * li.unit_price }\n  self.tax = sub_total * 0.10  # 10% GST\n  self.total = sub_total + tax\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.5"
  },
  {
    "id": 156,
    "chapter_number": 8,
    "chapter_name": "Purchase Orders",
    "component": null,
    "title": "Schedule Task Linking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Schedule Task Linking util ✅ ActiveRecord::Base.transaction do\n  # Unlink old task\n  if old_task = purchase_order.schedule_task\n    old_task.update!(purchase_order_id: nil)\n  end\n\n  # Link new task\n  if new_task_id.present?\n    new_task = ScheduleTask.find(new_task_id)\n    new_task.update!(purchase_order_id: purchase_order.id)\n  end\nend TRAPID_BIBLE.md RULE #8.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "8.6",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "ActiveRecord::Base.transaction do\n  # Unlink old task\n  if old_task = purchase_order.schedule_task\n    old_task.update!(purchase_order_id: nil)\n  end\n\n  # Link new task\n  if new_task_id.present?\n    new_task = ScheduleTask.find(new_task_id)\n    new_task.update!(purchase_order_id: purchase_order.id)\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #8.6"
  },
  {
    "id": 160,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "Company Settings - Working Days & Timezone",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Company Settings - Working Days & Timezone component ✅ def working_day?(date)\n  # CRITICAL: Use company timezone, not server timezone (UTC)\n  timezone = @company_settings.timezone || 'UTC'\n  date_in_company_tz = date.in_time_zone(timezone)\n\n  working_days = @company_settings.working_days || default_config\n  day_name = date_in_company_tz.strftime('%A').downcase\n  working_days[day_name] == true\nend\n\n# ---\n\n# ❌ WRONG - uses server timezone\nreference_date = Date.today  # Could be Saturday in UTC, Sunday in AU\nreference_date = Date.current  # Still uses server timezone!\n\n# ✅ CORRECT - uses company timezone\nreference_date = CompanySetting.today  # Preferred method\n# OR\ntimezone = CompanySetting.instance.timezone || 'UTC'\nreference_date = Time.now.in_time_zone(timezone).to_date\n\n# ---\n\n// ❌ WRONG - toLocaleString creates wrong Date object in browser timezone\nconst dateInTZ = new Date(now.toLocaleString('en-US', { timeZone: companyTimezone }))\n\n// ✅ CORRECT - Use Intl.DateTimeFormat and parse parts\nconst formatter = new Intl.DateTimeFormat('en-CA', {\n  timeZone: companyTimezone,\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit'\n})\nconst parts = formatter.formatToParts(now)\nconst year = parts.find(p => p.type === 'year').value\nconst month = parts.find(p => p.type === 'month').value\nconst day = parts.find(p => p.type === 'day').value\nconst dateInTZ = new Date(`${year}-${month}-${day}T00:00:00`) TRAPID_BIBLE.md RULE #9.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.3",
    "difficulty": "advanced",
    "summary": "✅",
    "code_example": "def working_day?(date)\n  # CRITICAL: Use company timezone, not server timezone (UTC)\n  timezone = @company_settings.timezone || 'UTC'\n  date_in_company_tz = date.in_time_zone(timezone)\n\n  working_days = @company_settings.working_days || default_config\n  day_name = date_in_company_tz.strftime('%A').downcase\n  working_days[day_name] == true\nend\n\n# ---\n\n# ❌ WRONG - uses server timezone\nreference_date = Date.today  # Could be Saturday in UTC, Sunday in AU\nreference_date = Date.current  # Still uses server timezone!\n\n# ✅ CORRECT - uses company timezone\nreference_date = CompanySetting.today  # Preferred method\n# OR\ntimezone = CompanySetting.instance.timezone || 'UTC'\nreference_date = Time.now.in_time_zone(timezone).to_date\n\n# ---\n\n// ❌ WRONG - toLocaleString creates wrong Date object in browser timezone\nconst dateInTZ = new Date(now.toLocaleString('en-US', { timeZone: companyTimezone }))\n\n// ✅ CORRECT - Use Intl.DateTimeFormat and parse parts\nconst formatter = new Intl.DateTimeFormat('en-CA', {\n  timeZone: companyTimezone,\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit'\n})\nconst parts = formatter.formatToParts(now)\nconst year = parts.find(p => p.type === 'year').value\nconst month = parts.find(p => p.type === 'month').value\nconst day = parts.find(p => p.type === 'day').value\nconst dateInTZ = new Date(`${year}-${month}-${day}T00:00:00`)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.3"
  },
  {
    "id": 161,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "Task Heights Configuration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Heights Configuration util ✅ gantt.config.row_height = 40\ngantt.config.task_height = 40  // MUST match row_height\ngantt.config.bar_height = 40   // MUST also match TRAPID_BIBLE.md RULE #9.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.5",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "gantt.config.row_height = 40\ngantt.config.task_height = 40  // MUST match row_height\ngantt.config.bar_height = 40   // MUST also match",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.5"
  },
  {
    "id": 162,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "API Pattern - Single Update + Cascade Response",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "API Pattern - Single Update + Cascade Response integration ✅ // Send ONE update:\nPATCH /api/v1/schedule_templates/:id/rows/:row_id\n{\n  schedule_template_row: {\n    start_date: 5,\n    duration: 3\n  }\n}\n\n// Backend returns updated task + ALL cascaded tasks:\n{\n  task: { id: 1, start_date: 5, duration: 3, ... },\n  cascaded_tasks: [\n    { id: 2, start_date: 8, ... },\n    { id: 3, start_date: 10, ... }\n  ]\n} TRAPID_BIBLE.md RULE #9.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.7",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "// Send ONE update:\nPATCH /api/v1/schedule_templates/:id/rows/:row_id\n{\n  schedule_template_row: {\n    start_date: 5,\n    duration: 3\n  }\n}\n\n// Backend returns updated task + ALL cascaded tasks:\n{\n  task: { id: 1, start_date: 5, duration: 3, ... },\n  cascaded_tasks: [\n    { id: 2, start_date: 8, ... },\n    { id: 3, start_date: 10, ... }\n  ]\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.7"
  },
  {
    "id": 163,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "Predecessor Format",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Predecessor Format util ✅ {\n  schedule_template_row: {\n    start_date: 5,\n    duration: 3,\n    predecessor_ids: [\n      { id: 1, type: \"FS\", lag: 0 },\n      { id: 2, type: \"SS\", lag: 3 }\n    ]  // MUST include this field\n  }\n} TRAPID_BIBLE.md RULE #9.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.9",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "{\n  schedule_template_row: {\n    start_date: 5,\n    duration: 3,\n    predecessor_ids: [\n      { id: 1, type: \"FS\", lag: 0 },\n      { id: 2, type: \"SS\", lag: 3 }\n    ]  // MUST include this field\n  }\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.9"
  },
  {
    "id": 164,
    "chapter_number": 9,
    "chapter_name": "Gantt & Schedule Master",
    "component": null,
    "title": "Debounced Render Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Debounced Render Pattern util ✅ const debouncedRender = (delay = 0) => {\n  if (renderTimeout.current) {\n    clearTimeout(renderTimeout.current)\n  }\n  renderTimeout.current = setTimeout(() => {\n    if (ganttReady) gantt.render()\n  }, delay)\n} TRAPID_BIBLE.md RULE #9.11",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "9.11",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "const debouncedRender = (delay = 0) => {\n  if (renderTimeout.current) {\n    clearTimeout(renderTimeout.current)\n  }\n  renderTimeout.current = setTimeout(() => {\n    if (ganttReady) gantt.render()\n  }, delay)\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #9.11"
  },
  {
    "id": 165,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Task Status Lifecycle & Automatic Date Updates",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Status Lifecycle & Automatic Date Updates util  # app/models/project_task.rb\nenum status: {\n  not_started: 0,\n  in_progress: 1,\n  complete: 2,\n  on_hold: 3\n}\n\n# Valid transitions:\n# not_started → in_progress → complete\n# any status → on_hold → previous status\n\n# ---\n\n# When status changes to in_progress\nbefore_save :set_actual_start_date, if: -> { status_changed? && in_progress? }\n\ndef set_actual_start_date\n  self.actual_start_date ||= Date.today\nend\n\n# When status changes to complete\nbefore_save :set_completion_data, if: -> { status_changed? && complete? }\n\ndef set_completion_data\n  self.actual_end_date ||= Date.today\n  self.progress_percentage = 100\nend TRAPID_BIBLE.md RULE #10.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/project_task.rb\nenum status: {\n  not_started: 0,\n  in_progress: 1,\n  complete: 2,\n  on_hold: 3\n}\n\n# Valid transitions:\n# not_started → in_progress → complete\n# any status → on_hold → previous status\n\n# ---\n\n# When status changes to in_progress\nbefore_save :set_actual_start_date, if: -> { status_changed? && in_progress? }\n\ndef set_actual_start_date\n  self.actual_start_date ||= Date.today\nend\n\n# When status changes to complete\nbefore_save :set_completion_data, if: -> { status_changed? && complete? }\n\ndef set_completion_data\n  self.actual_end_date ||= Date.today\n  self.progress_percentage = 100\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.1"
  },
  {
    "id": 170,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Auto-Complete Predecessors Feature",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Auto-Complete Predecessors Feature component  # app/models/project_task.rb\nafter_save :complete_predecessors, if: -> {\n  auto_complete_predecessors? &&\n  complete? &&\n  saved_change_to_status?\n}\n\ndef complete_predecessors\n  predecessor_tasks = TaskDependency\n    .where(successor_task_id: id)\n    .includes(:predecessor_task)\n    .map(&:predecessor_task)\n\n  predecessor_tasks.each do |task|\n    next if task.complete?\n\n    task.update!(\n      status: :complete,\n      actual_end_date: Date.today,\n      progress_percentage: 100,\n      completion_notes: \"Auto-completed by successor task: #{name}\"\n    )\n  end\nend\n\n# ---\n\n// TaskEditModal.jsx\n<label className=\"flex items-center gap-2\">\n  <input\n    type=\"checkbox\"\n    checked={task.auto_complete_predecessors || false}\n    onChange={(e) => setTask({\n      ...task,\n      auto_complete_predecessors: e.target.checked\n    })}\n  />\n  <span>Auto-complete predecessor tasks when this task completes</span>\n  <Tooltip>\n    If enabled, marking this task complete will automatically complete\n    all tasks it depends on (proving they're done).\n  </Tooltip>\n</label> TRAPID_BIBLE.md RULE #10.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/project_task.rb\nafter_save :complete_predecessors, if: -> {\n  auto_complete_predecessors? &&\n  complete? &&\n  saved_change_to_status?\n}\n\ndef complete_predecessors\n  predecessor_tasks = TaskDependency\n    .where(successor_task_id: id)\n    .includes(:predecessor_task)\n    .map(&:predecessor_task)\n\n  predecessor_tasks.each do |task|\n    next if task.complete?\n\n    task.update!(\n      status: :complete,\n      actual_end_date: Date.today,\n      progress_percentage: 100,\n      completion_notes: \"Auto-completed by successor task: #{name}\"\n    )\n  end\nend\n\n# ---\n\n// TaskEditModal.jsx\n<label className=\"flex items-center gap-2\">\n  <input\n    type=\"checkbox\"\n    checked={task.auto_complete_predecessors || false}\n    onChange={(e) => setTask({\n      ...task,\n      auto_complete_predecessors: e.target.checked\n    })}\n  />\n  <span>Auto-complete predecessor tasks when this task completes</span>\n  <Tooltip>\n    If enabled, marking this task complete will automatically complete\n    all tasks it depends on (proving they're done).\n  </Tooltip>\n</label>",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.6"
  },
  {
    "id": 166,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Task Dependencies & Circular Dependency Prevention",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Dependencies & Circular Dependency Prevention util  # app/models/task_dependency.rb\nenum dependency_type: {\n  finish_to_start: 0,   # Most common: B starts after A finishes\n  start_to_start: 1,    # B starts when A starts\n  finish_to_finish: 2,  # B finishes when A finishes\n  start_to_finish: 3    # Rare: B finishes when A starts\n}\n\n# ---\n\n# app/models/task_dependency.rb\nvalidates :predecessor_task_id, uniqueness: { scope: :successor_task_id }\nvalidates :dependency_type, presence: true\nvalidate :no_circular_dependencies\nvalidate :same_project\n\ndef no_circular_dependencies\n  # Check if predecessor has successor in its dependency chain\n  visited = Set.new\n  check_circular(successor_task, visited)\nend\n\ndef same_project\n  unless predecessor_task.project_id == successor_task.project_id\n    errors.add(:base, \"Tasks must be in same project\")\n  end\nend TRAPID_BIBLE.md RULE #10.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/task_dependency.rb\nenum dependency_type: {\n  finish_to_start: 0,   # Most common: B starts after A finishes\n  start_to_start: 1,    # B starts when A starts\n  finish_to_finish: 2,  # B finishes when A finishes\n  start_to_finish: 3    # Rare: B finishes when A starts\n}\n\n# ---\n\n# app/models/task_dependency.rb\nvalidates :predecessor_task_id, uniqueness: { scope: :successor_task_id }\nvalidates :dependency_type, presence: true\nvalidate :no_circular_dependencies\nvalidate :same_project\n\ndef no_circular_dependencies\n  # Check if predecessor has successor in its dependency chain\n  visited = Set.new\n  check_circular(successor_task, visited)\nend\n\ndef same_project\n  unless predecessor_task.project_id == successor_task.project_id\n    errors.add(:base, \"Tasks must be in same project\")\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.2"
  },
  {
    "id": 167,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Automatic Task Spawning from Templates",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Automatic Task Spawning from Templates component  # app/models/project_task.rb\nenum spawned_type: {\n  photo: 1,\n  certificate: 2,\n  subtask: 3\n}\n\n# spawned_type: nil = normal task (not spawned)\n\n# ---\n\n# app/services/schedule/task_spawner.rb\n\n# Photo Task: Spawned when parent completes, if require_photo: true\ndef spawn_photo_task(parent_task)\n  return unless parent_task.schedule_template_row&.require_photo\n\n  ProjectTask.create!(\n    project: parent_task.project,\n    name: \"📸 Photo - #{parent_task.name}\",\n    spawned_type: :photo,\n    parent_task: parent_task,\n    planned_start_date: parent_task.actual_end_date,\n    duration_days: 1,\n    status: :not_started\n  )\nend\n\n# Certificate Task: Spawned when parent completes, if require_certificate: true\ndef spawn_certificate_task(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.require_certificate\n\n  lag_days = row.certificate_lag_days || 0\n\n  ProjectTask.create!(\n    project: parent_task.project,\n    name: \"📜 Certificate - #{parent_task.name}\",\n    spawned_type: :certificate,\n    parent_task: parent_task,\n    planned_start_date: parent_task.actual_end_date + lag_days.days,\n    duration_days: row.certificate_duration_days || 3,\n    status: :not_started\n  )\nend\n\n# Subtasks: Spawned when parent starts, if has_subtasks: true\ndef spawn_subtasks(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.has_subtasks\n\n  row.subtask_templates.each_with_index do |template, index|\n    ProjectTask.create!(\n      project: parent_task.project,\n      name: template.name,\n      spawned_type: :subtask,\n      parent_task: parent_task,\n      sequence_order: parent_task.sequence_order + (index + 1) * 0.1,\n      planned_start_date: parent_task.planned_start_date,\n      duration_days: template.duration_days,\n      status: :not_started\n    )\n  end\nend\n\n# ---\n\n# app/models/project_task.rb\nafter_save :spawn_child_tasks, if: :status_changed?\n\ndef spawn_child_tasks\n  if complete? && saved_change_to_status?\n    Schedule::TaskSpawner.new.spawn_photo_task(self)\n    Schedule::TaskSpawner.new.spawn_certificate_task(self)\n  end\n\n  if in_progress? && saved_change_to_status?\n    Schedule::TaskSpawner.new.spawn_subtasks(self)\n  end\nend TRAPID_BIBLE.md RULE #10.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/project_task.rb\nenum spawned_type: {\n  photo: 1,\n  certificate: 2,\n  subtask: 3\n}\n\n# spawned_type: nil = normal task (not spawned)\n\n# ---\n\n# app/services/schedule/task_spawner.rb\n\n# Photo Task: Spawned when parent completes, if require_photo: true\ndef spawn_photo_task(parent_task)\n  return unless parent_task.schedule_template_row&.require_photo\n\n  ProjectTask.create!(\n    project: parent_task.project,\n    name: \"📸 Photo - #{parent_task.name}\",\n    spawned_type: :photo,\n    parent_task: parent_task,\n    planned_start_date: parent_task.actual_end_date,\n    duration_days: 1,\n    status: :not_started\n  )\nend\n\n# Certificate Task: Spawned when parent completes, if require_certificate: true\ndef spawn_certificate_task(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.require_certificate\n\n  lag_days = row.certificate_lag_days || 0\n\n  ProjectTask.create!(\n    project: parent_task.project,\n    name: \"📜 Certificate - #{parent_task.name}\",\n    spawned_type: :certificate,\n    parent_task: parent_task,\n    planned_start_date: parent_task.actual_end_date + lag_days.days,\n    duration_days: row.certificate_duration_days || 3,\n    status: :not_started\n  )\nend\n\n# Subtasks: Spawned when parent starts, if has_subtasks: true\ndef spawn_subtasks(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.has_subtasks\n\n  row.subtask_templates.each_with_index do |template, index|\n    ProjectTask.create!(\n      project: parent_task.project,\n      name: template.name,\n      spawned_type: :subtask,\n      parent_task: parent_task,\n      sequence_order: parent_task.sequence_order + (index + 1) * 0.1,\n      planned_start_date: parent_task.planned_start_date,\n      duration_days: template.duration_days,\n      status: :not_started\n    )\n  end\nend\n\n# ---\n\n# app/models/project_task.rb\nafter_save :spawn_child_tasks, if: :status_changed?\n\ndef spawn_child_tasks\n  if complete? && saved_change_to_status?\n    Schedule::TaskSpawner.new.spawn_photo_task(self)\n    Schedule::TaskSpawner.new.spawn_certificate_task(self)\n  end\n\n  if in_progress? && saved_change_to_status?\n    Schedule::TaskSpawner.new.spawn_subtasks(self)\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.3"
  },
  {
    "id": 168,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Supervisor Checklist Template-to-Instance Flow",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Supervisor Checklist Template-to-Instance Flow util  # app/models/supervisor_checklist_template.rb\nclass SupervisorChecklistTemplate < ApplicationRecord\n  validates :name, presence: true\n  validates :category, inclusion: {\n    in: %w[Safety Quality Pre-Start Completion Documentation]\n  }\n  validates :response_type, inclusion: {\n    in: %w[checkbox photo note photo_and_note]\n  }\n\n  has_many :schedule_template_row_checklists\n  has_many :schedule_template_rows, through: :schedule_template_row_checklists\nend\n\n# ---\n\n# app/services/schedule/template_instantiator.rb\ndef create_checklist_items_for_task(project_task)\n  row = project_task.schedule_template_row\n  return unless row\n\n  row.supervisor_checklist_templates.each do |template|\n    ProjectTaskChecklistItem.create!(\n      project_task: project_task,\n      name: template.name,\n      description: template.description,\n      category: template.category,\n      response_type: template.response_type,\n      sequence_order: template.sequence_order,\n      is_completed: false\n    )\n  end\nend\n\n# ---\n\n# app/models/project_task_checklist_item.rb\nvalidates :name, presence: true\nvalidates :response_type, inclusion: {\n  in: %w[checkbox photo note photo_and_note]\n}\n\n# Completion tracking\nattribute :is_completed, :boolean, default: false\nattribute :completed_at, :datetime\nattribute :completed_by, :string  # Username, not FK\n\n# Response data\nattribute :response_note, :text\nattribute :response_photo_url, :string TRAPID_BIBLE.md RULE #10.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/supervisor_checklist_template.rb\nclass SupervisorChecklistTemplate < ApplicationRecord\n  validates :name, presence: true\n  validates :category, inclusion: {\n    in: %w[Safety Quality Pre-Start Completion Documentation]\n  }\n  validates :response_type, inclusion: {\n    in: %w[checkbox photo note photo_and_note]\n  }\n\n  has_many :schedule_template_row_checklists\n  has_many :schedule_template_rows, through: :schedule_template_row_checklists\nend\n\n# ---\n\n# app/services/schedule/template_instantiator.rb\ndef create_checklist_items_for_task(project_task)\n  row = project_task.schedule_template_row\n  return unless row\n\n  row.supervisor_checklist_templates.each do |template|\n    ProjectTaskChecklistItem.create!(\n      project_task: project_task,\n      name: template.name,\n      description: template.description,\n      category: template.category,\n      response_type: template.response_type,\n      sequence_order: template.sequence_order,\n      is_completed: false\n    )\n  end\nend\n\n# ---\n\n# app/models/project_task_checklist_item.rb\nvalidates :name, presence: true\nvalidates :response_type, inclusion: {\n  in: %w[checkbox photo note photo_and_note]\n}\n\n# Completion tracking\nattribute :is_completed, :boolean, default: false\nattribute :completed_at, :datetime\nattribute :completed_by, :string  # Username, not FK\n\n# Response data\nattribute :response_note, :text\nattribute :response_photo_url, :string",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.4"
  },
  {
    "id": 169,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Response Type Validation & Photo Upload",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Response Type Validation & Photo Upload component  # Valid response types:\n# - checkbox: Simple completion toggle\n# - photo: Requires photo upload\n# - note: Requires text response\n# - photo_and_note: Requires both photo AND note\n\n# ---\n\n# app/models/project_task_checklist_item.rb\nvalidate :response_data_present, if: :is_completed?\n\ndef response_data_present\n  case response_type\n  when 'checkbox'\n    # No additional data required\n  when 'photo'\n    errors.add(:response_photo_url, \"required\") if response_photo_url.blank?\n  when 'note'\n    errors.add(:response_note, \"required\") if response_note.blank?\n  when 'photo_and_note'\n    errors.add(:response_photo_url, \"required\") if response_photo_url.blank?\n    errors.add(:response_note, \"required\") if response_note.blank?\n  end\nend\n\n# ---\n\n# Frontend component: SupervisorChecklistItemRow.jsx\nconst uploadPhoto = async (file) => {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('upload_preset', 'supervisor_checklist'); // Cloudinary preset\n  formData.append('folder', `jobs/${jobId}/checklists`);\n\n  const response = await fetch(\n    `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,\n    { method: 'POST', body: formData }\n  );\n\n  const data = await response.json();\n  return data.secure_url; // Store this in response_photo_url\n}; TRAPID_BIBLE.md RULE #10.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.5",
    "difficulty": "beginner",
    "summary": "",
    "code_example": "# Valid response types:\n# - checkbox: Simple completion toggle\n# - photo: Requires photo upload\n# - note: Requires text response\n# - photo_and_note: Requires both photo AND note\n\n# ---\n\n# app/models/project_task_checklist_item.rb\nvalidate :response_data_present, if: :is_completed?\n\ndef response_data_present\n  case response_type\n  when 'checkbox'\n    # No additional data required\n  when 'photo'\n    errors.add(:response_photo_url, \"required\") if response_photo_url.blank?\n  when 'note'\n    errors.add(:response_note, \"required\") if response_note.blank?\n  when 'photo_and_note'\n    errors.add(:response_photo_url, \"required\") if response_photo_url.blank?\n    errors.add(:response_note, \"required\") if response_note.blank?\n  end\nend\n\n# ---\n\n# Frontend component: SupervisorChecklistItemRow.jsx\nconst uploadPhoto = async (file) => {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('upload_preset', 'supervisor_checklist'); // Cloudinary preset\n  formData.append('folder', `jobs/${jobId}/checklists`);\n\n  const response = await fetch(\n    `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,\n    { method: 'POST', body: formData }\n  );\n\n  const data = await response.json();\n  return data.secure_url; // Store this in response_photo_url\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.5"
  },
  {
    "id": 171,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Materials Status Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Materials Status Calculation integration  # app/models/project_task.rb\ndef materials_status\n  return 'no_po' unless purchase_order\n\n  delivery_date = purchase_order.estimated_delivery_date\n  return 'no_po' unless delivery_date\n\n  if delivery_date <= planned_start_date\n    'on_time'\n  else\n    'delayed'\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/project_tasks_controller.rb\ndef show\n  task = ProjectTask.find(params[:id])\n\n  render json: {\n    id: task.id,\n    name: task.name,\n    status: task.status,\n    planned_start_date: task.planned_start_date,\n    purchase_order_id: task.purchase_order_id,\n    materials_status: task.materials_status, # ← Include calculated field\n    # ... other fields\n  }\nend\n\n# ---\n\n// TaskRow.jsx\nconst MaterialsBadge = ({ status }) => {\n  const badges = {\n    no_po: { text: 'No PO', color: 'gray' },\n    on_time: { text: 'Materials On Time', color: 'green' },\n    delayed: { text: 'Materials Delayed', color: 'red' }\n  };\n\n  const { text, color } = badges[status];\n\n  return (\n    <span className={`badge badge-${color}`}>\n      {text}\n    </span>\n  );\n}; TRAPID_BIBLE.md RULE #10.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/project_task.rb\ndef materials_status\n  return 'no_po' unless purchase_order\n\n  delivery_date = purchase_order.estimated_delivery_date\n  return 'no_po' unless delivery_date\n\n  if delivery_date <= planned_start_date\n    'on_time'\n  else\n    'delayed'\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/project_tasks_controller.rb\ndef show\n  task = ProjectTask.find(params[:id])\n\n  render json: {\n    id: task.id,\n    name: task.name,\n    status: task.status,\n    planned_start_date: task.planned_start_date,\n    purchase_order_id: task.purchase_order_id,\n    materials_status: task.materials_status, # ← Include calculated field\n    # ... other fields\n  }\nend\n\n# ---\n\n// TaskRow.jsx\nconst MaterialsBadge = ({ status }) => {\n  const badges = {\n    no_po: { text: 'No PO', color: 'gray' },\n    on_time: { text: 'Materials On Time', color: 'green' },\n    delayed: { text: 'Materials Delayed', color: 'red' }\n  };\n\n  const { text, color } = badges[status];\n\n  return (\n    <span className={`badge badge-${color}`}>\n      {text}\n    </span>\n  );\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.7"
  },
  {
    "id": 172,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Sequence Order for Task Display",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Sequence Order for Task Display feature  # Normal tasks: Integer sequence (1, 2, 3, ...)\n# Spawned subtasks: Parent + 0.1 increments (2.1, 2.2, 2.3, ...)\n\n# Example:\n# 1.0 - Foundation\n# 2.0 - Framing\n#   2.1 - 📸 Photo - Framing  (spawned)\n#   2.2 - 📜 Certificate - Framing Structure (spawned)\n# 3.0 - Roofing\n#   3.1 - Install trusses (subtask)\n#   3.2 - Install sheets (subtask)\n#   3.3 - Install gutters (subtask)\n# 4.0 - Electrical\n\n# ---\n\n# app/services/schedule/task_spawner.rb\ndef spawn_subtasks(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.has_subtasks\n\n  row.subtask_templates.each_with_index do |template, index|\n    ProjectTask.create!(\n      # ... other fields\n      sequence_order: parent_task.sequence_order + (index + 1) * 0.1,\n      parent_task: parent_task\n    )\n  end\nend\n\n# For new top-level tasks:\ndef next_sequence_order(project)\n  max = project.tasks.maximum(:sequence_order) || 0\n  max.ceil + 1.0  # Always round up to next integer\nend\n\n# ---\n\n# db/migrate/..._add_sequence_order_to_project_tasks.rb\nadd_column :project_tasks, :sequence_order, :decimal, precision: 10, scale: 2\nadd_index :project_tasks, [:project_id, :sequence_order] TRAPID_BIBLE.md RULE #10.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# Normal tasks: Integer sequence (1, 2, 3, ...)\n# Spawned subtasks: Parent + 0.1 increments (2.1, 2.2, 2.3, ...)\n\n# Example:\n# 1.0 - Foundation\n# 2.0 - Framing\n#   2.1 - 📸 Photo - Framing  (spawned)\n#   2.2 - 📜 Certificate - Framing Structure (spawned)\n# 3.0 - Roofing\n#   3.1 - Install trusses (subtask)\n#   3.2 - Install sheets (subtask)\n#   3.3 - Install gutters (subtask)\n# 4.0 - Electrical\n\n# ---\n\n# app/services/schedule/task_spawner.rb\ndef spawn_subtasks(parent_task)\n  row = parent_task.schedule_template_row\n  return unless row&.has_subtasks\n\n  row.subtask_templates.each_with_index do |template, index|\n    ProjectTask.create!(\n      # ... other fields\n      sequence_order: parent_task.sequence_order + (index + 1) * 0.1,\n      parent_task: parent_task\n    )\n  end\nend\n\n# For new top-level tasks:\ndef next_sequence_order(project)\n  max = project.tasks.maximum(:sequence_order) || 0\n  max.ceil + 1.0  # Always round up to next integer\nend\n\n# ---\n\n# db/migrate/..._add_sequence_order_to_project_tasks.rb\nadd_column :project_tasks, :sequence_order, :decimal, precision: 10, scale: 2\nadd_index :project_tasks, [:project_id, :sequence_order]",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.8"
  },
  {
    "id": 173,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Task Update Audit Trail",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Task Update Audit Trail integration Task Update Audit Trail # app/models/task_update.rb (DOES NOT EXIST YET)\nclass TaskUpdate < ApplicationRecord\n  belongs_to :project_task\n  belongs_to :user, optional: true\n\n  validates :update_type, inclusion: {\n    in: %w[status_change progress_update note_added assignment_changed]\n  }\n  validates :old_value, presence: true, if: -> { update_type.ends_with?('_change') }\n  validates :new_value, presence: true\nend\n\n# Intended usage:\n# app/models/project_task.rb\nafter_save :log_status_change, if: :saved_change_to_status?\n\ndef log_status_change\n  TaskUpdate.create!(\n    project_task: self,\n    user: Current.user,\n    update_type: 'status_change',\n    old_value: saved_change_to_status[0],\n    new_value: saved_change_to_status[1],\n    timestamp: Time.current\n  )\nend TRAPID_BIBLE.md RULE #10.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.9",
    "difficulty": "intermediate",
    "summary": "Task Update Audit Trail",
    "code_example": "# app/models/task_update.rb (DOES NOT EXIST YET)\nclass TaskUpdate < ApplicationRecord\n  belongs_to :project_task\n  belongs_to :user, optional: true\n\n  validates :update_type, inclusion: {\n    in: %w[status_change progress_update note_added assignment_changed]\n  }\n  validates :old_value, presence: true, if: -> { update_type.ends_with?('_change') }\n  validates :new_value, presence: true\nend\n\n# Intended usage:\n# app/models/project_task.rb\nafter_save :log_status_change, if: :saved_change_to_status?\n\ndef log_status_change\n  TaskUpdate.create!(\n    project_task: self,\n    user: Current.user,\n    update_type: 'status_change',\n    old_value: saved_change_to_status[0],\n    new_value: saved_change_to_status[1],\n    timestamp: Time.current\n  )\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.9"
  },
  {
    "id": 174,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Duration Days Validation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Duration Days Validation util  # app/models/project_task.rb\nvalidates :duration_days, presence: true, numericality: {\n  greater_than_or_equal_to: 1,\n  only_integer: true\n}\n\n# ---\n\n# Planned end date calculation\ndef planned_end_date\n  return nil unless planned_start_date && duration_days\n\n  planned_start_date + (duration_days - 1).days\nend\n\n# Example:\n# Start: Jan 1, Duration: 1 day → End: Jan 1 (same day)\n# Start: Jan 1, Duration: 3 days → End: Jan 3 TRAPID_BIBLE.md RULE #10.10",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.10",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/project_task.rb\nvalidates :duration_days, presence: true, numericality: {\n  greater_than_or_equal_to: 1,\n  only_integer: true\n}\n\n# ---\n\n# Planned end date calculation\ndef planned_end_date\n  return nil unless planned_start_date && duration_days\n\n  planned_start_date + (duration_days - 1).days\nend\n\n# Example:\n# Start: Jan 1, Duration: 1 day → End: Jan 1 (same day)\n# Start: Jan 1, Duration: 3 days → End: Jan 3",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.10"
  },
  {
    "id": 194,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "SMS Status Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "SMS Status Tracking component  # app/models/sms_message.rb\nclass SmsMessage < ApplicationRecord\n  belongs_to :contact\n  belongs_to :user, optional: true # null for inbound messages\n\n  validates :from_phone, :to_phone, :body, :direction, presence: true\n  validates :direction, inclusion: { in: %w[inbound outbound] }\n\n  scope :inbound, -> { where(direction: 'inbound') }\n  scope :outbound, -> { where(direction: 'outbound') }\n  scope :recent, -> { order(created_at: :desc) }\n\n  # Status helpers\n  def delivered?\n    status == 'delivered'\n  end\n\n  def failed?\n    status == 'failed'\n  end\n\n  def inbound?\n    direction == 'inbound'\n  end\n\n  def outbound?\n    direction == 'outbound'\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/sms_messages_controller.rb\ndef status_webhook\n  message_sid = params['MessageSid']\n  status = params['MessageStatus'] # queued, sent, delivered, failed\n\n  TwilioService.update_message_status(message_sid, status)\n\n  head :ok\nend\n\n# app/services/twilio_service.rb\ndef self.update_message_status(message_sid, status)\n  sms = SmsMessage.find_by(twilio_sid: message_sid)\n  return unless sms\n\n  sms.update!(status: status)\nend\n\n# ---\n\n// frontend/src/components/contacts/SmsConversation.jsx\nconst getStatusIcon = (message) => {\n  if (message.direction === 'inbound') return null;\n\n  switch (message.status) {\n    case 'delivered': return <CheckIcon className=\"text-green-500\" />;\n    case 'sent': return <CheckIcon className=\"text-blue-500\" />;\n    case 'failed': return <XMarkIcon className=\"text-red-500\" />;\n    case 'queued': return <ClockIcon className=\"text-gray-400\" />;\n    default: return null;\n  }\n}; TRAPID_BIBLE.md RULE #14.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/sms_message.rb\nclass SmsMessage < ApplicationRecord\n  belongs_to :contact\n  belongs_to :user, optional: true # null for inbound messages\n\n  validates :from_phone, :to_phone, :body, :direction, presence: true\n  validates :direction, inclusion: { in: %w[inbound outbound] }\n\n  scope :inbound, -> { where(direction: 'inbound') }\n  scope :outbound, -> { where(direction: 'outbound') }\n  scope :recent, -> { order(created_at: :desc) }\n\n  # Status helpers\n  def delivered?\n    status == 'delivered'\n  end\n\n  def failed?\n    status == 'failed'\n  end\n\n  def inbound?\n    direction == 'inbound'\n  end\n\n  def outbound?\n    direction == 'outbound'\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/sms_messages_controller.rb\ndef status_webhook\n  message_sid = params['MessageSid']\n  status = params['MessageStatus'] # queued, sent, delivered, failed\n\n  TwilioService.update_message_status(message_sid, status)\n\n  head :ok\nend\n\n# app/services/twilio_service.rb\ndef self.update_message_status(message_sid, status)\n  sms = SmsMessage.find_by(twilio_sid: message_sid)\n  return unless sms\n\n  sms.update!(status: status)\nend\n\n# ---\n\n// frontend/src/components/contacts/SmsConversation.jsx\nconst getStatusIcon = (message) => {\n  if (message.direction === 'inbound') return null;\n\n  switch (message.status) {\n    case 'delivered': return <CheckIcon className=\"text-green-500\" />;\n    case 'sent': return <CheckIcon className=\"text-blue-500\" />;\n    case 'failed': return <XMarkIcon className=\"text-red-500\" />;\n    case 'queued': return <ClockIcon className=\"text-gray-400\" />;\n    default: return null;\n  }\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.4"
  },
  {
    "id": 175,
    "chapter_number": 10,
    "chapter_name": "Project Tasks & Checklists",
    "component": null,
    "title": "Tags System for Flexible Categorization",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Tags System for Flexible Categorization integration  # db/migrate/..._add_tags_to_project_tasks.rb\nadd_column :project_tasks, :tags, :jsonb, default: []\nadd_index :project_tasks, :tags, using: :gin\n\n# ---\n\n# Trade-based tags\ntags: ['plumbing', 'electrical', 'carpentry']\n\n# Priority tags\ntags: ['urgent', 'client_facing', 'weather_dependent']\n\n# Location tags\ntags: ['first_floor', 'exterior', 'garage']\n\n# Custom workflow tags\ntags: ['requires_permit', 'council_inspection', 'engineer_signoff']\n\n# ---\n\n# Find tasks with specific tag\nProjectTask.where(\"tags @> ?\", ['urgent'].to_json)\n\n# Find tasks with any of multiple tags\nProjectTask.where(\"tags ?| array[:tags]\", tags: ['plumbing', 'electrical'])\n\n# Find tasks with all of multiple tags\nProjectTask.where(\"tags @> ?\", ['urgent', 'client_facing'].to_json)\n\n# ---\n\n# app/controllers/api/v1/project_tasks_controller.rb\nrender json: {\n  id: task.id,\n  name: task.name,\n  tags: task.tags || [],  # Always return array, never nil\n  # ... other fields\n} TRAPID_BIBLE.md RULE #10.11",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "10.11",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# db/migrate/..._add_tags_to_project_tasks.rb\nadd_column :project_tasks, :tags, :jsonb, default: []\nadd_index :project_tasks, :tags, using: :gin\n\n# ---\n\n# Trade-based tags\ntags: ['plumbing', 'electrical', 'carpentry']\n\n# Priority tags\ntags: ['urgent', 'client_facing', 'weather_dependent']\n\n# Location tags\ntags: ['first_floor', 'exterior', 'garage']\n\n# Custom workflow tags\ntags: ['requires_permit', 'council_inspection', 'engineer_signoff']\n\n# ---\n\n# Find tasks with specific tag\nProjectTask.where(\"tags @> ?\", ['urgent'].to_json)\n\n# Find tasks with any of multiple tags\nProjectTask.where(\"tags ?| array[:tags]\", tags: ['plumbing', 'electrical'])\n\n# Find tasks with all of multiple tags\nProjectTask.where(\"tags @> ?\", ['urgent', 'client_facing'].to_json)\n\n# ---\n\n# app/controllers/api/v1/project_tasks_controller.rb\nrender json: {\n  id: task.id,\n  name: task.name,\n  tags: task.tags || [],  # Always return array, never nil\n  # ... other fields\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #10.11"
  },
  {
    "id": 176,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Unique Holidays Per Region",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Unique Holidays Per Region feature - Validate uniqueness: `validates :date, uniqueness: { scope: :region }` - Use region codes: QLD, NSW, VIC, SA, WA, TAS, NT, NZ - Store date in UTC (no time component) # app/models/public_holiday.rb\nvalidates :name, presence: true\nvalidates :date, presence: true, uniqueness: { scope: :region }\nvalidates :region, presence: true\n\n# ---\n\nUNIQUE(date, region) TRAPID_BIBLE.md RULE #11.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.1",
    "difficulty": "intermediate",
    "summary": "- Validate uniqueness: `validates :date, uniqueness: { scope: :region }` - Use region codes: QLD, NSW, VIC, SA, WA, TAS, NT, NZ - Store date in UTC (no time component)",
    "code_example": "# app/models/public_holiday.rb\nvalidates :name, presence: true\nvalidates :date, presence: true, uniqueness: { scope: :region }\nvalidates :region, presence: true\n\n# ---\n\nUNIQUE(date, region)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.1"
  },
  {
    "id": 177,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Rain Log - One Entry Per Construction Per Day",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Rain Log - One Entry Per Construction Per Day util - Enforce uniqueness at database level: `UNIQUE(construction_id, date)` - Check for existing log before auto-creation - Use `find_or_initialize_by` pattern for updates # app/models/rain_log.rb\nvalidate :date_cannot_be_in_future\n\ndef date_cannot_be_in_future\n  errors.add(:date, \"can't be in the future\") if date.present? && date > Date.current\nend\n\n# app/jobs/check_yesterday_rain_job.rb\nexisting_log = construction.rain_logs.find_by(date: yesterday)\nnext if existing_log  # Skip if already logged TRAPID_BIBLE.md RULE #11.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.2",
    "difficulty": "intermediate",
    "summary": "- Enforce uniqueness at database level: `UNIQUE(construction_id, date)` - Check for existing log before auto-creation - Use `find_or_initialize_by` pattern for updates",
    "code_example": "# app/models/rain_log.rb\nvalidate :date_cannot_be_in_future\n\ndef date_cannot_be_in_future\n  errors.add(:date, \"can't be in the future\") if date.present? && date > Date.current\nend\n\n# app/jobs/check_yesterday_rain_job.rb\nexisting_log = construction.rain_logs.find_by(date: yesterday)\nnext if existing_log  # Skip if already logged",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.2"
  },
  {
    "id": 178,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Rainfall Severity Auto-Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Rainfall Severity Auto-Calculation util - Light: `< 5mm` - Moderate: `5mm to 15mm` - Heavy: `> 15mm` # app/models/rain_log.rb\ndef self.calculate_severity(rainfall_mm)\n  return nil if rainfall_mm.nil? || rainfall_mm.zero?\n  rainfall_mm < 5 ? 'light' : rainfall_mm < 15 ? 'moderate' : 'heavy'\nend\n\ndef auto_calculate_severity!\n  calculated = self.class.calculate_severity(rainfall_mm)\n  update_column(:severity, calculated) if calculated\nend\n\n# After create/update callbacks\nafter_save :auto_calculate_severity!, if: :rainfall_mm_changed? TRAPID_BIBLE.md RULE #11.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.3",
    "difficulty": "intermediate",
    "summary": "- Light: `< 5mm` - Moderate: `5mm to 15mm` - Heavy: `> 15mm`",
    "code_example": "# app/models/rain_log.rb\ndef self.calculate_severity(rainfall_mm)\n  return nil if rainfall_mm.nil? || rainfall_mm.zero?\n  rainfall_mm < 5 ? 'light' : rainfall_mm < 15 ? 'moderate' : 'heavy'\nend\n\ndef auto_calculate_severity!\n  calculated = self.class.calculate_severity(rainfall_mm)\n  update_column(:severity, calculated) if calculated\nend\n\n# After create/update callbacks\nafter_save :auto_calculate_severity!, if: :rainfall_mm_changed?",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.3"
  },
  {
    "id": 179,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Manual Rain Logs Require Notes",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Manual Rain Logs Require Notes component - Validate presence: `validates :notes, presence: true, if: :source_manual?` - Display notes in UI for audit trail - Include who created the entry (`created_by_user_id`) # app/models/rain_log.rb\nbelongs_to :created_by_user, class_name: 'User', optional: true\n\nenum :source, {\n  automatic: 'automatic',\n  manual: 'manual'\n}, prefix: true\n\nvalidates :notes, presence: true, if: :source_manual? TRAPID_BIBLE.md RULE #11.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.4",
    "difficulty": "intermediate",
    "summary": "- Validate presence: `validates :notes, presence: true, if: :source_manual?` - Display notes in UI for audit trail - Include who created the entry (`created_by_user_id`)",
    "code_example": "# app/models/rain_log.rb\nbelongs_to :created_by_user, class_name: 'User', optional: true\n\nenum :source, {\n  automatic: 'automatic',\n  manual: 'manual'\n}, prefix: true\n\nvalidates :notes, presence: true, if: :source_manual?",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.4"
  },
  {
    "id": 180,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Weather API - Historical Data Only",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Weather API - Historical Data Only integration - Validate date is not in future before API call - Use `Date.yesterday` for automatic checks - Raise `ArgumentError` if future date provided # app/services/weather_api_client.rb\ndef fetch_historical(location, date)\n  raise ArgumentError, 'Date cannot be in the future' if date > Date.current\n\n  url = build_url('/history.json', {\n    q: location,\n    dt: date.strftime('%Y-%m-%d')\n  })\n\n  response = make_request(url)\n  parse_response(response)\nend TRAPID_BIBLE.md RULE #11.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.5",
    "difficulty": "intermediate",
    "summary": "- Validate date is not in future before API call - Use `Date.yesterday` for automatic checks - Raise `ArgumentError` if future date provided",
    "code_example": "# app/services/weather_api_client.rb\ndef fetch_historical(location, date)\n  raise ArgumentError, 'Date cannot be in the future' if date > Date.current\n\n  url = build_url('/history.json', {\n    q: location,\n    dt: date.strftime('%Y-%m-%d')\n  })\n\n  response = make_request(url)\n  parse_response(response)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.5"
  },
  {
    "id": 181,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Location Extraction Priority",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Location Extraction Priority integration 1. `construction.location` (if present) 2. `construction.project.site_address` (extract suburb) 3. `construction.title` (parse after dash) # app/jobs/check_yesterday_rain_job.rb\ndef extract_location(construction)\n  # Priority 1: Explicit location field\n  return construction.location if construction.location.present?\n\n  # Priority 2: Parse site_address (extract suburb)\n  if construction.project&.site_address.present?\n    address = construction.project.site_address\n    parts = address.split(',').map(&:strip)\n    return parts[-2] if parts.length > 1  # Suburb is second-to-last\n  end\n\n  # Priority 3: Extract from title (e.g., \"House Build - Bondi\")\n  if construction.title.include?('-')\n    potential_location = construction.title.split('-').last.strip\n    return potential_location if potential_location.present?\n  end\n\n  nil  # Skip if location cannot be determined\nend TRAPID_BIBLE.md RULE #11.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.6",
    "difficulty": "intermediate",
    "summary": "1. `construction.location` (if present) 2. `construction.project.site_address` (extract suburb) 3. `construction.title` (parse after dash)",
    "code_example": "# app/jobs/check_yesterday_rain_job.rb\ndef extract_location(construction)\n  # Priority 1: Explicit location field\n  return construction.location if construction.location.present?\n\n  # Priority 2: Parse site_address (extract suburb)\n  if construction.project&.site_address.present?\n    address = construction.project.site_address\n    parts = address.split(',').map(&:strip)\n    return parts[-2] if parts.length > 1  # Suburb is second-to-last\n  end\n\n  # Priority 3: Extract from title (e.g., \"House Build - Bondi\")\n  if construction.title.include?('-')\n    potential_location = construction.title.split('-').last.strip\n    return potential_location if potential_location.present?\n  end\n\n  nil  # Skip if location cannot be determined\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.6"
  },
  {
    "id": 182,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Gantt Integration - Working Day Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Gantt Integration - Working Day Calculation util - Load company `working_days` configuration - Load `PublicHoliday` dates for relevant region (3-year range) - Skip task to next working day if lands on weekend OR holiday - Respect lock hierarchy (loc # app/services/schedule_cascade_service.rb\ndef working_day?(date)\n  working_days = @company_settings.working_days || default_working_days\n  day_name = date.strftime('%A').downcase\n  working_days[day_name] == true && !@holidays.include?(date)\nend\n\ndef skip_to_next_working_day(day_offset)\n  actual_date = @reference_date + day_offset.days\n\n  while !working_day?(actual_date)\n    actual_date += 1.day\n  end\n\n  (actual_date - @reference_date).to_i\nend\n\ndef load_holidays\n  today = CompanySetting.today\n  year_range = (today.year..today.year + 2)\n\n  holiday_dates = PublicHoliday\n    .for_region(@region)\n    .where('EXTRACT(YEAR FROM date) IN (?)', year_range.to_a)\n    .pluck(:date)\n\n  Set.new(holiday_dates)  # O(1) lookup\nend TRAPID_BIBLE.md RULE #11.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.7",
    "difficulty": "intermediate",
    "summary": "- Load company `working_days` configuration - Load `PublicHoliday` dates for relevant region (3-year range) - Skip task to next working day if lands on weekend OR holiday - Respect lock hierarchy (loc",
    "code_example": "# app/services/schedule_cascade_service.rb\ndef working_day?(date)\n  working_days = @company_settings.working_days || default_working_days\n  day_name = date.strftime('%A').downcase\n  working_days[day_name] == true && !@holidays.include?(date)\nend\n\ndef skip_to_next_working_day(day_offset)\n  actual_date = @reference_date + day_offset.days\n\n  while !working_day?(actual_date)\n    actual_date += 1.day\n  end\n\n  (actual_date - @reference_date).to_i\nend\n\ndef load_holidays\n  today = CompanySetting.today\n  year_range = (today.year..today.year + 2)\n\n  holiday_dates = PublicHoliday\n    .for_region(@region)\n    .where('EXTRACT(YEAR FROM date) IN (?)', year_range.to_a)\n    .pluck(:date)\n\n  Set.new(holiday_dates)  # O(1) lookup\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.7"
  },
  {
    "id": 183,
    "chapter_number": 11,
    "chapter_name": "Weather & Public Holidays",
    "component": null,
    "title": "Weather API Response Storage",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Weather API Response Storage integration - Store complete API JSON response - Include location confirmation data - Preserve all weather metrics (temp, condition, etc.) - Use for future analysis and verification # app/services/weather_api_client.rb\ndef parse_response(response)\n  day_data = response.dig('forecast', 'forecastday', 0, 'day')\n\n  {\n    rainfall_mm: day_data['totalprecip_mm'].to_f,\n    date: response.dig('forecast', 'forecastday', 0, 'date'),\n    location: response.dig('location', 'name'),\n    region: response.dig('location', 'region'),\n    country: response.dig('location', 'country'),\n    max_temp_c: day_data['maxtemp_c'].to_f,\n    min_temp_c: day_data['mintemp_c'].to_f,\n    condition: day_data.dig('condition', 'text'),\n    raw_response: response  # Full API JSON\n  }\nend\n\n# app/jobs/check_yesterday_rain_job.rb\nrain_log = construction.rain_logs.create!(\n  rainfall_mm: weather_data[:rainfall_mm],\n  severity: RainLog.calculate_severity(weather_data[:rainfall_mm]),\n  source: 'automatic',\n  weather_api_response: weather_data[:raw_response]  # Store full response\n) TRAPID_BIBLE.md RULE #11.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "11.8",
    "difficulty": "intermediate",
    "summary": "- Store complete API JSON response - Include location confirmation data - Preserve all weather metrics (temp, condition, etc.) - Use for future analysis and verification",
    "code_example": "# app/services/weather_api_client.rb\ndef parse_response(response)\n  day_data = response.dig('forecast', 'forecastday', 0, 'day')\n\n  {\n    rainfall_mm: day_data['totalprecip_mm'].to_f,\n    date: response.dig('forecast', 'forecastday', 0, 'date'),\n    location: response.dig('location', 'name'),\n    region: response.dig('location', 'region'),\n    country: response.dig('location', 'country'),\n    max_temp_c: day_data['maxtemp_c'].to_f,\n    min_temp_c: day_data['mintemp_c'].to_f,\n    condition: day_data.dig('condition', 'text'),\n    raw_response: response  # Full API JSON\n  }\nend\n\n# app/jobs/check_yesterday_rain_job.rb\nrain_log = construction.rain_logs.create!(\n  rainfall_mm: weather_data[:rainfall_mm],\n  severity: RainLog.calculate_severity(weather_data[:rainfall_mm]),\n  source: 'automatic',\n  weather_api_response: weather_data[:raw_response]  # Store full response\n)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #11.8"
  },
  {
    "id": 184,
    "chapter_number": 12,
    "chapter_name": "OneDrive Integration",
    "component": null,
    "title": "Folder Template System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Folder Template System util ✅ Trapid Jobs/\n  └── [Job Number] - [Job Name]/\n      ├── Plans/\n      ├── Quotes/\n      ├── Contracts/\n      ├── Photos/\n      ├── Invoices/\n      └── Correspondence/ TRAPID_BIBLE.md RULE #12.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "12.2",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "Trapid Jobs/\n  └── [Job Number] - [Job Name]/\n      ├── Plans/\n      ├── Quotes/\n      ├── Contracts/\n      ├── Photos/\n      ├── Invoices/\n      └── Correspondence/",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #12.2"
  },
  {
    "id": 220,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Model Callback Automation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Model Callback Automation util  # app/models/purchase_order.rb\nbefore_save :calculate_totals\nafter_save :update_construction_profit\nafter_destroy :update_construction_profit\n\ndef calculate_totals\n  self.sub_total = line_items.sum(&:total_price)\n  self.tax = sub_total * (tax_rate || 0.10)\n  self.total = sub_total + tax\nend\n\ndef update_construction_profit\n  return unless construction\n  construction.recalculate_profit!\nend\n\n# ---\n\n# app/models/project_task.rb\nafter_save :spawn_child_tasks_on_status_change, if: :saved_change_to_status?\n\ndef spawn_child_tasks_on_status_change\n  return unless spawn_rules_enabled?\n\n  case status\n  when 'completed'\n    spawn_photo_task if spawn_photo_on_completion?\n    spawn_certificate_task if spawn_certificate_on_completion?\n  when 'in_progress'\n    spawn_subtasks if spawn_subtasks_on_start?\n  end\nend\n\n# ---\n\n# app/models/pricebook_item.rb\nafter_update :track_price_change, if: :should_track_price_change?\n\ndef track_price_change\n  return if skip_price_history_callback\n\n  PriceHistory.create!(\n    pricebook_item: self,\n    old_price: current_price_was,\n    new_price: current_price,\n    change_reason: price_change_reason || 'Manual update',\n    changed_by: User.current\n  )\nend TRAPID_BIBLE.md RULE #17.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.5",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/purchase_order.rb\nbefore_save :calculate_totals\nafter_save :update_construction_profit\nafter_destroy :update_construction_profit\n\ndef calculate_totals\n  self.sub_total = line_items.sum(&:total_price)\n  self.tax = sub_total * (tax_rate || 0.10)\n  self.total = sub_total + tax\nend\n\ndef update_construction_profit\n  return unless construction\n  construction.recalculate_profit!\nend\n\n# ---\n\n# app/models/project_task.rb\nafter_save :spawn_child_tasks_on_status_change, if: :saved_change_to_status?\n\ndef spawn_child_tasks_on_status_change\n  return unless spawn_rules_enabled?\n\n  case status\n  when 'completed'\n    spawn_photo_task if spawn_photo_on_completion?\n    spawn_certificate_task if spawn_certificate_on_completion?\n  when 'in_progress'\n    spawn_subtasks if spawn_subtasks_on_start?\n  end\nend\n\n# ---\n\n# app/models/pricebook_item.rb\nafter_update :track_price_change, if: :should_track_price_change?\n\ndef track_price_change\n  return if skip_price_history_callback\n\n  PriceHistory.create!(\n    pricebook_item: self,\n    old_price: current_price_was,\n    new_price: current_price,\n    change_reason: price_change_reason || 'Manual update',\n    changed_by: User.current\n  )\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.5"
  },
  {
    "id": 185,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Organization-Wide Singleton OAuth Credential",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Organization-Wide Singleton OAuth Credential integration  # app/models/organization_outlook_credential.rb\nclass OrganizationOutlookCredential < ApplicationRecord\n  encrypts :access_token, :refresh_token\n\n  def self.current\n    first_or_create!\n  end\n\n  def needs_refresh?\n    expires_at.nil? || Time.current >= expires_at - 5.minutes\n  end\nend\n\n# ---\n\n# app/services/outlook_service.rb\ndef ensure_valid_token\n  credential = OrganizationOutlookCredential.current\n\n  if credential.needs_refresh?\n    refresh_access_token(credential)\n  end\n\n  credential.access_token\nend\n\ndef refresh_access_token(credential)\n  response = HTTParty.post(\"https://login.microsoftonline.com/#{tenant}/oauth2/v2.0/token\", {\n    body: {\n      client_id: ENV['OUTLOOK_CLIENT_ID'],\n      client_secret: ENV['OUTLOOK_CLIENT_SECRET'],\n      refresh_token: credential.refresh_token,\n      grant_type: 'refresh_token'\n    }\n  })\n\n  credential.update!(\n    access_token: response['access_token'],\n    refresh_token: response['refresh_token'],\n    expires_at: Time.current + response['expires_in'].seconds\n  )\nend TRAPID_BIBLE.md RULE #13.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/organization_outlook_credential.rb\nclass OrganizationOutlookCredential < ApplicationRecord\n  encrypts :access_token, :refresh_token\n\n  def self.current\n    first_or_create!\n  end\n\n  def needs_refresh?\n    expires_at.nil? || Time.current >= expires_at - 5.minutes\n  end\nend\n\n# ---\n\n# app/services/outlook_service.rb\ndef ensure_valid_token\n  credential = OrganizationOutlookCredential.current\n\n  if credential.needs_refresh?\n    refresh_access_token(credential)\n  end\n\n  credential.access_token\nend\n\ndef refresh_access_token(credential)\n  response = HTTParty.post(\"https://login.microsoftonline.com/#{tenant}/oauth2/v2.0/token\", {\n    body: {\n      client_id: ENV['OUTLOOK_CLIENT_ID'],\n      client_secret: ENV['OUTLOOK_CLIENT_SECRET'],\n      refresh_token: credential.refresh_token,\n      grant_type: 'refresh_token'\n    }\n  })\n\n  credential.update!(\n    access_token: response['access_token'],\n    refresh_token: response['refresh_token'],\n    expires_at: Time.current + response['expires_in'].seconds\n  )\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.1"
  },
  {
    "id": 186,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Four-Strategy Email-to-Job Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Four-Strategy Email-to-Job Matching feature  # app/services/email_parser_service.rb\ndef match_construction(email_data)\n  # Strategy 1: Job reference in subject (highest priority)\n  if email_data[:subject] =~ /#(\\d+)/ || email_data[:subject] =~ /JOB-(\\d+)/\n    construction = Construction.find_by(reference_number: $1)\n    return construction if construction\n  end\n\n  # Strategy 2: Job reference in body\n  if email_data[:body] =~ /#(\\d+)/ || email_data[:body] =~ /JOB-(\\d+)/\n    construction = Construction.find_by(reference_number: $1)\n    return construction if construction\n  end\n\n  # Strategy 3: Sender email matches contact\n  contact = Contact.find_by(email: email_data[:from])\n  if contact\n    # Return most recent active job for this contact\n    return contact.constructions.active.order(created_at: :desc).first\n  end\n\n  # Strategy 4: Address matching (fuzzy)\n  extract_addresses_from_email(email_data).each do |address|\n    construction = Construction.where(\"address ILIKE ?\", \"%#{address}%\").first\n    return construction if construction\n  end\n\n  # No match found\n  nil\nend\n\n# ---\n\n# app/controllers/api/v1/emails_controller.rb\ndef create\n  email_data = parse_email_params(params)\n\n  matched_construction = EmailParserService.new.match_construction(email_data)\n\n  email = Email.create!(\n    construction: matched_construction,  # May be nil if no match\n    from_email: email_data[:from],\n    subject: email_data[:subject],\n    body_text: email_data[:body],\n    # ... other fields\n  )\n\n  render json: email\nend TRAPID_BIBLE.md RULE #13.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/email_parser_service.rb\ndef match_construction(email_data)\n  # Strategy 1: Job reference in subject (highest priority)\n  if email_data[:subject] =~ /#(\\d+)/ || email_data[:subject] =~ /JOB-(\\d+)/\n    construction = Construction.find_by(reference_number: $1)\n    return construction if construction\n  end\n\n  # Strategy 2: Job reference in body\n  if email_data[:body] =~ /#(\\d+)/ || email_data[:body] =~ /JOB-(\\d+)/\n    construction = Construction.find_by(reference_number: $1)\n    return construction if construction\n  end\n\n  # Strategy 3: Sender email matches contact\n  contact = Contact.find_by(email: email_data[:from])\n  if contact\n    # Return most recent active job for this contact\n    return contact.constructions.active.order(created_at: :desc).first\n  end\n\n  # Strategy 4: Address matching (fuzzy)\n  extract_addresses_from_email(email_data).each do |address|\n    construction = Construction.where(\"address ILIKE ?\", \"%#{address}%\").first\n    return construction if construction\n  end\n\n  # No match found\n  nil\nend\n\n# ---\n\n# app/controllers/api/v1/emails_controller.rb\ndef create\n  email_data = parse_email_params(params)\n\n  matched_construction = EmailParserService.new.match_construction(email_data)\n\n  email = Email.create!(\n    construction: matched_construction,  # May be nil if no match\n    from_email: email_data[:from],\n    subject: email_data[:subject],\n    body_text: email_data[:body],\n    # ... other fields\n  )\n\n  render json: email\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.2"
  },
  {
    "id": 187,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Microsoft Graph API Usage Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Microsoft Graph API Usage Pattern integration  # app/services/outlook_service.rb\nGRAPH_API_BASE = \"https://graph.microsoft.com/v1.0\"\n\ndef search_emails(query: nil, folder: 'inbox', max_results: 50)\n  token = ensure_valid_token\n\n  # Build OData filter\n  filter_parts = []\n  filter_parts << \"receivedDateTime ge #{30.days.ago.iso8601}\" if folder == 'inbox'\n  filter_parts << \"(contains(subject,'#{query}') or contains(body/content,'#{query}'))\" if query\n\n  params = {\n    '$filter' => filter_parts.join(' and '),\n    '$top' => max_results,\n    '$select' => 'id,subject,from,toRecipients,ccRecipients,receivedDateTime,hasAttachments,body',\n    '$orderby' => 'receivedDateTime desc'\n  }\n\n  response = HTTParty.get(\n    \"#{GRAPH_API_BASE}/me/mailFolders/#{folder}/messages\",\n    headers: { 'Authorization' => \"Bearer #{token}\" },\n    query: params\n  )\n\n  response.parsed_response['value']\nend\n\n# ---\n\n# app/controllers/api/v1/outlook_controller.rb\nREQUIRED_SCOPES = [\n  'Mail.Read',              # Read emails\n  'MailboxSettings.Read',   # Read settings/folders\n  'offline_access'          # Refresh token support\n].freeze\n\ndef auth_url\n  params = {\n    client_id: ENV['OUTLOOK_CLIENT_ID'],\n    redirect_uri: \"#{ENV['FRONTEND_URL']}/settings/outlook/callback\",\n    scope: REQUIRED_SCOPES.join(' '),\n    response_type: 'code',\n    response_mode: 'query'\n  }\n\n  \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize?#{params.to_query}\"\nend TRAPID_BIBLE.md RULE #13.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/outlook_service.rb\nGRAPH_API_BASE = \"https://graph.microsoft.com/v1.0\"\n\ndef search_emails(query: nil, folder: 'inbox', max_results: 50)\n  token = ensure_valid_token\n\n  # Build OData filter\n  filter_parts = []\n  filter_parts << \"receivedDateTime ge #{30.days.ago.iso8601}\" if folder == 'inbox'\n  filter_parts << \"(contains(subject,'#{query}') or contains(body/content,'#{query}'))\" if query\n\n  params = {\n    '$filter' => filter_parts.join(' and '),\n    '$top' => max_results,\n    '$select' => 'id,subject,from,toRecipients,ccRecipients,receivedDateTime,hasAttachments,body',\n    '$orderby' => 'receivedDateTime desc'\n  }\n\n  response = HTTParty.get(\n    \"#{GRAPH_API_BASE}/me/mailFolders/#{folder}/messages\",\n    headers: { 'Authorization' => \"Bearer #{token}\" },\n    query: params\n  )\n\n  response.parsed_response['value']\nend\n\n# ---\n\n# app/controllers/api/v1/outlook_controller.rb\nREQUIRED_SCOPES = [\n  'Mail.Read',              # Read emails\n  'MailboxSettings.Read',   # Read settings/folders\n  'offline_access'          # Refresh token support\n].freeze\n\ndef auth_url\n  params = {\n    client_id: ENV['OUTLOOK_CLIENT_ID'],\n    redirect_uri: \"#{ENV['FRONTEND_URL']}/settings/outlook/callback\",\n    scope: REQUIRED_SCOPES.join(' '),\n    response_type: 'code',\n    response_mode: 'query'\n  }\n\n  \"https://login.microsoftonline.com/common/oauth2/v2.0/authorize?#{params.to_query}\"\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.3"
  },
  {
    "id": 188,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Email Threading Support via Message-ID",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Email Threading Support via Message-ID component  # db/schema.rb\ncreate_table :emails do |t|\n  t.string :message_id, null: false, index: { unique: true }\n  t.string :in_reply_to      # Message-ID of parent email\n  t.text :references         # Space-separated list of ancestor message IDs\n\n  # ... other fields\nend\n\n# ---\n\n# app/services/email_parser_service.rb\ndef extract_threading_info(raw_email_headers)\n  {\n    message_id: raw_email_headers['Message-ID']&.value,\n    in_reply_to: raw_email_headers['In-Reply-To']&.value,\n    references: raw_email_headers['References']&.value\n  }\nend\n\n# Controller usage:\nemail = Email.create!(\n  message_id: threading_info[:message_id],\n  in_reply_to: threading_info[:in_reply_to],\n  references: threading_info[:references],\n  # ... other fields\n)\n\n# ---\n\n# app/models/email.rb\ndef conversation_root\n  return self if in_reply_to.blank?\n  Email.find_by(message_id: in_reply_to)\nend\n\ndef conversation_thread\n  # Get all emails in this thread\n  root = conversation_root\n  Email.where(\"message_id = ? OR references LIKE ?\", root.message_id, \"%#{root.message_id}%\")\n       .order(:received_at)\nend TRAPID_BIBLE.md RULE #13.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# db/schema.rb\ncreate_table :emails do |t|\n  t.string :message_id, null: false, index: { unique: true }\n  t.string :in_reply_to      # Message-ID of parent email\n  t.text :references         # Space-separated list of ancestor message IDs\n\n  # ... other fields\nend\n\n# ---\n\n# app/services/email_parser_service.rb\ndef extract_threading_info(raw_email_headers)\n  {\n    message_id: raw_email_headers['Message-ID']&.value,\n    in_reply_to: raw_email_headers['In-Reply-To']&.value,\n    references: raw_email_headers['References']&.value\n  }\nend\n\n# Controller usage:\nemail = Email.create!(\n  message_id: threading_info[:message_id],\n  in_reply_to: threading_info[:in_reply_to],\n  references: threading_info[:references],\n  # ... other fields\n)\n\n# ---\n\n# app/models/email.rb\ndef conversation_root\n  return self if in_reply_to.blank?\n  Email.find_by(message_id: in_reply_to)\nend\n\ndef conversation_thread\n  # Get all emails in this thread\n  root = conversation_root\n  Email.where(\"message_id = ? OR references LIKE ?\", root.message_id, \"%#{root.message_id}%\")\n       .order(:received_at)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.4"
  },
  {
    "id": 189,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Webhook Support for Email Services",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Webhook Support for Email Services integration  # app/controllers/api/v1/emails_controller.rb\ndef webhook\n  # Parse incoming webhook payload (varies by service)\n  email_data = case request.headers['User-Agent']\n  when /SendGrid/\n    parse_sendgrid_webhook(params)\n  when /Mailgun/\n    parse_mailgun_webhook(params)\n  else\n    parse_generic_webhook(params)\n  end\n\n  # Use same matching logic as Outlook import\n  matched_construction = EmailParserService.new.match_construction(email_data)\n\n  email = Email.create!(\n    construction: matched_construction,\n    from_email: email_data[:from],\n    to_emails: email_data[:to],\n    subject: email_data[:subject],\n    body_text: email_data[:body_text],\n    body_html: email_data[:body_html],\n    received_at: email_data[:received_at] || Time.current,\n    message_id: email_data[:message_id] || SecureRandom.uuid\n  )\n\n  head :ok  # Return 200 to acknowledge receipt\nend\n\n# ---\n\n# For SendGrid:\ndef verify_sendgrid_signature\n  signature = request.headers['X-Twilio-Email-Event-Webhook-Signature']\n  timestamp = request.headers['X-Twilio-Email-Event-Webhook-Timestamp']\n\n  # Verify signature matches expected value\n  expected = OpenSSL::HMAC.hexdigest(\n    'SHA256',\n    ENV['SENDGRID_WEBHOOK_SECRET'],\n    timestamp + request.raw_post\n  )\n\n  signature == expected\nend TRAPID_BIBLE.md RULE #13.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.5",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/emails_controller.rb\ndef webhook\n  # Parse incoming webhook payload (varies by service)\n  email_data = case request.headers['User-Agent']\n  when /SendGrid/\n    parse_sendgrid_webhook(params)\n  when /Mailgun/\n    parse_mailgun_webhook(params)\n  else\n    parse_generic_webhook(params)\n  end\n\n  # Use same matching logic as Outlook import\n  matched_construction = EmailParserService.new.match_construction(email_data)\n\n  email = Email.create!(\n    construction: matched_construction,\n    from_email: email_data[:from],\n    to_emails: email_data[:to],\n    subject: email_data[:subject],\n    body_text: email_data[:body_text],\n    body_html: email_data[:body_html],\n    received_at: email_data[:received_at] || Time.current,\n    message_id: email_data[:message_id] || SecureRandom.uuid\n  )\n\n  head :ok  # Return 200 to acknowledge receipt\nend\n\n# ---\n\n# For SendGrid:\ndef verify_sendgrid_signature\n  signature = request.headers['X-Twilio-Email-Event-Webhook-Signature']\n  timestamp = request.headers['X-Twilio-Email-Event-Webhook-Timestamp']\n\n  # Verify signature matches expected value\n  expected = OpenSSL::HMAC.hexdigest(\n    'SHA256',\n    ENV['SENDGRID_WEBHOOK_SECRET'],\n    timestamp + request.raw_post\n  )\n\n  signature == expected\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.5"
  },
  {
    "id": 190,
    "chapter_number": 13,
    "chapter_name": "Outlook/Email Integration",
    "component": null,
    "title": "Inbound-Only Architecture (Current Limitation)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Inbound-Only Architecture (Current Limitation) integration Inbound-Only Architecture (Current Limitation) # Proposed pattern (NOT YET IMPLEMENTED):\n# app/mailers/job_mailer.rb\nclass JobMailer < ApplicationMailer\n  def quote_sent(construction_id, contact_id)\n    @construction = Construction.find(construction_id)\n    @contact = Contact.find(contact_id)\n\n    mail(\n      to: @contact.email,\n      subject: \"Quote for #{@construction.name}\",\n      from: ENV['OUTBOUND_EMAIL_ADDRESS']\n    )\n  end\nend\n\n# Usage:\nJobMailer.quote_sent(job.id, contact.id).deliver_later TRAPID_BIBLE.md RULE #13.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "13.6",
    "difficulty": "intermediate",
    "summary": "Inbound-Only Architecture (Current Limitation)",
    "code_example": "# Proposed pattern (NOT YET IMPLEMENTED):\n# app/mailers/job_mailer.rb\nclass JobMailer < ApplicationMailer\n  def quote_sent(construction_id, contact_id)\n    @construction = Construction.find(construction_id)\n    @contact = Contact.find(contact_id)\n\n    mail(\n      to: @contact.email,\n      subject: \"Quote for #{@construction.name}\",\n      from: ENV['OUTBOUND_EMAIL_ADDRESS']\n    )\n  end\nend\n\n# Usage:\nJobMailer.quote_sent(job.id, contact.id).deliver_later",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #13.6"
  },
  {
    "id": 191,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "ChatMessage Multi-Channel Architecture",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "ChatMessage Multi-Channel Architecture util  # app/models/chat_message.rb\nclass ChatMessage < ApplicationRecord\n  belongs_to :user\n  belongs_to :project, optional: true\n  belongs_to :recipient_user, class_name: 'User', optional: true\n  belongs_to :construction, optional: true\n\n  validates :content, presence: true\n\n  # Channel messages (team-wide)\n  scope :in_channel, ->(channel) {\n    where(channel: channel, project_id: nil, recipient_user_id: nil)\n      .order(created_at: :asc)\n  }\n\n  # Project/job messages\n  scope :for_project, ->(project_id) {\n    where(project_id: project_id).order(created_at: :asc)\n  }\n\n  # Direct messages between users\n  scope :between_users, ->(user1_id, user2_id) {\n    where(\n      '(user_id = ? AND recipient_user_id = ?) OR (user_id = ? AND recipient_user_id = ?)',\n      user1_id, user2_id, user2_id, user1_id\n    ).order(created_at: :asc)\n  }\n\n  # General channel (default)\n  scope :general, -> {\n    where(channel: 'general', project_id: nil, recipient_user_id: nil)\n      .order(created_at: :asc)\n  }\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\ndef index\n  if params[:user_id].present?\n    # Direct message query\n    @messages = ChatMessage.between_users(@current_user.id, params[:user_id])\n  elsif params[:project_id].present?\n    # Project message query\n    @messages = ChatMessage.for_project(params[:project_id])\n  else\n    # Channel query (default: general)\n    channel = params[:channel] || 'general'\n    @messages = ChatMessage.in_channel(channel)\n  end\n\n  @messages = @messages.recent(100)\n  render json: @messages.as_json(include_user: true)\nend TRAPID_BIBLE.md RULE #14.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/chat_message.rb\nclass ChatMessage < ApplicationRecord\n  belongs_to :user\n  belongs_to :project, optional: true\n  belongs_to :recipient_user, class_name: 'User', optional: true\n  belongs_to :construction, optional: true\n\n  validates :content, presence: true\n\n  # Channel messages (team-wide)\n  scope :in_channel, ->(channel) {\n    where(channel: channel, project_id: nil, recipient_user_id: nil)\n      .order(created_at: :asc)\n  }\n\n  # Project/job messages\n  scope :for_project, ->(project_id) {\n    where(project_id: project_id).order(created_at: :asc)\n  }\n\n  # Direct messages between users\n  scope :between_users, ->(user1_id, user2_id) {\n    where(\n      '(user_id = ? AND recipient_user_id = ?) OR (user_id = ? AND recipient_user_id = ?)',\n      user1_id, user2_id, user2_id, user1_id\n    ).order(created_at: :asc)\n  }\n\n  # General channel (default)\n  scope :general, -> {\n    where(channel: 'general', project_id: nil, recipient_user_id: nil)\n      .order(created_at: :asc)\n  }\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\ndef index\n  if params[:user_id].present?\n    # Direct message query\n    @messages = ChatMessage.between_users(@current_user.id, params[:user_id])\n  elsif params[:project_id].present?\n    # Project message query\n    @messages = ChatMessage.for_project(params[:project_id])\n  else\n    # Channel query (default: general)\n    channel = params[:channel] || 'general'\n    @messages = ChatMessage.in_channel(channel)\n  end\n\n  @messages = @messages.recent(100)\n  render json: @messages.as_json(include_user: true)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.1"
  },
  {
    "id": 192,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Message-to-Job Linking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Message-to-Job Linking integration  # app/controllers/api/v1/chat_messages_controller.rb\ndef save_to_job\n  @message = ChatMessage.find(params[:id])\n  construction = Construction.find(params[:construction_id])\n\n  @message.update!(\n    construction_id: construction.id,\n    saved_to_job: true\n  )\n\n  render json: { message: 'Message saved to job', chat_message: @message }\nend\n\ndef save_conversation_to_job\n  construction = Construction.find(params[:construction_id])\n  message_ids = params[:message_ids]\n\n  ChatMessage.where(id: message_ids).update_all(\n    construction_id: construction.id,\n    saved_to_job: true\n  )\n\n  render json: {\n    message: \"#{message_ids.length} messages saved to job\",\n    construction_id: construction.id\n  }\nend\n\n# ---\n\n# db/migrate/20251111021538_add_construction_to_chat_messages.rb\nadd_reference :chat_messages, :construction, foreign_key: true\nadd_column :chat_messages, :saved_to_job, :boolean, default: false\nadd_index :chat_messages, [:construction_id, :channel, :created_at]\n\n# ---\n\n// frontend/src/components/chat/ChatBox.jsx\nconst saveConversationToJob = async () => {\n  const messageIds = messages.map(m => m.id);\n\n  await fetch('/api/v1/chat_messages/save_conversation_to_job', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      construction_id: selectedConstruction,\n      message_ids: messageIds\n    })\n  });\n}; TRAPID_BIBLE.md RULE #14.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/chat_messages_controller.rb\ndef save_to_job\n  @message = ChatMessage.find(params[:id])\n  construction = Construction.find(params[:construction_id])\n\n  @message.update!(\n    construction_id: construction.id,\n    saved_to_job: true\n  )\n\n  render json: { message: 'Message saved to job', chat_message: @message }\nend\n\ndef save_conversation_to_job\n  construction = Construction.find(params[:construction_id])\n  message_ids = params[:message_ids]\n\n  ChatMessage.where(id: message_ids).update_all(\n    construction_id: construction.id,\n    saved_to_job: true\n  )\n\n  render json: {\n    message: \"#{message_ids.length} messages saved to job\",\n    construction_id: construction.id\n  }\nend\n\n# ---\n\n# db/migrate/20251111021538_add_construction_to_chat_messages.rb\nadd_reference :chat_messages, :construction, foreign_key: true\nadd_column :chat_messages, :saved_to_job, :boolean, default: false\nadd_index :chat_messages, [:construction_id, :channel, :created_at]\n\n# ---\n\n// frontend/src/components/chat/ChatBox.jsx\nconst saveConversationToJob = async () => {\n  const messageIds = messages.map(m => m.id);\n\n  await fetch('/api/v1/chat_messages/save_conversation_to_job', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      construction_id: selectedConstruction,\n      message_ids: messageIds\n    })\n  });\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.2"
  },
  {
    "id": 193,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "SMS Twilio Integration",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "SMS Twilio Integration integration  # app/services/twilio_service.rb\nclass TwilioService\n  def self.send_sms(to:, body:, contact:, user: nil)\n    settings = CompanySetting.current\n    raise 'Twilio not enabled' unless settings.twilio_enabled\n\n    client = Twilio::REST::Client.new(\n      settings.twilio_account_sid,\n      settings.twilio_auth_token\n    )\n\n    normalized_to = normalize_phone_number(to)\n\n    twilio_message = client.messages.create(\n      from: settings.twilio_phone_number,\n      to: normalized_to,\n      body: body\n    )\n\n    sms = SmsMessage.create!(\n      contact: contact,\n      user: user,\n      from_phone: settings.twilio_phone_number,\n      to_phone: normalized_to,\n      body: body,\n      direction: 'outbound',\n      status: 'sent',\n      twilio_sid: twilio_message.sid,\n      sent_at: Time.current\n    )\n\n    { success: true, sms: sms, twilio_message: twilio_message }\n  rescue Twilio::REST::RestError => e\n    { success: false, error: e.message }\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/sms_messages_controller.rb\ndef webhook\n  from_phone = params['From']\n  body = params['Body']\n  message_sid = params['MessageSid']\n\n  result = TwilioService.process_incoming_sms(params)\n\n  # Return TwiML response\n  response = Twilio::TwiML::MessagingResponse.new do |r|\n    r.message(body: 'Message received') if result[:success]\n  end\n\n  render xml: response.to_s\nend\n\n# ---\n\n# app/services/twilio_service.rb\ndef self.normalize_phone_number(phone)\n  clean = phone.gsub(/\\D/, '') # Remove non-digits\n\n  # Australian mobile starting with 04\n  if clean.start_with?('04') && clean.length == 10\n    return \"+61#{clean[1..-1]}\" # Convert to +61\n  end\n\n  # Already international format\n  return \"+#{clean}\" if clean.start_with?('61')\n\n  phone # Return as-is if unrecognized\nend TRAPID_BIBLE.md RULE #14.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/twilio_service.rb\nclass TwilioService\n  def self.send_sms(to:, body:, contact:, user: nil)\n    settings = CompanySetting.current\n    raise 'Twilio not enabled' unless settings.twilio_enabled\n\n    client = Twilio::REST::Client.new(\n      settings.twilio_account_sid,\n      settings.twilio_auth_token\n    )\n\n    normalized_to = normalize_phone_number(to)\n\n    twilio_message = client.messages.create(\n      from: settings.twilio_phone_number,\n      to: normalized_to,\n      body: body\n    )\n\n    sms = SmsMessage.create!(\n      contact: contact,\n      user: user,\n      from_phone: settings.twilio_phone_number,\n      to_phone: normalized_to,\n      body: body,\n      direction: 'outbound',\n      status: 'sent',\n      twilio_sid: twilio_message.sid,\n      sent_at: Time.current\n    )\n\n    { success: true, sms: sms, twilio_message: twilio_message }\n  rescue Twilio::REST::RestError => e\n    { success: false, error: e.message }\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/sms_messages_controller.rb\ndef webhook\n  from_phone = params['From']\n  body = params['Body']\n  message_sid = params['MessageSid']\n\n  result = TwilioService.process_incoming_sms(params)\n\n  # Return TwiML response\n  response = Twilio::TwiML::MessagingResponse.new do |r|\n    r.message(body: 'Message received') if result[:success]\n  end\n\n  render xml: response.to_s\nend\n\n# ---\n\n# app/services/twilio_service.rb\ndef self.normalize_phone_number(phone)\n  clean = phone.gsub(/\\D/, '') # Remove non-digits\n\n  # Australian mobile starting with 04\n  if clean.start_with?('04') && clean.length == 10\n    return \"+61#{clean[1..-1]}\" # Convert to +61\n  end\n\n  # Already international format\n  return \"+#{clean}\" if clean.start_with?('61')\n\n  phone # Return as-is if unrecognized\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.3"
  },
  {
    "id": 195,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Unread Message Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Unread Message Tracking integration  # app/models/user.rb\nclass User < ApplicationRecord\n  has_many :chat_messages\n\n  # Timestamp when user last viewed chat\n  # Used to calculate unread count\n  # Migration: add_column :users, :last_chat_read_at, :datetime\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\ndef unread_count\n  if @current_user.last_chat_read_at.present?\n    count = ChatMessage.where('created_at > ?', @current_user.last_chat_read_at).count\n  else\n    count = ChatMessage.count\n  end\n\n  render json: { unread_count: count }\nend\n\ndef mark_as_read\n  @current_user.update!(last_chat_read_at: Time.current)\n  render json: { message: 'Messages marked as read' }\nend\n\n# ---\n\n// frontend/src/components/AppLayout.jsx\nuseEffect(() => {\n  const fetchUnreadCount = async () => {\n    try {\n      const response = await fetch('http://localhost:3001/api/v1/chat_messages/unread_count');\n      const data = await response.json();\n      setUnreadCount(data.unread_count);\n    } catch (error) {\n      console.error('Failed to fetch unread count:', error);\n    }\n  };\n\n  fetchUnreadCount();\n  const interval = setInterval(fetchUnreadCount, 5000); // Poll every 5 seconds\n\n  return () => clearInterval(interval);\n}, []); TRAPID_BIBLE.md RULE #14.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.5",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/user.rb\nclass User < ApplicationRecord\n  has_many :chat_messages\n\n  # Timestamp when user last viewed chat\n  # Used to calculate unread count\n  # Migration: add_column :users, :last_chat_read_at, :datetime\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\ndef unread_count\n  if @current_user.last_chat_read_at.present?\n    count = ChatMessage.where('created_at > ?', @current_user.last_chat_read_at).count\n  else\n    count = ChatMessage.count\n  end\n\n  render json: { unread_count: count }\nend\n\ndef mark_as_read\n  @current_user.update!(last_chat_read_at: Time.current)\n  render json: { message: 'Messages marked as read' }\nend\n\n# ---\n\n// frontend/src/components/AppLayout.jsx\nuseEffect(() => {\n  const fetchUnreadCount = async () => {\n    try {\n      const response = await fetch('http://localhost:3001/api/v1/chat_messages/unread_count');\n      const data = await response.json();\n      setUnreadCount(data.unread_count);\n    } catch (error) {\n      console.error('Failed to fetch unread count:', error);\n    }\n  };\n\n  fetchUnreadCount();\n  const interval = setInterval(fetchUnreadCount, 5000); // Poll every 5 seconds\n\n  return () => clearInterval(interval);\n}, []);",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.5"
  },
  {
    "id": 196,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Message Polling (No WebSockets)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Message Polling (No WebSockets) component  // frontend/src/components/chat/ChatBox.jsx\nuseEffect(() => {\n  loadMessages();\n\n  const interval = setInterval(() => {\n    loadMessages();\n  }, 3000); // Poll every 3 seconds\n\n  return () => clearInterval(interval);\n}, [channel, projectId, userId]);\n\nconst loadMessages = async () => {\n  let url = '/api/v1/chat_messages';\n\n  if (userId) {\n    url += `?user_id=${userId}`;\n  } else if (projectId) {\n    url += `?project_id=${projectId}`;\n  } else {\n    url += `?channel=${channel}`;\n  }\n\n  const response = await fetch(url);\n  const data = await response.json();\n  setMessages(data);\n};\n\n# ---\n\n// frontend/src/components/communications/SmsTab.jsx\nuseEffect(() => {\n  loadMessages();\n\n  const interval = setInterval(() => {\n    loadMessages();\n  }, 3000);\n\n  return () => clearInterval(interval);\n}, [contactId, jobId]); TRAPID_BIBLE.md RULE #14.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "// frontend/src/components/chat/ChatBox.jsx\nuseEffect(() => {\n  loadMessages();\n\n  const interval = setInterval(() => {\n    loadMessages();\n  }, 3000); // Poll every 3 seconds\n\n  return () => clearInterval(interval);\n}, [channel, projectId, userId]);\n\nconst loadMessages = async () => {\n  let url = '/api/v1/chat_messages';\n\n  if (userId) {\n    url += `?user_id=${userId}`;\n  } else if (projectId) {\n    url += `?project_id=${projectId}`;\n  } else {\n    url += `?channel=${channel}`;\n  }\n\n  const response = await fetch(url);\n  const data = await response.json();\n  setMessages(data);\n};\n\n# ---\n\n// frontend/src/components/communications/SmsTab.jsx\nuseEffect(() => {\n  loadMessages();\n\n  const interval = setInterval(() => {\n    loadMessages();\n  }, 3000);\n\n  return () => clearInterval(interval);\n}, [contactId, jobId]);",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.6"
  },
  {
    "id": 197,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Contact-SMS Fuzzy Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Contact-SMS Fuzzy Matching util  # app/services/twilio_service.rb\ndef self.find_contact_by_phone(phone_number)\n  normalized = normalize_phone_number(phone_number)\n\n  # Try exact match first\n  contact = Contact.find_by(mobile_phone: normalized)\n  return contact if contact\n\n  # Try partial match (last 9 digits for AU)\n  # 0412 345 678 → 412345678\n  last_9_digits = normalized.gsub(/\\D/, '')[-9..-1]\n\n  Contact.where(\n    \"regexp_replace(mobile_phone, '[^0-9]', '', 'g') LIKE ?\",\n    \"%#{last_9_digits}\"\n  ).first\nend\n\ndef self.process_incoming_sms(params)\n  from_phone = params['From']\n  body = params['Body']\n  message_sid = params['MessageSid']\n\n  contact = find_contact_by_phone(from_phone)\n\n  unless contact\n    Rails.logger.warn \"Incoming SMS from unknown number: #{from_phone}\"\n    return { success: false, error: 'Contact not found' }\n  end\n\n  sms = SmsMessage.create!(\n    contact: contact,\n    from_phone: from_phone,\n    to_phone: params['To'],\n    body: body,\n    direction: 'inbound',\n    status: 'received',\n    twilio_sid: message_sid,\n    received_at: Time.current\n  )\n\n  { success: true, sms: sms, contact: contact }\nend TRAPID_BIBLE.md RULE #14.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/twilio_service.rb\ndef self.find_contact_by_phone(phone_number)\n  normalized = normalize_phone_number(phone_number)\n\n  # Try exact match first\n  contact = Contact.find_by(mobile_phone: normalized)\n  return contact if contact\n\n  # Try partial match (last 9 digits for AU)\n  # 0412 345 678 → 412345678\n  last_9_digits = normalized.gsub(/\\D/, '')[-9..-1]\n\n  Contact.where(\n    \"regexp_replace(mobile_phone, '[^0-9]', '', 'g') LIKE ?\",\n    \"%#{last_9_digits}\"\n  ).first\nend\n\ndef self.process_incoming_sms(params)\n  from_phone = params['From']\n  body = params['Body']\n  message_sid = params['MessageSid']\n\n  contact = find_contact_by_phone(from_phone)\n\n  unless contact\n    Rails.logger.warn \"Incoming SMS from unknown number: #{from_phone}\"\n    return { success: false, error: 'Contact not found' }\n  end\n\n  sms = SmsMessage.create!(\n    contact: contact,\n    from_phone: from_phone,\n    to_phone: params['To'],\n    body: body,\n    direction: 'inbound',\n    status: 'received',\n    twilio_sid: message_sid,\n    received_at: Time.current\n  )\n\n  { success: true, sms: sms, contact: contact }\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.7"
  },
  {
    "id": 198,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Message Deletion Authorization",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Message Deletion Authorization util  # app/controllers/api/v1/chat_messages_controller.rb\ndef destroy\n  @message = ChatMessage.find(params[:id])\n\n  # Authorization: only creator can delete\n  unless @message.user_id == @current_user.id\n    return render json: { error: 'Unauthorized' }, status: :forbidden\n  end\n\n  @message.destroy\n  render json: { message: 'Message deleted' }\nend TRAPID_BIBLE.md RULE #14.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/chat_messages_controller.rb\ndef destroy\n  @message = ChatMessage.find(params[:id])\n\n  # Authorization: only creator can delete\n  unless @message.user_id == @current_user.id\n    return render json: { error: 'Unauthorized' }, status: :forbidden\n  end\n\n  @message.destroy\n  render json: { message: 'Message deleted' }\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.8"
  },
  {
    "id": 226,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Formula Evaluation System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Formula Evaluation System optimization  # Valid formula examples:\n\"{quantity} * {unit_price}\"                    # Simple calculation\n\"({cost} + {tax}) * {quantity}\"                # Grouping\n\"{amount} / {units}\"                           # Division with decimal result\n\"{supplier.tax_rate} * {amount}\"               # Cross-table lookup\n\"IF({quantity} > 100, {bulk_price}, {unit_price})\" # Conditional (Dentaku function)\n\n# ---\n\n# app/services/formula_evaluator.rb\ndef evaluate(formula_expression, record_data, record_instance = nil)\n  # Step 1: Replace {field_name} with variable placeholders\n  variables = {}\n  processed_formula = formula_expression.gsub(/\\{([^}]+)\\}/) do |match|\n    field_ref = $1\n\n    if field_ref.include?('.')\n      # Cross-table reference: {lookup_column.target_field}\n      value = resolve_cross_table_reference(field_ref, record_instance)\n    else\n      # Direct field reference\n      value = record_data[field_ref] || 0\n    end\n\n    var_name = field_ref.gsub('.', '_')\n    variables[var_name] = value.to_f\n    var_name\n  end\n\n  # Step 2: Evaluate with Dentaku\n  calculator = Dentaku::Calculator.new\n  result = calculator.evaluate(processed_formula, variables)\n\n  # Step 3: Round floats to 2 decimals\n  result.is_a?(Float) ? result.round(2) : result\nrescue => e\n  \"ERROR: #{e.message}\"\nend\n\ndef resolve_cross_table_reference(field_ref, record_instance)\n  lookup_column_name, target_field = field_ref.split('.')\n\n  # Get related record via association\n  related_record = record_instance.send(lookup_column_name.to_sym)\n  return 0 unless related_record\n\n  related_record.send(target_field.to_sym) || 0\nend\n\n# ---\n\n# app/models/column.rb\nbefore_save :detect_cross_table_references, if: -> { column_type == 'computed' }\n\ndef detect_cross_table_references\n  formula = settings&.dig('formula') || ''\n  self.has_cross_table_refs = FormulaEvaluator.uses_cross_table_references?(formula)\nend\n\n# app/services/formula_evaluator.rb\ndef self.uses_cross_table_references?(formula_expression)\n  formula_expression.match?(/\\{[^}]+\\.[^}]+\\}/)\nend TRAPID_BIBLE.md RULE #18.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "optimization",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.3",
    "difficulty": "beginner",
    "summary": "",
    "code_example": "# Valid formula examples:\n\"{quantity} * {unit_price}\"                    # Simple calculation\n\"({cost} + {tax}) * {quantity}\"                # Grouping\n\"{amount} / {units}\"                           # Division with decimal result\n\"{supplier.tax_rate} * {amount}\"               # Cross-table lookup\n\"IF({quantity} > 100, {bulk_price}, {unit_price})\" # Conditional (Dentaku function)\n\n# ---\n\n# app/services/formula_evaluator.rb\ndef evaluate(formula_expression, record_data, record_instance = nil)\n  # Step 1: Replace {field_name} with variable placeholders\n  variables = {}\n  processed_formula = formula_expression.gsub(/\\{([^}]+)\\}/) do |match|\n    field_ref = $1\n\n    if field_ref.include?('.')\n      # Cross-table reference: {lookup_column.target_field}\n      value = resolve_cross_table_reference(field_ref, record_instance)\n    else\n      # Direct field reference\n      value = record_data[field_ref] || 0\n    end\n\n    var_name = field_ref.gsub('.', '_')\n    variables[var_name] = value.to_f\n    var_name\n  end\n\n  # Step 2: Evaluate with Dentaku\n  calculator = Dentaku::Calculator.new\n  result = calculator.evaluate(processed_formula, variables)\n\n  # Step 3: Round floats to 2 decimals\n  result.is_a?(Float) ? result.round(2) : result\nrescue => e\n  \"ERROR: #{e.message}\"\nend\n\ndef resolve_cross_table_reference(field_ref, record_instance)\n  lookup_column_name, target_field = field_ref.split('.')\n\n  # Get related record via association\n  related_record = record_instance.send(lookup_column_name.to_sym)\n  return 0 unless related_record\n\n  related_record.send(target_field.to_sym) || 0\nend\n\n# ---\n\n# app/models/column.rb\nbefore_save :detect_cross_table_references, if: -> { column_type == 'computed' }\n\ndef detect_cross_table_references\n  formula = settings&.dig('formula') || ''\n  self.has_cross_table_refs = FormulaEvaluator.uses_cross_table_references?(formula)\nend\n\n# app/services/formula_evaluator.rb\ndef self.uses_cross_table_references?(formula_expression)\n  formula_expression.match?(/\\{[^}]+\\.[^}]+\\}/)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.3"
  },
  {
    "id": 199,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Email Ingestion Storage",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Email Ingestion Storage util  # app/models/email.rb\nclass Email < ApplicationRecord\n  belongs_to :construction, optional: true\n  belongs_to :user, optional: true\n\n  validates :from_email, :subject, :body, presence: true\n  validates :message_id, uniqueness: true, allow_nil: true\n\n  scope :recent, -> { order(received_at: :desc) }\n  scope :for_construction, ->(construction_id) {\n    where(construction_id: construction_id).order(received_at: :desc)\n  }\n  scope :unassigned, -> { where(construction_id: nil) }\n  scope :with_attachments, -> { where(has_attachments: true) }\n\n  def formatted_received_at\n    return 'N/A' unless received_at\n    received_at.strftime('%b %d, %Y %I:%M %p')\n  end\n\n  def short_subject\n    return 'No Subject' if subject.blank?\n    subject.length > 50 ? \"#{subject[0..47]}...\" : subject\n  end\nend\n\n# ---\n\n# db/schema.rb (emails table)\ncreate_table :emails do |t|\n  t.references :construction, foreign_key: true, null: true\n  t.references :user, foreign_key: true, null: true\n  t.string :from_email, null: false\n  t.json :to_emails, default: []\n  t.json :cc_emails, default: []\n  t.json :bcc_emails, default: []\n  t.string :subject\n  t.text :body\n  t.datetime :received_at\n  t.string :message_id # Microsoft Graph message ID\n  t.boolean :has_attachments, default: false\n  t.timestamps\nend\n\nadd_index :emails, :message_id, unique: true\nadd_index :emails, :construction_id TRAPID_BIBLE.md RULE #14.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.9",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/email.rb\nclass Email < ApplicationRecord\n  belongs_to :construction, optional: true\n  belongs_to :user, optional: true\n\n  validates :from_email, :subject, :body, presence: true\n  validates :message_id, uniqueness: true, allow_nil: true\n\n  scope :recent, -> { order(received_at: :desc) }\n  scope :for_construction, ->(construction_id) {\n    where(construction_id: construction_id).order(received_at: :desc)\n  }\n  scope :unassigned, -> { where(construction_id: nil) }\n  scope :with_attachments, -> { where(has_attachments: true) }\n\n  def formatted_received_at\n    return 'N/A' unless received_at\n    received_at.strftime('%b %d, %Y %I:%M %p')\n  end\n\n  def short_subject\n    return 'No Subject' if subject.blank?\n    subject.length > 50 ? \"#{subject[0..47]}...\" : subject\n  end\nend\n\n# ---\n\n# db/schema.rb (emails table)\ncreate_table :emails do |t|\n  t.references :construction, foreign_key: true, null: true\n  t.references :user, foreign_key: true, null: true\n  t.string :from_email, null: false\n  t.json :to_emails, default: []\n  t.json :cc_emails, default: []\n  t.json :bcc_emails, default: []\n  t.string :subject\n  t.text :body\n  t.datetime :received_at\n  t.string :message_id # Microsoft Graph message ID\n  t.boolean :has_attachments, default: false\n  t.timestamps\nend\n\nadd_index :emails, :message_id, unique: true\nadd_index :emails, :construction_id",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.9"
  },
  {
    "id": 200,
    "chapter_number": 14,
    "chapter_name": "Chat & Communications",
    "component": null,
    "title": "Authentication Placeholder - CRITICAL TODO",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Authentication Placeholder - CRITICAL TODO util  # app/controllers/api/v1/chat_messages_controller.rb (Line 110)\ndef set_current_user\n  @current_user = User.first # TODO: Replace with actual current_user logic\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\nbefore_action :authenticate_user!\n\ndef set_current_user\n  @current_user = current_user # From Devise or JWT auth\nend TRAPID_BIBLE.md RULE #14.10",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "14.10",
    "difficulty": "advanced",
    "summary": "",
    "code_example": "# app/controllers/api/v1/chat_messages_controller.rb (Line 110)\ndef set_current_user\n  @current_user = User.first # TODO: Replace with actual current_user logic\nend\n\n# ---\n\n# app/controllers/api/v1/chat_messages_controller.rb\nbefore_action :authenticate_user!\n\ndef set_current_user\n  @current_user = current_user # From Devise or JWT auth\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #14.10"
  },
  {
    "id": 201,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "OAuth Token Management",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "OAuth Token Management integration ✅ class XeroCredential < ApplicationRecord\n  encrypts :access_token\n  encrypts :refresh_token\n\n  def self.current\n    order(created_at: :desc).first\n  end\nend TRAPID_BIBLE.md RULE #15.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "15.1",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "class XeroCredential < ApplicationRecord\n  encrypts :access_token\n  encrypts :refresh_token\n\n  def self.current\n    order(created_at: :desc).first\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #15.1"
  },
  {
    "id": 202,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "Two-Way Contact Sync",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Two-Way Contact Sync component ✅ add_column :contacts, :xero_id, :string\nadd_column :contacts, :xero_contact_id, :string  # UUID\nadd_column :contacts, :sync_with_xero, :boolean, default: true\nadd_column :contacts, :last_synced_at, :datetime\nadd_column :contacts, :xero_sync_error, :text TRAPID_BIBLE.md RULE #15.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "15.2",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "add_column :contacts, :xero_id, :string\nadd_column :contacts, :xero_contact_id, :string  # UUID\nadd_column :contacts, :sync_with_xero, :boolean, default: true\nadd_column :contacts, :last_synced_at, :datetime\nadd_column :contacts, :xero_sync_error, :text",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #15.2"
  },
  {
    "id": 203,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "Webhook Signature Verification",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Webhook Signature Verification util ✅ def verify_xero_webhook_signature\n  signature = request.headers['X-Xero-Signature']\n  body = request.body.read\n\n  expected = Base64.strict_encode64(\n    OpenSSL::HMAC.digest('SHA256', ENV['XERO_WEBHOOK_KEY'], body)\n  )\n\n  ActiveSupport::SecurityUtils.secure_compare(signature, expected)\nend TRAPID_BIBLE.md RULE #15.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "15.4",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "def verify_xero_webhook_signature\n  signature = request.headers['X-Xero-Signature']\n  body = request.body.read\n\n  expected = Base64.strict_encode64(\n    OpenSSL::HMAC.digest('SHA256', ENV['XERO_WEBHOOK_KEY'], body)\n  )\n\n  ActiveSupport::SecurityUtils.secure_compare(signature, expected)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #15.4"
  },
  {
    "id": 204,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "Background Job Processing",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Background Job Processing util ✅ {\n  job_id: \"unique_job_id\",\n  status: \"queued\" | \"processing\" | \"completed\" | \"failed\",\n  queued_at: Time,\n  started_at: Time,\n  completed_at: Time,\n  total: Integer,\n  processed: Integer,\n  errors: Array\n} TRAPID_BIBLE.md RULE #15.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "15.7",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "{\n  job_id: \"unique_job_id\",\n  status: \"queued\" | \"processing\" | \"completed\" | \"failed\",\n  queued_at: Time,\n  started_at: Time,\n  completed_at: Time,\n  total: Integer,\n  processed: Integer,\n  errors: Array\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #15.7"
  },
  {
    "id": 205,
    "chapter_number": 15,
    "chapter_name": "Xero Accounting Integration",
    "component": null,
    "title": "Payment Sync Workflow",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Sync Workflow feature ✅ add_column :payments, :xero_payment_id, :string\nadd_column :payments, :synced_to_xero_at, :datetime TRAPID_BIBLE.md RULE #15.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "15.8",
    "difficulty": "intermediate",
    "summary": "✅",
    "code_example": "add_column :payments, :xero_payment_id, :string\nadd_column :payments, :synced_to_xero_at, :datetime",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #15.8"
  },
  {
    "id": 206,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Payment Model Structure",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Model Structure feature  # app/models/payment.rb\nclass Payment < ApplicationRecord\n  belongs_to :purchase_order\n  belongs_to :created_by, class_name: 'User', foreign_key: 'created_by_id'\n\n  validates :amount, presence: true, numericality: { greater_than: 0 }\n  validates :payment_date, presence: true\n  validates :payment_method, inclusion: {\n    in: %w[bank_transfer check credit_card cash eft other],\n    allow_nil: true\n  }\n\n  scope :by_purchase_order, ->(po_id) { where(purchase_order_id: po_id).order(payment_date: :desc) }\n  scope :synced_to_xero, -> { where.not(xero_payment_id: nil) }\n  scope :sync_failed, -> { where.not(xero_sync_error: nil) }\n\n  after_save :update_purchase_order_payment_status\n  after_destroy :update_purchase_order_payment_status\nend\n\n# ---\n\n# db/migrate/20251112213631_create_payments.rb\ncreate_table :payments do |t|\n  t.references :purchase_order, null: false, foreign_key: true\n  t.decimal :amount, precision: 15, scale: 2, null: false\n  t.date :payment_date, null: false\n  t.string :payment_method\n  t.string :reference_number\n  t.text :notes\n  t.string :xero_payment_id\n  t.datetime :xero_synced_at\n  t.text :xero_sync_error\n  t.references :created_by, foreign_key: { to_table: :users }\n  t.timestamps\nend\n\nadd_index :payments, :payment_date\nadd_index :payments, [:purchase_order_id, :payment_date]\nadd_index :payments, :xero_payment_id TRAPID_BIBLE.md RULE #16.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/payment.rb\nclass Payment < ApplicationRecord\n  belongs_to :purchase_order\n  belongs_to :created_by, class_name: 'User', foreign_key: 'created_by_id'\n\n  validates :amount, presence: true, numericality: { greater_than: 0 }\n  validates :payment_date, presence: true\n  validates :payment_method, inclusion: {\n    in: %w[bank_transfer check credit_card cash eft other],\n    allow_nil: true\n  }\n\n  scope :by_purchase_order, ->(po_id) { where(purchase_order_id: po_id).order(payment_date: :desc) }\n  scope :synced_to_xero, -> { where.not(xero_payment_id: nil) }\n  scope :sync_failed, -> { where.not(xero_sync_error: nil) }\n\n  after_save :update_purchase_order_payment_status\n  after_destroy :update_purchase_order_payment_status\nend\n\n# ---\n\n# db/migrate/20251112213631_create_payments.rb\ncreate_table :payments do |t|\n  t.references :purchase_order, null: false, foreign_key: true\n  t.decimal :amount, precision: 15, scale: 2, null: false\n  t.date :payment_date, null: false\n  t.string :payment_method\n  t.string :reference_number\n  t.text :notes\n  t.string :xero_payment_id\n  t.datetime :xero_synced_at\n  t.text :xero_sync_error\n  t.references :created_by, foreign_key: { to_table: :users }\n  t.timestamps\nend\n\nadd_index :payments, :payment_date\nadd_index :payments, [:purchase_order_id, :payment_date]\nadd_index :payments, :xero_payment_id",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.1"
  },
  {
    "id": 207,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Automatic Payment Status Updates",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Automatic Payment Status Updates util  # app/models/payment.rb\nafter_save :update_purchase_order_payment_status\nafter_destroy :update_purchase_order_payment_status\n\nprivate\n\ndef update_purchase_order_payment_status\n  po = purchase_order\n  total_paid = po.payments.sum(:amount)\n\n  po.update!(\n    xero_amount_paid: total_paid,\n    xero_complete: total_paid >= po.total,\n    xero_still_to_be_paid: [po.total - total_paid, 0].max\n  )\n\n  # Update payment_status enum\n  po.update_payment_status_from_payments!\nend\n\n# ---\n\n# app/models/purchase_order.rb\nenum payment_status: {\n  pending: 'pending',\n  part_payment: 'part_payment',\n  complete: 'complete',\n  manual_review: 'manual_review'\n}\n\ndef update_payment_status_from_payments!\n  total_paid = payments.sum(:amount)\n  percentage = (total_paid / total) * 100\n\n  new_status = if percentage >= 95 && percentage <= 105\n    'complete'\n  elsif percentage > 105\n    'manual_review'\n  elsif total_paid > 0\n    'part_payment'\n  else\n    'pending'\n  end\n\n  update!(payment_status: new_status)\nend TRAPID_BIBLE.md RULE #16.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/payment.rb\nafter_save :update_purchase_order_payment_status\nafter_destroy :update_purchase_order_payment_status\n\nprivate\n\ndef update_purchase_order_payment_status\n  po = purchase_order\n  total_paid = po.payments.sum(:amount)\n\n  po.update!(\n    xero_amount_paid: total_paid,\n    xero_complete: total_paid >= po.total,\n    xero_still_to_be_paid: [po.total - total_paid, 0].max\n  )\n\n  # Update payment_status enum\n  po.update_payment_status_from_payments!\nend\n\n# ---\n\n# app/models/purchase_order.rb\nenum payment_status: {\n  pending: 'pending',\n  part_payment: 'part_payment',\n  complete: 'complete',\n  manual_review: 'manual_review'\n}\n\ndef update_payment_status_from_payments!\n  total_paid = payments.sum(:amount)\n  percentage = (total_paid / total) * 100\n\n  new_status = if percentage >= 95 && percentage <= 105\n    'complete'\n  elsif percentage > 105\n    'manual_review'\n  elsif total_paid > 0\n    'part_payment'\n  else\n    'pending'\n  end\n\n  update!(payment_status: new_status)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.2"
  },
  {
    "id": 208,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Xero Invoice Fuzzy Matching",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Xero Invoice Fuzzy Matching feature  # app/services/invoice_matching_service.rb\nclass InvoiceMatchingService\n  def match_invoice_to_po(xero_invoice, po_id_hint: nil)\n    # Strategy 1: Explicit PO ID provided\n    return PurchaseOrder.find(po_id_hint) if po_id_hint.present?\n\n    po_number = extract_po_number(xero_invoice)\n\n    # Strategy 2: Reference field (most reliable)\n    if xero_invoice['Reference'].present?\n      po = match_by_reference(xero_invoice['Reference'])\n      return po if po\n    end\n\n    # Strategy 3: InvoiceNumber field\n    if xero_invoice['InvoiceNumber'].present?\n      po = match_by_invoice_number(xero_invoice['InvoiceNumber'])\n      return po if po\n    end\n\n    # Strategy 4: LineItems description\n    po = match_by_line_items(xero_invoice['LineItems'])\n    return po if po\n\n    # Strategy 5: Normalized PO number (handles zero-padding)\n    po = match_by_normalized_po_number(po_number)\n    return po if po\n\n    # Strategy 6: Supplier + amount fallback\n    match_by_supplier_and_amount(\n      xero_invoice['Contact']['Name'],\n      xero_invoice['Total'],\n      tolerance: 0.10\n    )\n  end\n\n  private\n\n  def extract_po_number(xero_invoice)\n    text = [\n      xero_invoice['Reference'],\n      xero_invoice['InvoiceNumber'],\n      xero_invoice['LineItems']&.map { |li| li['Description'] }&.join(' ')\n    ].compact.join(' ')\n\n    # Patterns: PO-123, P.O. 123, P/O 123, Purchase Order 123\n    if text =~ /\\b(?:PO|P\\.O\\.|P\\/O|Purchase Order)\\s*[:-]?\\s*(\\d+)/i\n      $1.to_i\n    end\n  end\n\n  def match_by_normalized_po_number(po_number)\n    return nil unless po_number\n\n    # Try exact match\n    po = PurchaseOrder.find_by(po_number: po_number)\n    return po if po\n\n    # Try normalized (strip leading zeros)\n    normalized = po_number.to_s.gsub(/^0+/, '')\n    PurchaseOrder.where(\"CAST(po_number AS TEXT) LIKE ?\", \"%#{normalized}\").first\n  end\nend\n\n# ---\n\n# app/models/purchase_order.rb\ndef apply_invoice!(invoice_amount:, invoice_date:, invoice_reference:)\n  update!(\n    invoiced_amount: invoice_amount,\n    invoice_date: invoice_date,\n    invoice_reference: invoice_reference,\n    payment_status: determine_payment_status(invoice_amount)\n  )\nend\n\ndef determine_payment_status(invoice_amount)\n  percentage = (invoice_amount / total) * 100\n\n  if percentage >= 95 && percentage <= 105\n    'complete'\n  elsif percentage > 105 && (invoice_amount - total) > 1.00\n    'manual_review' # Overage >$1 needs review\n  elsif percentage < 95\n    'part_payment'\n  else\n    'pending'\n  end\nend TRAPID_BIBLE.md RULE #16.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/invoice_matching_service.rb\nclass InvoiceMatchingService\n  def match_invoice_to_po(xero_invoice, po_id_hint: nil)\n    # Strategy 1: Explicit PO ID provided\n    return PurchaseOrder.find(po_id_hint) if po_id_hint.present?\n\n    po_number = extract_po_number(xero_invoice)\n\n    # Strategy 2: Reference field (most reliable)\n    if xero_invoice['Reference'].present?\n      po = match_by_reference(xero_invoice['Reference'])\n      return po if po\n    end\n\n    # Strategy 3: InvoiceNumber field\n    if xero_invoice['InvoiceNumber'].present?\n      po = match_by_invoice_number(xero_invoice['InvoiceNumber'])\n      return po if po\n    end\n\n    # Strategy 4: LineItems description\n    po = match_by_line_items(xero_invoice['LineItems'])\n    return po if po\n\n    # Strategy 5: Normalized PO number (handles zero-padding)\n    po = match_by_normalized_po_number(po_number)\n    return po if po\n\n    # Strategy 6: Supplier + amount fallback\n    match_by_supplier_and_amount(\n      xero_invoice['Contact']['Name'],\n      xero_invoice['Total'],\n      tolerance: 0.10\n    )\n  end\n\n  private\n\n  def extract_po_number(xero_invoice)\n    text = [\n      xero_invoice['Reference'],\n      xero_invoice['InvoiceNumber'],\n      xero_invoice['LineItems']&.map { |li| li['Description'] }&.join(' ')\n    ].compact.join(' ')\n\n    # Patterns: PO-123, P.O. 123, P/O 123, Purchase Order 123\n    if text =~ /\\b(?:PO|P\\.O\\.|P\\/O|Purchase Order)\\s*[:-]?\\s*(\\d+)/i\n      $1.to_i\n    end\n  end\n\n  def match_by_normalized_po_number(po_number)\n    return nil unless po_number\n\n    # Try exact match\n    po = PurchaseOrder.find_by(po_number: po_number)\n    return po if po\n\n    # Try normalized (strip leading zeros)\n    normalized = po_number.to_s.gsub(/^0+/, '')\n    PurchaseOrder.where(\"CAST(po_number AS TEXT) LIKE ?\", \"%#{normalized}\").first\n  end\nend\n\n# ---\n\n# app/models/purchase_order.rb\ndef apply_invoice!(invoice_amount:, invoice_date:, invoice_reference:)\n  update!(\n    invoiced_amount: invoice_amount,\n    invoice_date: invoice_date,\n    invoice_reference: invoice_reference,\n    payment_status: determine_payment_status(invoice_amount)\n  )\nend\n\ndef determine_payment_status(invoice_amount)\n  percentage = (invoice_amount / total) * 100\n\n  if percentage >= 95 && percentage <= 105\n    'complete'\n  elsif percentage > 105 && (invoice_amount - total) > 1.00\n    'manual_review' # Overage >$1 needs review\n  elsif percentage < 95\n    'part_payment'\n  else\n    'pending'\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.3"
  },
  {
    "id": 209,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Xero Payment Sync",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Xero Payment Sync feature  # app/services/xero_payment_sync_service.rb\nclass XeroPaymentSyncService\n  def self.sync_payment(payment)\n    new(payment).sync\n  end\n\n  def initialize(payment)\n    @payment = payment\n    @po = payment.purchase_order\n  end\n\n  def sync\n    validate_xero_invoice!\n\n    payload = build_payment_payload\n    response = xero_client.create_payment(payload)\n\n    @payment.mark_synced!(response['PaymentID'])\n    { success: true, xero_payment_id: response['PaymentID'] }\n  rescue => e\n    @payment.mark_sync_failed!(e.message)\n    { success: false, error: e.message }\n  end\n\n  private\n\n  def validate_xero_invoice!\n    raise \"PO must have xero_invoice_id before syncing payments\" unless @po.xero_invoice_id.present?\n  end\n\n  def build_payment_payload\n    {\n      Invoice: { InvoiceID: @po.xero_invoice_id },\n      Account: { Code: bank_account_code },\n      Date: @payment.payment_date.strftime('%Y-%m-%d'),\n      Amount: @payment.amount.to_f,\n      Reference: @payment.reference_number || \"Payment for PO #{@po.po_number}\"\n    }\n  end\n\n  def xero_client\n    @xero_client ||= XeroApiClient.new\n  end\n\n  def bank_account_code\n    '091' # Default bank account code\n  end\nend\n\n# app/models/payment.rb\ndef mark_synced!(xero_id)\n  update!(\n    xero_payment_id: xero_id,\n    xero_synced_at: Time.current,\n    xero_sync_error: nil\n  )\nend\n\ndef mark_sync_failed!(error_message)\n  update!(xero_sync_error: error_message)\nend\n\ndef synced_to_xero?\n  xero_payment_id.present?\nend\n\ndef sync_error?\n  xero_sync_error.present?\nend TRAPID_BIBLE.md RULE #16.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/xero_payment_sync_service.rb\nclass XeroPaymentSyncService\n  def self.sync_payment(payment)\n    new(payment).sync\n  end\n\n  def initialize(payment)\n    @payment = payment\n    @po = payment.purchase_order\n  end\n\n  def sync\n    validate_xero_invoice!\n\n    payload = build_payment_payload\n    response = xero_client.create_payment(payload)\n\n    @payment.mark_synced!(response['PaymentID'])\n    { success: true, xero_payment_id: response['PaymentID'] }\n  rescue => e\n    @payment.mark_sync_failed!(e.message)\n    { success: false, error: e.message }\n  end\n\n  private\n\n  def validate_xero_invoice!\n    raise \"PO must have xero_invoice_id before syncing payments\" unless @po.xero_invoice_id.present?\n  end\n\n  def build_payment_payload\n    {\n      Invoice: { InvoiceID: @po.xero_invoice_id },\n      Account: { Code: bank_account_code },\n      Date: @payment.payment_date.strftime('%Y-%m-%d'),\n      Amount: @payment.amount.to_f,\n      Reference: @payment.reference_number || \"Payment for PO #{@po.po_number}\"\n    }\n  end\n\n  def xero_client\n    @xero_client ||= XeroApiClient.new\n  end\n\n  def bank_account_code\n    '091' # Default bank account code\n  end\nend\n\n# app/models/payment.rb\ndef mark_synced!(xero_id)\n  update!(\n    xero_payment_id: xero_id,\n    xero_synced_at: Time.current,\n    xero_sync_error: nil\n  )\nend\n\ndef mark_sync_failed!(error_message)\n  update!(xero_sync_error: error_message)\nend\n\ndef synced_to_xero?\n  xero_payment_id.present?\nend\n\ndef sync_error?\n  xero_sync_error.present?\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.4"
  },
  {
    "id": 210,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Payment Method Enum",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Method Enum component  # app/models/payment.rb\nPAYMENT_METHODS = %w[bank_transfer check credit_card cash eft other].freeze\n\nvalidates :payment_method, inclusion: {\n  in: PAYMENT_METHODS,\n  allow_nil: true,\n  message: \"%{value} is not a valid payment method\"\n}\n\ndef payment_method_label\n  return 'Not Specified' if payment_method.blank?\n\n  case payment_method\n  when 'bank_transfer' then 'Bank Transfer'\n  when 'check' then 'Check'\n  when 'credit_card' then 'Credit Card'\n  when 'cash' then 'Cash'\n  when 'eft' then 'EFT'\n  when 'other' then 'Other'\n  end\nend\n\n# ---\n\n// frontend/src/components/purchase-orders/NewPaymentModal.jsx\nconst PAYMENT_METHODS = [\n  { value: 'bank_transfer', label: 'Bank Transfer' },\n  { value: 'eft', label: 'EFT' },\n  { value: 'check', label: 'Check' },\n  { value: 'credit_card', label: 'Credit Card' },\n  { value: 'cash', label: 'Cash' },\n  { value: 'other', label: 'Other' }\n];\n\n<select\n  value={formData.payment_method}\n  onChange={(e) => setFormData({ ...formData, payment_method: e.target.value })}\n  className=\"w-full px-3 py-2 border rounded-md\"\n>\n  <option value=\"\">Select method...</option>\n  {PAYMENT_METHODS.map(method => (\n    <option key={method.value} value={method.value}>\n      {method.label}\n    </option>\n  ))}\n</select> TRAPID_BIBLE.md RULE #16.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.5",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/payment.rb\nPAYMENT_METHODS = %w[bank_transfer check credit_card cash eft other].freeze\n\nvalidates :payment_method, inclusion: {\n  in: PAYMENT_METHODS,\n  allow_nil: true,\n  message: \"%{value} is not a valid payment method\"\n}\n\ndef payment_method_label\n  return 'Not Specified' if payment_method.blank?\n\n  case payment_method\n  when 'bank_transfer' then 'Bank Transfer'\n  when 'check' then 'Check'\n  when 'credit_card' then 'Credit Card'\n  when 'cash' then 'Cash'\n  when 'eft' then 'EFT'\n  when 'other' then 'Other'\n  end\nend\n\n# ---\n\n// frontend/src/components/purchase-orders/NewPaymentModal.jsx\nconst PAYMENT_METHODS = [\n  { value: 'bank_transfer', label: 'Bank Transfer' },\n  { value: 'eft', label: 'EFT' },\n  { value: 'check', label: 'Check' },\n  { value: 'credit_card', label: 'Credit Card' },\n  { value: 'cash', label: 'Cash' },\n  { value: 'other', label: 'Other' }\n];\n\n<select\n  value={formData.payment_method}\n  onChange={(e) => setFormData({ ...formData, payment_method: e.target.value })}\n  className=\"w-full px-3 py-2 border rounded-md\"\n>\n  <option value=\"\">Select method...</option>\n  {PAYMENT_METHODS.map(method => (\n    <option key={method.value} value={method.value}>\n      {method.label}\n    </option>\n  ))}\n</select>",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.5"
  },
  {
    "id": 211,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Financial Precision with DECIMAL(15,2)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Financial Precision with DECIMAL(15,2) util  # Payments table\nt.decimal :amount, precision: 15, scale: 2, null: false\n\n# Purchase orders table\nt.decimal :total, precision: 15, scale: 2, default: 0.0\nt.decimal :invoiced_amount, precision: 15, scale: 2, default: 0.0\nt.decimal :xero_amount_paid, precision: 15, scale: 2, default: 0.0\nt.decimal :xero_still_to_be_paid, precision: 15, scale: 2, default: 0.0\nt.decimal :amount_still_to_be_invoiced, precision: 15, scale: 2, default: 0.0\nt.decimal :budget, precision: 15, scale: 2\n\n# ---\n\n# app/models/payment.rb\nvalidates :amount, numericality: {\n  greater_than: 0,\n  less_than_or_equal_to: 999_999_999_999.99\n}\n\n# app/models/purchase_order.rb\nvalidates :total, :invoiced_amount, :xero_amount_paid,\n  numericality: { greater_than_or_equal_to: 0 } TRAPID_BIBLE.md RULE #16.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# Payments table\nt.decimal :amount, precision: 15, scale: 2, null: false\n\n# Purchase orders table\nt.decimal :total, precision: 15, scale: 2, default: 0.0\nt.decimal :invoiced_amount, precision: 15, scale: 2, default: 0.0\nt.decimal :xero_amount_paid, precision: 15, scale: 2, default: 0.0\nt.decimal :xero_still_to_be_paid, precision: 15, scale: 2, default: 0.0\nt.decimal :amount_still_to_be_invoiced, precision: 15, scale: 2, default: 0.0\nt.decimal :budget, precision: 15, scale: 2\n\n# ---\n\n# app/models/payment.rb\nvalidates :amount, numericality: {\n  greater_than: 0,\n  less_than_or_equal_to: 999_999_999_999.99\n}\n\n# app/models/purchase_order.rb\nvalidates :total, :invoiced_amount, :xero_amount_paid,\n  numericality: { greater_than_or_equal_to: 0 }",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.6"
  },
  {
    "id": 212,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Payment Status Badge Display",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Status Badge Display component  // frontend/src/components/purchase-orders/PaymentStatusBadge.jsx\nconst STATUS_CONFIG = {\n  pending: {\n    label: 'Pending',\n    color: 'gray',\n    icon: HourglassIcon\n  },\n  part_payment: {\n    label: 'Partial Payment',\n    color: 'yellow',\n    icon: CircleDotIcon\n  },\n  complete: {\n    label: 'Paid',\n    color: 'green',\n    icon: CheckCircleIcon\n  },\n  manual_review: {\n    label: 'Needs Review',\n    color: 'red',\n    icon: ExclamationTriangleIcon\n  }\n};\n\nexport function PaymentStatusBadge({ status }) {\n  const config = STATUS_CONFIG[status] || STATUS_CONFIG.pending;\n  const Icon = config.icon;\n\n  return (\n    <Badge variant={config.color}>\n      <Icon className=\"w-4 h-4 mr-1\" />\n      {config.label}\n    </Badge>\n  );\n} TRAPID_BIBLE.md RULE #16.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "// frontend/src/components/purchase-orders/PaymentStatusBadge.jsx\nconst STATUS_CONFIG = {\n  pending: {\n    label: 'Pending',\n    color: 'gray',\n    icon: HourglassIcon\n  },\n  part_payment: {\n    label: 'Partial Payment',\n    color: 'yellow',\n    icon: CircleDotIcon\n  },\n  complete: {\n    label: 'Paid',\n    color: 'green',\n    icon: CheckCircleIcon\n  },\n  manual_review: {\n    label: 'Needs Review',\n    color: 'red',\n    icon: ExclamationTriangleIcon\n  }\n};\n\nexport function PaymentStatusBadge({ status }) {\n  const config = STATUS_CONFIG[status] || STATUS_CONFIG.pending;\n  const Icon = config.icon;\n\n  return (\n    <Badge variant={config.color}>\n      <Icon className=\"w-4 h-4 mr-1\" />\n      {config.label}\n    </Badge>\n  );\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.7"
  },
  {
    "id": 213,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Payment Summary Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Payment Summary Calculation integration  # app/controllers/api/v1/payments_controller.rb\ndef index\n  @purchase_order = PurchaseOrder.find(params[:purchase_order_id])\n  @payments = @purchase_order.payments.order(payment_date: :desc)\n\n  total_paid = @payments.sum(:amount)\n  remaining = [@purchase_order.total - total_paid, 0].max\n\n  render json: {\n    success: true,\n    payments: @payments.as_json(include: [:created_by]),\n    summary: {\n      total_paid: total_paid,\n      po_total: @purchase_order.total,\n      remaining: remaining,\n      payment_status: @purchase_order.payment_status\n    }\n  }\nend\n\n# ---\n\n// frontend/src/components/purchase-orders/PaymentsList.jsx\n<div className=\"bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-4\">\n  <div className=\"grid grid-cols-3 gap-4 text-center\">\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">PO Total</p>\n      <p className=\"text-xl font-bold\">${summary.po_total.toFixed(2)}</p>\n    </div>\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">Total Paid</p>\n      <p className=\"text-xl font-bold text-green-600\">${summary.total_paid.toFixed(2)}</p>\n    </div>\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">Remaining</p>\n      <p className=\"text-xl font-bold text-red-600\">${summary.remaining.toFixed(2)}</p>\n    </div>\n  </div>\n</div> TRAPID_BIBLE.md RULE #16.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/payments_controller.rb\ndef index\n  @purchase_order = PurchaseOrder.find(params[:purchase_order_id])\n  @payments = @purchase_order.payments.order(payment_date: :desc)\n\n  total_paid = @payments.sum(:amount)\n  remaining = [@purchase_order.total - total_paid, 0].max\n\n  render json: {\n    success: true,\n    payments: @payments.as_json(include: [:created_by]),\n    summary: {\n      total_paid: total_paid,\n      po_total: @purchase_order.total,\n      remaining: remaining,\n      payment_status: @purchase_order.payment_status\n    }\n  }\nend\n\n# ---\n\n// frontend/src/components/purchase-orders/PaymentsList.jsx\n<div className=\"bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-4\">\n  <div className=\"grid grid-cols-3 gap-4 text-center\">\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">PO Total</p>\n      <p className=\"text-xl font-bold\">${summary.po_total.toFixed(2)}</p>\n    </div>\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">Total Paid</p>\n      <p className=\"text-xl font-bold text-green-600\">${summary.total_paid.toFixed(2)}</p>\n    </div>\n    <div>\n      <p className=\"text-sm text-gray-600 dark:text-gray-400\">Remaining</p>\n      <p className=\"text-xl font-bold text-red-600\">${summary.remaining.toFixed(2)}</p>\n    </div>\n  </div>\n</div>",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.8"
  },
  {
    "id": 214,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Budget Variance Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Budget Variance Tracking component  # app/models/purchase_order.rb\n# Schema fields:\n# - budget (decimal 15,2) - Planned budget\n# - diff_po_with_allowance_versus_budget - PO total vs budget\n# - xero_budget_diff - Actual paid vs budget\n\ndef update_budget_variances!\n  return unless budget.present?\n\n  # PO vs Budget\n  po_variance = total - budget\n  update!(diff_po_with_allowance_versus_budget: po_variance)\n\n  # Actual vs Budget\n  actual_variance = xero_amount_paid - budget\n  update!(xero_budget_diff: actual_variance)\nend\n\ndef over_budget?\n  budget.present? && total > budget\nend\n\ndef budget_utilization_percentage\n  return 0 unless budget.present? && budget > 0\n  (total / budget * 100).round(2)\nend\n\n# ---\n\n// frontend/src/pages/PurchaseOrderDetailPage.jsx\n{po.budget && (\n  <div className={cn(\n    \"p-4 rounded-lg\",\n    po.total > po.budget ? \"bg-red-50 dark:bg-red-900/20\" : \"bg-green-50 dark:bg-green-900/20\"\n  )}>\n    <p className=\"text-sm font-medium\">Budget: ${po.budget.toFixed(2)}</p>\n    <p className=\"text-sm\">Actual: ${po.total.toFixed(2)}</p>\n    <p className={cn(\n      \"text-sm font-bold\",\n      po.total > po.budget ? \"text-red-600\" : \"text-green-600\"\n    )}>\n      Variance: ${(po.total - po.budget).toFixed(2)}\n    </p>\n  </div>\n)} TRAPID_BIBLE.md RULE #16.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.9",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/purchase_order.rb\n# Schema fields:\n# - budget (decimal 15,2) - Planned budget\n# - diff_po_with_allowance_versus_budget - PO total vs budget\n# - xero_budget_diff - Actual paid vs budget\n\ndef update_budget_variances!\n  return unless budget.present?\n\n  # PO vs Budget\n  po_variance = total - budget\n  update!(diff_po_with_allowance_versus_budget: po_variance)\n\n  # Actual vs Budget\n  actual_variance = xero_amount_paid - budget\n  update!(xero_budget_diff: actual_variance)\nend\n\ndef over_budget?\n  budget.present? && total > budget\nend\n\ndef budget_utilization_percentage\n  return 0 unless budget.present? && budget > 0\n  (total / budget * 100).round(2)\nend\n\n# ---\n\n// frontend/src/pages/PurchaseOrderDetailPage.jsx\n{po.budget && (\n  <div className={cn(\n    \"p-4 rounded-lg\",\n    po.total > po.budget ? \"bg-red-50 dark:bg-red-900/20\" : \"bg-green-50 dark:bg-green-900/20\"\n  )}>\n    <p className=\"text-sm font-medium\">Budget: ${po.budget.toFixed(2)}</p>\n    <p className=\"text-sm\">Actual: ${po.total.toFixed(2)}</p>\n    <p className={cn(\n      \"text-sm font-bold\",\n      po.total > po.budget ? \"text-red-600\" : \"text-green-600\"\n    )}>\n      Variance: ${(po.total - po.budget).toFixed(2)}\n    </p>\n  </div>\n)}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.9"
  },
  {
    "id": 215,
    "chapter_number": 16,
    "chapter_name": "Payments & Financials",
    "component": null,
    "title": "Cascade Delete Payments",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Cascade Delete Payments util  # app/models/purchase_order.rb\nhas_many :payments, dependent: :destroy\n\n# Migration\nadd_foreign_key :payments, :purchase_orders, on_delete: :cascade TRAPID_BIBLE.md RULE #16.10",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "16.10",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/purchase_order.rb\nhas_many :payments, dependent: :destroy\n\n# Migration\nadd_foreign_key :payments, :purchase_orders, on_delete: :cascade",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #16.10"
  },
  {
    "id": 216,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Solid Queue Background Job System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Solid Queue Background Job System util  # config/solid_queue.yml\nproduction:\n  dispatchers:\n    - polling_interval: 1\n      batch_size: 500\n  workers:\n    - queues: \"*\"\n      threads: 3\n      processes: 1\n      polling_interval: 0.1\n  recurring_tasks:\n    - key: apply_price_updates\n      class_name: ApplyPriceUpdatesJob\n      schedule: every day at midnight\n\n# ---\n\n# app/jobs/application_job.rb\nclass ApplicationJob < ActiveJob::Base\n  retry_on ActiveRecord::Deadlocked, wait: :exponentially_longer, attempts: 5\n  retry_on Net::ReadTimeout, wait: 5.seconds, attempts: 3\n  retry_on Errno::ECONNREFUSED, wait: 10.seconds, attempts: 3\n\n  discard_on ActiveJob::DeserializationError\n\n  rescue_from(StandardError) do |exception|\n    Rails.logger.error \"Job failed: #{exception.class} - #{exception.message}\"\n    Rails.logger.error exception.backtrace.join(\"\\n\")\n    # TODO: Send to error tracking (Sentry/Rollbar)\n  end\nend TRAPID_BIBLE.md RULE #17.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# config/solid_queue.yml\nproduction:\n  dispatchers:\n    - polling_interval: 1\n      batch_size: 500\n  workers:\n    - queues: \"*\"\n      threads: 3\n      processes: 1\n      polling_interval: 0.1\n  recurring_tasks:\n    - key: apply_price_updates\n      class_name: ApplyPriceUpdatesJob\n      schedule: every day at midnight\n\n# ---\n\n# app/jobs/application_job.rb\nclass ApplicationJob < ActiveJob::Base\n  retry_on ActiveRecord::Deadlocked, wait: :exponentially_longer, attempts: 5\n  retry_on Net::ReadTimeout, wait: 5.seconds, attempts: 3\n  retry_on Errno::ECONNREFUSED, wait: 10.seconds, attempts: 3\n\n  discard_on ActiveJob::DeserializationError\n\n  rescue_from(StandardError) do |exception|\n    Rails.logger.error \"Job failed: #{exception.class} - #{exception.message}\"\n    Rails.logger.error exception.backtrace.join(\"\\n\")\n    # TODO: Send to error tracking (Sentry/Rollbar)\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.1"
  },
  {
    "id": 217,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Workflow State Machine",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Workflow State Machine util  # app/models/workflow_instance.rb\nenum status: {\n  pending: 'pending',\n  in_progress: 'in_progress',\n  completed: 'completed',\n  rejected: 'rejected',\n  cancelled: 'cancelled'\n}\n\nafter_create :initialize_first_step\n\ndef initialize_first_step\n  first_step = workflow_definition.steps.first\n  update!(\n    status: 'in_progress',\n    current_step: first_step['name'],\n    started_at: Time.current\n  )\n  create_step(first_step)\nend\n\ndef advance!\n  next_step_config = get_next_step\n  return false unless next_step_config\n\n  update!(current_step: next_step_config['name'])\n  create_step(next_step_config)\n  true\nend\n\ndef complete!\n  update!(\n    status: 'completed',\n    completed_at: Time.current\n  )\nend\n\n# ---\n\n# app/models/workflow_step.rb\nafter_update :check_workflow_advancement, if: :saved_change_to_status?\n\ndef approve!(user:, comment: nil)\n  update!(\n    status: 'completed',\n    completed_at: Time.current,\n    comment: comment\n  )\n  workflow_instance.advance! || workflow_instance.complete!\nend\n\ndef reject!(user:, comment:)\n  update!(\n    status: 'rejected',\n    completed_at: Time.current,\n    comment: comment\n  )\n  workflow_instance.update!(status: 'rejected')\nend TRAPID_BIBLE.md RULE #17.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/workflow_instance.rb\nenum status: {\n  pending: 'pending',\n  in_progress: 'in_progress',\n  completed: 'completed',\n  rejected: 'rejected',\n  cancelled: 'cancelled'\n}\n\nafter_create :initialize_first_step\n\ndef initialize_first_step\n  first_step = workflow_definition.steps.first\n  update!(\n    status: 'in_progress',\n    current_step: first_step['name'],\n    started_at: Time.current\n  )\n  create_step(first_step)\nend\n\ndef advance!\n  next_step_config = get_next_step\n  return false unless next_step_config\n\n  update!(current_step: next_step_config['name'])\n  create_step(next_step_config)\n  true\nend\n\ndef complete!\n  update!(\n    status: 'completed',\n    completed_at: Time.current\n  )\nend\n\n# ---\n\n# app/models/workflow_step.rb\nafter_update :check_workflow_advancement, if: :saved_change_to_status?\n\ndef approve!(user:, comment: nil)\n  update!(\n    status: 'completed',\n    completed_at: Time.current,\n    comment: comment\n  )\n  workflow_instance.advance! || workflow_instance.complete!\nend\n\ndef reject!(user:, comment:)\n  update!(\n    status: 'rejected',\n    completed_at: Time.current,\n    comment: comment\n  )\n  workflow_instance.update!(status: 'rejected')\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.2"
  },
  {
    "id": 218,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Idempotent Background Jobs",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Idempotent Background Jobs util  # app/jobs/create_job_folders_job.rb\ndef perform(construction_id, template_id = nil)\n  construction = Construction.find(construction_id)\n\n  # Idempotent: Check if already created\n  if construction.onedrive_folders_created_at.present?\n    Rails.logger.info \"Folders already exist for construction #{construction.id}\"\n    return\n  end\n\n  construction.update!(onedrive_folder_creation_status: 'processing')\n\n  # ... folder creation logic\n\n  construction.update!(\n    onedrive_folders_created_at: Time.current,\n    onedrive_folder_creation_status: 'completed'\n  )\nrescue => e\n  construction.update!(onedrive_folder_creation_status: 'failed')\n  raise # Re-raise for retry\nend\n\n# ---\n\n# app/jobs/check_yesterday_rain_job.rb\ndef perform\n  yesterday = Date.yesterday\n  Construction.active.each do |construction|\n    # Idempotent: Skip if log already exists\n    next if RainLog.exists?(construction: construction, date: yesterday)\n\n    weather_data = fetch_weather(construction)\n    create_rain_log_if_rainfall(construction, yesterday, weather_data) if weather_data\n  end\nend TRAPID_BIBLE.md RULE #17.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.3",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/jobs/create_job_folders_job.rb\ndef perform(construction_id, template_id = nil)\n  construction = Construction.find(construction_id)\n\n  # Idempotent: Check if already created\n  if construction.onedrive_folders_created_at.present?\n    Rails.logger.info \"Folders already exist for construction #{construction.id}\"\n    return\n  end\n\n  construction.update!(onedrive_folder_creation_status: 'processing')\n\n  # ... folder creation logic\n\n  construction.update!(\n    onedrive_folders_created_at: Time.current,\n    onedrive_folder_creation_status: 'completed'\n  )\nrescue => e\n  construction.update!(onedrive_folder_creation_status: 'failed')\n  raise # Re-raise for retry\nend\n\n# ---\n\n# app/jobs/check_yesterday_rain_job.rb\ndef perform\n  yesterday = Date.yesterday\n  Construction.active.each do |construction|\n    # Idempotent: Skip if log already exists\n    next if RainLog.exists?(construction: construction, date: yesterday)\n\n    weather_data = fetch_weather(construction)\n    create_rain_log_if_rainfall(construction, yesterday, weather_data) if weather_data\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.3"
  },
  {
    "id": 219,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Price Update Automation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Price Update Automation util  # app/jobs/apply_price_updates_job.rb\ndef perform\n  today = Date.today\n  applicable_updates = PriceHistory.where('date_effective <= ?', today)\n    .where(applied: false)\n    .includes(:pricebook_item)\n\n  applicable_updates.each do |price_history|\n    item = price_history.pricebook_item\n\n    # Only update if this is the latest price for this date\n    latest_for_date = item.price_histories\n      .where('date_effective <= ?', today)\n      .order(date_effective: :desc)\n      .first\n\n    next unless latest_for_date.id == price_history.id\n\n    # Only update if supplier matches default\n    next unless item.default_supplier_id == price_history.supplier_id\n\n    old_price = item.current_price\n    item.update!(current_price: price_history.new_price)\n\n    price_history.update!(applied: true)\n\n    Rails.logger.info \"Applied price update for item #{item.code}: #{old_price} → #{price_history.new_price}\"\n  end\nend\n\n# ---\n\n# config/solid_queue.yml\nrecurring_tasks:\n  - key: apply_price_updates\n    class_name: ApplyPriceUpdatesJob\n    schedule: every day at midnight TRAPID_BIBLE.md RULE #17.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/jobs/apply_price_updates_job.rb\ndef perform\n  today = Date.today\n  applicable_updates = PriceHistory.where('date_effective <= ?', today)\n    .where(applied: false)\n    .includes(:pricebook_item)\n\n  applicable_updates.each do |price_history|\n    item = price_history.pricebook_item\n\n    # Only update if this is the latest price for this date\n    latest_for_date = item.price_histories\n      .where('date_effective <= ?', today)\n      .order(date_effective: :desc)\n      .first\n\n    next unless latest_for_date.id == price_history.id\n\n    # Only update if supplier matches default\n    next unless item.default_supplier_id == price_history.supplier_id\n\n    old_price = item.current_price\n    item.update!(current_price: price_history.new_price)\n\n    price_history.update!(applied: true)\n\n    Rails.logger.info \"Applied price update for item #{item.code}: #{old_price} → #{price_history.new_price}\"\n  end\nend\n\n# ---\n\n# config/solid_queue.yml\nrecurring_tasks:\n  - key: apply_price_updates\n    class_name: ApplyPriceUpdatesJob\n    schedule: every day at midnight",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.4"
  },
  {
    "id": 221,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Job Status Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Job Status Tracking util  # app/models/construction.rb\nenum onedrive_folder_creation_status: {\n  not_requested: 'not_requested',\n  pending: 'pending',\n  processing: 'processing',\n  completed: 'completed',\n  failed: 'failed'\n}\n\ndef create_folders_if_needed!(template_id = nil)\n  return unless folders_not_requested?\n  update!(onedrive_folder_creation_status: 'pending')\n  CreateJobFoldersJob.perform_later(id, template_id)\nend\n\n# ---\n\n# app/jobs/import_job.rb\ndef perform(import_session_id, table_id, column_mapping)\n  session = ImportSession.find(import_session_id)\n  session.update!(status: 'processing', progress: 0)\n\n  importer = DataImporter.new(session.file_path, column_mapping)\n\n  importer.on_progress do |processed, total|\n    progress = (processed.to_f / total * 100).round(2)\n    session.update!(progress: progress, processed_rows: processed, total_rows: total)\n  end\n\n  result = importer.import!\n  session.update!(status: 'completed', progress: 100, result: result)\nend TRAPID_BIBLE.md RULE #17.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/construction.rb\nenum onedrive_folder_creation_status: {\n  not_requested: 'not_requested',\n  pending: 'pending',\n  processing: 'processing',\n  completed: 'completed',\n  failed: 'failed'\n}\n\ndef create_folders_if_needed!(template_id = nil)\n  return unless folders_not_requested?\n  update!(onedrive_folder_creation_status: 'pending')\n  CreateJobFoldersJob.perform_later(id, template_id)\nend\n\n# ---\n\n# app/jobs/import_job.rb\ndef perform(import_session_id, table_id, column_mapping)\n  session = ImportSession.find(import_session_id)\n  session.update!(status: 'processing', progress: 0)\n\n  importer = DataImporter.new(session.file_path, column_mapping)\n\n  importer.on_progress do |processed, total|\n    progress = (processed.to_f / total * 100).round(2)\n    session.update!(progress: progress, processed_rows: processed, total_rows: total)\n  end\n\n  result = importer.import!\n  session.update!(status: 'completed', progress: 100, result: result)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.6"
  },
  {
    "id": 222,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Batch Processing with Rate Limiting",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Batch Processing with Rate Limiting integration  # app/jobs/xero_contact_sync_job.rb\nBATCH_SIZE = 10\nRATE_LIMIT_DELAY = 1.second\nMAX_RETRIES = 3\n\ndef perform\n  xero_contacts = fetch_xero_contacts\n\n  xero_contacts.in_groups_of(BATCH_SIZE, false) do |batch|\n    batch.each do |xero_contact|\n      sync_contact(xero_contact)\n      sleep(RATE_LIMIT_DELAY) # Respect API rate limits\n    end\n  end\nend\n\ndef sync_contact(xero_contact)\n  retries = 0\n  begin\n    # ... sync logic\n  rescue XeroApiClient::RateLimitError => e\n    retries += 1\n    if retries <= MAX_RETRIES\n      wait_time = 2 ** retries # Exponential backoff\n      sleep(wait_time)\n      retry\n    else\n      raise\n    end\n  end\nend TRAPID_BIBLE.md RULE #17.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/jobs/xero_contact_sync_job.rb\nBATCH_SIZE = 10\nRATE_LIMIT_DELAY = 1.second\nMAX_RETRIES = 3\n\ndef perform\n  xero_contacts = fetch_xero_contacts\n\n  xero_contacts.in_groups_of(BATCH_SIZE, false) do |batch|\n    batch.each do |xero_contact|\n      sync_contact(xero_contact)\n      sleep(RATE_LIMIT_DELAY) # Respect API rate limits\n    end\n  end\nend\n\ndef sync_contact(xero_contact)\n  retries = 0\n  begin\n    # ... sync logic\n  rescue XeroApiClient::RateLimitError => e\n    retries += 1\n    if retries <= MAX_RETRIES\n      wait_time = 2 ** retries # Exponential backoff\n      sleep(wait_time)\n      retry\n    else\n      raise\n    end\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.7"
  },
  {
    "id": 223,
    "chapter_number": 17,
    "chapter_name": "Workflows & Automation",
    "component": null,
    "title": "Workflow Metadata Storage",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Workflow Metadata Storage component  # app/models/workflow_instance.rb\n# metadata JSONB structure:\n{\n  client_details: {\n    name: string,\n    email: string,\n    phone: string,\n    address: string\n  },\n  financial_info: {\n    amount: decimal,\n    currency: string,\n    payment_terms: string\n  },\n  project_details: {\n    name: string,\n    reference: string,\n    site_address: string,\n    due_date: date,\n    priority: string\n  },\n  scope_requirements: {\n    scope: text,\n    special_requirements: text\n  },\n  references: {\n    external_reference: string,\n    onedrive_url: string\n  },\n  attachments: [\n    { filename: string, url: string, size: integer }\n  ]\n}\n\n# ---\n\n// frontend/src/components/workflows/WorkflowStartModal.jsx\nconst metadata = {\n  client_details: {\n    name: formData.clientName,\n    email: formData.clientEmail,\n    phone: formData.clientPhone,\n    address: formData.clientAddress\n  },\n  financial_info: {\n    amount: formData.amount,\n    currency: formData.currency,\n    payment_terms: formData.paymentTerms\n  },\n  // ... rest of metadata\n  attachments: attachments.map(a => ({\n    filename: a.filename,\n    url: a.url,\n    size: a.size\n  }))\n};\n\nawait api.post('/workflow_instances', {\n  workflow_type: 'purchase_order_approval',\n  subject_id: poId,\n  subject_type: 'PurchaseOrder',\n  metadata: metadata\n}); TRAPID_BIBLE.md RULE #17.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "17.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/workflow_instance.rb\n# metadata JSONB structure:\n{\n  client_details: {\n    name: string,\n    email: string,\n    phone: string,\n    address: string\n  },\n  financial_info: {\n    amount: decimal,\n    currency: string,\n    payment_terms: string\n  },\n  project_details: {\n    name: string,\n    reference: string,\n    site_address: string,\n    due_date: date,\n    priority: string\n  },\n  scope_requirements: {\n    scope: text,\n    special_requirements: text\n  },\n  references: {\n    external_reference: string,\n    onedrive_url: string\n  },\n  attachments: [\n    { filename: string, url: string, size: integer }\n  ]\n}\n\n# ---\n\n// frontend/src/components/workflows/WorkflowStartModal.jsx\nconst metadata = {\n  client_details: {\n    name: formData.clientName,\n    email: formData.clientEmail,\n    phone: formData.clientPhone,\n    address: formData.clientAddress\n  },\n  financial_info: {\n    amount: formData.amount,\n    currency: formData.currency,\n    payment_terms: formData.paymentTerms\n  },\n  // ... rest of metadata\n  attachments: attachments.map(a => ({\n    filename: a.filename,\n    url: a.url,\n    size: a.size\n  }))\n};\n\nawait api.post('/workflow_instances', {\n  workflow_type: 'purchase_order_approval',\n  subject_id: poId,\n  subject_type: 'PurchaseOrder',\n  metadata: metadata\n});",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #17.8"
  },
  {
    "id": 224,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Dynamic Table Creation Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Dynamic Table Creation Pattern feature  # app/models/table.rb\nbefore_validation :set_database_table_name, on: :create\n\ndef set_database_table_name\n  return if database_table_name.present?\n\n  safe_name = name.parameterize.underscore\n  unique_suffix = SecureRandom.hex(3)\n  self.database_table_name = \"user_#{safe_name}_#{unique_suffix}\"\nend\n\n# ---\n\n# app/models/table.rb\ndef dynamic_model\n  return @dynamic_model if @dynamic_model\n\n  class_name = name.gsub(/[^a-zA-Z0-9_]/, '').classify\n\n  @dynamic_model = Object.const_set(class_name, Class.new(ApplicationRecord) do\n    self.table_name = database_table_name\n  end)\n\n  # Auto-inject lookup associations\n  columns.where(column_type: 'lookup').each do |column|\n    inject_lookup_association(column)\n  end\n\n  @dynamic_model\nend TRAPID_BIBLE.md RULE #18.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.1",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/table.rb\nbefore_validation :set_database_table_name, on: :create\n\ndef set_database_table_name\n  return if database_table_name.present?\n\n  safe_name = name.parameterize.underscore\n  unique_suffix = SecureRandom.hex(3)\n  self.database_table_name = \"user_#{safe_name}_#{unique_suffix}\"\nend\n\n# ---\n\n# app/models/table.rb\ndef dynamic_model\n  return @dynamic_model if @dynamic_model\n\n  class_name = name.gsub(/[^a-zA-Z0-9_]/, '').classify\n\n  @dynamic_model = Object.const_set(class_name, Class.new(ApplicationRecord) do\n    self.table_name = database_table_name\n  end)\n\n  # Auto-inject lookup associations\n  columns.where(column_type: 'lookup').each do |column|\n    inject_lookup_association(column)\n  end\n\n  @dynamic_model\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.1"
  },
  {
    "id": 225,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Column Type System",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Type System feature  # Column Types → Database Types\nCOLUMN_TYPE_MAPPINGS = {\n  'single_line_text' => :string,        # VARCHAR(255)\n  'multiple_lines_text' => :text,       # TEXT\n  'email' => :string,                   # VARCHAR with email validation\n  'phone' => :string,                   # VARCHAR with phone format\n  'url' => :string,                     # VARCHAR with URL validation\n  'number' => :decimal,                 # DECIMAL(15,2)\n  'whole_number' => :integer,           # INTEGER\n  'currency' => :decimal,               # DECIMAL(15,2)\n  'percentage' => :decimal,             # DECIMAL(15,2)\n  'date' => :date,                      # DATE\n  'date_and_time' => :datetime,         # TIMESTAMP\n  'boolean' => :boolean,                # BOOLEAN\n  'choice' => :string,                  # VARCHAR (single select)\n  'lookup' => :integer,                 # INTEGER (foreign key)\n  'multiple_lookups' => :text,          # TEXT (JSON array)\n  'user' => :integer,                   # INTEGER (FK to users)\n  'computed' => :string                 # VARCHAR (formula result)\n}\n\n# ---\n\n# app/services/table_builder.rb\ndef add_column(column)\n  db_type = COLUMN_TYPE_MAPPINGS[column.column_type]\n\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.add_column(\n      table.database_table_name,\n      column.column_name,\n      db_type,\n      **column_options(column)\n    )\n  end\n\n  # Add indexes for lookups\n  add_lookup_index(column) if column.column_type.in?(['lookup', 'user'])\n\n  # Add foreign key constraints\n  add_foreign_key(column) if column.column_type == 'lookup'\nend\n\ndef column_options(column)\n  opts = {}\n  opts[:limit] = column.max_length if column.column_type.ends_with?('text')\n  opts[:precision] = 15 if column.column_type.in?(['number', 'currency', 'percentage'])\n  opts[:scale] = 2 if column.column_type.in?(['number', 'currency', 'percentage'])\n  opts[:null] = !column.required\n  opts[:default] = column.default_value if column.default_value.present?\n  opts\nend TRAPID_BIBLE.md RULE #18.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.2",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# Column Types → Database Types\nCOLUMN_TYPE_MAPPINGS = {\n  'single_line_text' => :string,        # VARCHAR(255)\n  'multiple_lines_text' => :text,       # TEXT\n  'email' => :string,                   # VARCHAR with email validation\n  'phone' => :string,                   # VARCHAR with phone format\n  'url' => :string,                     # VARCHAR with URL validation\n  'number' => :decimal,                 # DECIMAL(15,2)\n  'whole_number' => :integer,           # INTEGER\n  'currency' => :decimal,               # DECIMAL(15,2)\n  'percentage' => :decimal,             # DECIMAL(15,2)\n  'date' => :date,                      # DATE\n  'date_and_time' => :datetime,         # TIMESTAMP\n  'boolean' => :boolean,                # BOOLEAN\n  'choice' => :string,                  # VARCHAR (single select)\n  'lookup' => :integer,                 # INTEGER (foreign key)\n  'multiple_lookups' => :text,          # TEXT (JSON array)\n  'user' => :integer,                   # INTEGER (FK to users)\n  'computed' => :string                 # VARCHAR (formula result)\n}\n\n# ---\n\n# app/services/table_builder.rb\ndef add_column(column)\n  db_type = COLUMN_TYPE_MAPPINGS[column.column_type]\n\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.add_column(\n      table.database_table_name,\n      column.column_name,\n      db_type,\n      **column_options(column)\n    )\n  end\n\n  # Add indexes for lookups\n  add_lookup_index(column) if column.column_type.in?(['lookup', 'user'])\n\n  # Add foreign key constraints\n  add_foreign_key(column) if column.column_type == 'lookup'\nend\n\ndef column_options(column)\n  opts = {}\n  opts[:limit] = column.max_length if column.column_type.ends_with?('text')\n  opts[:precision] = 15 if column.column_type.in?(['number', 'currency', 'percentage'])\n  opts[:scale] = 2 if column.column_type.in?(['number', 'currency', 'percentage'])\n  opts[:null] = !column.required\n  opts[:default] = column.default_value if column.default_value.present?\n  opts\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.2"
  },
  {
    "id": 227,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Lookup Column Pattern",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Lookup Column Pattern util  # app/models/table.rb\ndef inject_lookup_association(column)\n  return unless column.lookup_table_id.present?\n\n  target_table = Table.find(column.lookup_table_id)\n  target_class = target_table.name.classify\n\n  @dynamic_model.belongs_to column.column_name.to_sym,\n    class_name: target_class,\n    foreign_key: \"#{column.column_name}_id\",\n    optional: !column.required\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef build_lookup_cache(records, table)\n  cache = {}\n\n  table.columns.where(column_type: 'lookup').each do |column|\n    next unless column.lookup_table_id.present?\n\n    target_table = Table.find(column.lookup_table_id)\n    foreign_key = \"#{column.column_name}_id\"\n\n    # Collect all foreign key IDs\n    ids = records.map { |r| r.send(foreign_key) }.compact.uniq\n    next if ids.empty?\n\n    # Batch load related records\n    related_records = target_table.dynamic_model.where(id: ids).index_by(&:id)\n\n    cache[column.id] = {\n      records: related_records,\n      display_column: column.lookup_display_column || target_table.title_column\n    }\n  end\n\n  cache\nend\n\n# ---\n\n{\n  \"supplier\": {\n    \"id\": 5,\n    \"display\": \"ABC Building Supplies\"\n  }\n} TRAPID_BIBLE.md RULE #18.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.4",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/table.rb\ndef inject_lookup_association(column)\n  return unless column.lookup_table_id.present?\n\n  target_table = Table.find(column.lookup_table_id)\n  target_class = target_table.name.classify\n\n  @dynamic_model.belongs_to column.column_name.to_sym,\n    class_name: target_class,\n    foreign_key: \"#{column.column_name}_id\",\n    optional: !column.required\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef build_lookup_cache(records, table)\n  cache = {}\n\n  table.columns.where(column_type: 'lookup').each do |column|\n    next unless column.lookup_table_id.present?\n\n    target_table = Table.find(column.lookup_table_id)\n    foreign_key = \"#{column.column_name}_id\"\n\n    # Collect all foreign key IDs\n    ids = records.map { |r| r.send(foreign_key) }.compact.uniq\n    next if ids.empty?\n\n    # Batch load related records\n    related_records = target_table.dynamic_model.where(id: ids).index_by(&:id)\n\n    cache[column.id] = {\n      records: related_records,\n      display_column: column.lookup_display_column || target_table.title_column\n    }\n  end\n\n  cache\nend\n\n# ---\n\n{\n  \"supplier\": {\n    \"id\": 5,\n    \"display\": \"ABC Building Supplies\"\n  }\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.4"
  },
  {
    "id": 228,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Record CRUD with Formula Calculation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Record CRUD with Formula Calculation util  # app/controllers/api/v1/records_controller.rb\ndef create\n  record = @table.dynamic_model.new(record_params)\n\n  if record.save\n    # Calculate computed columns AFTER save (so ID exists for lookups)\n    update_computed_columns(record)\n\n    render json: record_to_json(record), status: :created\n  else\n    render json: { errors: record.errors.full_messages }, status: :unprocessable_entity\n  end\nend\n\ndef update_computed_columns(record)\n  computed_columns = @table.columns.where(column_type: 'computed')\n\n  computed_columns.each do |column|\n    formula = column.settings&.dig('formula')\n    next unless formula.present?\n\n    # Get current record data\n    record_data = record.attributes\n\n    # Evaluate formula\n    result = FormulaEvaluator.new.evaluate(\n      formula,\n      record_data,\n      column.has_cross_table_refs? ? record : nil\n    )\n\n    # Update computed field\n    record.update_column(column.column_name, result.to_s)\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef record_to_json(record)\n  json = record.attributes\n\n  @table.columns.each do |column|\n    case column.column_type\n    when 'computed'\n      # Parse string back to number\n      value = json[column.column_name]\n      json[column.column_name] = value.present? ? value.to_f : 0\n\n    when 'lookup'\n      # Replace FK with {id, display}\n      if lookup_cache[column.id]\n        id = json[\"#{column.column_name}_id\"]\n        related = lookup_cache[column.id][:records][id]\n        display_col = lookup_cache[column.id][:display_column]\n\n        json[column.column_name] = {\n          id: id,\n          display: related&.send(display_col) || 'Unknown'\n        }\n      end\n    end\n  end\n\n  json\nend TRAPID_BIBLE.md RULE #18.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.5",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/records_controller.rb\ndef create\n  record = @table.dynamic_model.new(record_params)\n\n  if record.save\n    # Calculate computed columns AFTER save (so ID exists for lookups)\n    update_computed_columns(record)\n\n    render json: record_to_json(record), status: :created\n  else\n    render json: { errors: record.errors.full_messages }, status: :unprocessable_entity\n  end\nend\n\ndef update_computed_columns(record)\n  computed_columns = @table.columns.where(column_type: 'computed')\n\n  computed_columns.each do |column|\n    formula = column.settings&.dig('formula')\n    next unless formula.present?\n\n    # Get current record data\n    record_data = record.attributes\n\n    # Evaluate formula\n    result = FormulaEvaluator.new.evaluate(\n      formula,\n      record_data,\n      column.has_cross_table_refs? ? record : nil\n    )\n\n    # Update computed field\n    record.update_column(column.column_name, result.to_s)\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef record_to_json(record)\n  json = record.attributes\n\n  @table.columns.each do |column|\n    case column.column_type\n    when 'computed'\n      # Parse string back to number\n      value = json[column.column_name]\n      json[column.column_name] = value.present? ? value.to_f : 0\n\n    when 'lookup'\n      # Replace FK with {id, display}\n      if lookup_cache[column.id]\n        id = json[\"#{column.column_name}_id\"]\n        related = lookup_cache[column.id][:records][id]\n        display_col = lookup_cache[column.id][:display_column]\n\n        json[column.column_name] = {\n          id: id,\n          display: related&.send(display_col) || 'Unknown'\n        }\n      end\n    end\n  end\n\n  json\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.5"
  },
  {
    "id": 229,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Table Deletion Safety",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Table Deletion Safety util  # app/controllers/api/v1/tables_controller.rb\ndef destroy\n  # Check 1: Is table marked as live?\n  if @table.is_live?\n    return render json: {\n      error: 'Cannot delete live table. Set is_live to false first.'\n    }, status: :unprocessable_entity\n  end\n\n  # Check 2: Does table have records?\n  record_count = @table.dynamic_model.count\n  if record_count > 0\n    return render json: {\n      error: \"Cannot delete table with #{record_count} records. Delete records first.\"\n    }, status: :unprocessable_entity\n  end\n\n  # Check 3: Do other tables reference this table?\n  referencing_columns = Column.where(lookup_table_id: @table.id)\n  if referencing_columns.any?\n    table_names = referencing_columns.map { |c| c.table.name }.uniq.join(', ')\n    return render json: {\n      error: \"Cannot delete. Referenced by lookup columns in: #{table_names}\"\n    }, status: :unprocessable_entity\n  end\n\n  # Safe to delete\n  TableBuilder.new(@table).drop_database_table\n  @table.destroy\n\n  head :no_content\nend\n\n# ---\n\n# app/services/table_builder.rb\ndef drop_database_table\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.drop_table(table.database_table_name, if_exists: true)\n  end\n\n  # Remove dynamic model from memory\n  class_name = table.name.classify\n  Object.send(:remove_const, class_name) if Object.const_defined?(class_name)\nend TRAPID_BIBLE.md RULE #18.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.6",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/controllers/api/v1/tables_controller.rb\ndef destroy\n  # Check 1: Is table marked as live?\n  if @table.is_live?\n    return render json: {\n      error: 'Cannot delete live table. Set is_live to false first.'\n    }, status: :unprocessable_entity\n  end\n\n  # Check 2: Does table have records?\n  record_count = @table.dynamic_model.count\n  if record_count > 0\n    return render json: {\n      error: \"Cannot delete table with #{record_count} records. Delete records first.\"\n    }, status: :unprocessable_entity\n  end\n\n  # Check 3: Do other tables reference this table?\n  referencing_columns = Column.where(lookup_table_id: @table.id)\n  if referencing_columns.any?\n    table_names = referencing_columns.map { |c| c.table.name }.uniq.join(', ')\n    return render json: {\n      error: \"Cannot delete. Referenced by lookup columns in: #{table_names}\"\n    }, status: :unprocessable_entity\n  end\n\n  # Safe to delete\n  TableBuilder.new(@table).drop_database_table\n  @table.destroy\n\n  head :no_content\nend\n\n# ---\n\n# app/services/table_builder.rb\ndef drop_database_table\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.drop_table(table.database_table_name, if_exists: true)\n  end\n\n  # Remove dynamic model from memory\n  class_name = table.name.classify\n  Object.send(:remove_const, class_name) if Object.const_defined?(class_name)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.6"
  },
  {
    "id": 230,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Column Validation Rules",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Column Validation Rules util  # app/models/column.rb\nvalidates :name, presence: true\nvalidates :column_name, presence: true, uniqueness: { scope: :table_id }\nvalidates :column_type, inclusion: { in: COLUMN_TYPES }\n\n# Type-specific validations\nvalidate :validate_max_length_for_text_columns\nvalidate :validate_min_max_for_numeric_columns\nvalidate :validate_lookup_table_exists\n\ndef validate_max_length_for_text_columns\n  return unless column_type.ends_with?('text')\n\n  if max_length.present? && max_length > 65535\n    errors.add(:max_length, 'cannot exceed 65,535 for text columns')\n  end\nend\n\ndef validate_min_max_for_numeric_columns\n  return unless column_type.in?(%w[number whole_number currency percentage])\n\n  if min_value.present? && max_value.present? && min_value > max_value\n    errors.add(:min_value, 'cannot be greater than max_value')\n  end\nend\n\ndef validate_lookup_table_exists\n  return unless column_type.in?(%w[lookup multiple_lookups])\n\n  if lookup_table_id.blank?\n    errors.add(:lookup_table_id, 'is required for lookup columns')\n  elsif !Table.exists?(lookup_table_id)\n    errors.add(:lookup_table_id, 'references non-existent table')\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef validate_record_data(record, params)\n  @table.columns.each do |column|\n    value = params[column.column_name]\n\n    # Required check\n    if column.required && value.blank?\n      record.errors.add(column.column_name, column.validation_message || 'is required')\n    end\n\n    # Type-specific validation\n    case column.column_type\n    when 'email'\n      unless value =~ URI::MailTo::EMAIL_REGEXP\n        record.errors.add(column.column_name, 'is not a valid email')\n      end\n    when 'url'\n      unless value =~ URI::DEFAULT_PARSER.make_regexp\n        record.errors.add(column.column_name, 'is not a valid URL')\n      end\n    when 'number', 'currency', 'percentage'\n      if column.min_value && value.to_f < column.min_value\n        record.errors.add(column.column_name, \"must be at least #{column.min_value}\")\n      end\n      if column.max_value && value.to_f > column.max_value\n        record.errors.add(column.column_name, \"cannot exceed #{column.max_value}\")\n      end\n    end\n  end\nend TRAPID_BIBLE.md RULE #18.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.7",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/models/column.rb\nvalidates :name, presence: true\nvalidates :column_name, presence: true, uniqueness: { scope: :table_id }\nvalidates :column_type, inclusion: { in: COLUMN_TYPES }\n\n# Type-specific validations\nvalidate :validate_max_length_for_text_columns\nvalidate :validate_min_max_for_numeric_columns\nvalidate :validate_lookup_table_exists\n\ndef validate_max_length_for_text_columns\n  return unless column_type.ends_with?('text')\n\n  if max_length.present? && max_length > 65535\n    errors.add(:max_length, 'cannot exceed 65,535 for text columns')\n  end\nend\n\ndef validate_min_max_for_numeric_columns\n  return unless column_type.in?(%w[number whole_number currency percentage])\n\n  if min_value.present? && max_value.present? && min_value > max_value\n    errors.add(:min_value, 'cannot be greater than max_value')\n  end\nend\n\ndef validate_lookup_table_exists\n  return unless column_type.in?(%w[lookup multiple_lookups])\n\n  if lookup_table_id.blank?\n    errors.add(:lookup_table_id, 'is required for lookup columns')\n  elsif !Table.exists?(lookup_table_id)\n    errors.add(:lookup_table_id, 'references non-existent table')\n  end\nend\n\n# ---\n\n# app/controllers/api/v1/records_controller.rb\ndef validate_record_data(record, params)\n  @table.columns.each do |column|\n    value = params[column.column_name]\n\n    # Required check\n    if column.required && value.blank?\n      record.errors.add(column.column_name, column.validation_message || 'is required')\n    end\n\n    # Type-specific validation\n    case column.column_type\n    when 'email'\n      unless value =~ URI::MailTo::EMAIL_REGEXP\n        record.errors.add(column.column_name, 'is not a valid email')\n      end\n    when 'url'\n      unless value =~ URI::DEFAULT_PARSER.make_regexp\n        record.errors.add(column.column_name, 'is not a valid URL')\n      end\n    when 'number', 'currency', 'percentage'\n      if column.min_value && value.to_f < column.min_value\n        record.errors.add(column.column_name, \"must be at least #{column.min_value}\")\n      end\n      if column.max_value && value.to_f > column.max_value\n        record.errors.add(column.column_name, \"cannot exceed #{column.max_value}\")\n      end\n    end\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.7"
  },
  {
    "id": 231,
    "chapter_number": 18,
    "chapter_name": "Custom Tables & Formulas",
    "component": null,
    "title": "Foreign Key Constraints",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Foreign Key Constraints component  # app/services/table_builder.rb\ndef add_foreign_key(column)\n  return unless column.column_type == 'lookup'\n  return unless column.lookup_table_id.present?\n\n  target_table = Table.find(column.lookup_table_id)\n\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.add_foreign_key(\n      table.database_table_name,\n      target_table.database_table_name,\n      column: \"#{column.column_name}_id\",\n      on_delete: :nullify  # Don't cascade delete\n    )\n  end\nend TRAPID_BIBLE.md RULE #18.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "18.8",
    "difficulty": "intermediate",
    "summary": "",
    "code_example": "# app/services/table_builder.rb\ndef add_foreign_key(column)\n  return unless column.column_type == 'lookup'\n  return unless column.lookup_table_id.present?\n\n  target_table = Table.find(column.lookup_table_id)\n\n  ActiveRecord::Migration.suppress_messages do\n    ActiveRecord::Migration.add_foreign_key(\n      table.database_table_name,\n      target_table.database_table_name,\n      column: \"#{column.column_name}_id\",\n      on_delete: :nullify  # Don't cascade delete\n    )\n  end\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #18.8"
  },
  {
    "id": 232,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Agent Definitions Are Database-Driven",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Definitions Are Database-Driven integration - Store all agent metadata in database - Update run history after each agent execution - Use API endpoints to manage agents - Track success/failure rates - Maintain agent priority order # Record successful agent run\nagent = AgentDefinition.find_by(agent_id: 'backend-developer')\nagent.record_success(\n  \"Created API endpoint successfully\",\n  {\n    files_created: 3,\n    tests_passed: true,\n    duration_seconds: 45\n  }\n)\n\n# Record failed agent run\nagent.record_failure(\n  \"Migration failed with syntax error\",\n  {\n    error_type: \"SyntaxError\",\n    error_message: \"unexpected token\",\n    file: \"db/migrate/...\",\n    line: 12\n  }\n) TRAPID_BIBLE.md RULE #20.1",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.1",
    "difficulty": "intermediate",
    "summary": "- Store all agent metadata in database - Update run history after each agent execution - Use API endpoints to manage agents - Track success/failure rates - Maintain agent priority order",
    "code_example": "# Record successful agent run\nagent = AgentDefinition.find_by(agent_id: 'backend-developer')\nagent.record_success(\n  \"Created API endpoint successfully\",\n  {\n    files_created: 3,\n    tests_passed: true,\n    duration_seconds: 45\n  }\n)\n\n# Record failed agent run\nagent.record_failure(\n  \"Migration failed with syntax error\",\n  {\n    error_type: \"SyntaxError\",\n    error_message: \"unexpected token\",\n    file: \"db/migrate/...\",\n    line: 12\n  }\n)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.1"
  },
  {
    "id": 233,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Agent Invocation Protocol",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Invocation Protocol util - Check if agent exists and is active - Record run start timestamp - Execute agent task - Record success or failure with details - Return comprehensive result // 1. User types shortcut\n\"backend dev\"\n\n// 2. Claude Code reads agent definition\nconst agent = await fetch('/api/v1/agent_definitions/backend-developer')\n\n// 3. Execute agent task\nconst result = await Task({\n  subagent_type: 'general-purpose',\n  prompt: agent.purpose + \"\\n\\n\" + userRequest,\n  model: agent.model\n})\n\n// 4. Record result\nawait fetch(`/api/v1/agent_definitions/backend-developer/record_run`, {\n  method: 'POST',\n  body: {\n    status: result.success ? 'success' : 'failure',\n    message: result.message,\n    details: result.details\n  }\n}) TRAPID_BIBLE.md RULE #20.2",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.2",
    "difficulty": "intermediate",
    "summary": "- Check if agent exists and is active - Record run start timestamp - Execute agent task - Record success or failure with details - Return comprehensive result",
    "code_example": "// 1. User types shortcut\n\"backend dev\"\n\n// 2. Claude Code reads agent definition\nconst agent = await fetch('/api/v1/agent_definitions/backend-developer')\n\n// 3. Execute agent task\nconst result = await Task({\n  subagent_type: 'general-purpose',\n  prompt: agent.purpose + \"\\n\\n\" + userRequest,\n  model: agent.model\n})\n\n// 4. Record result\nawait fetch(`/api/v1/agent_definitions/backend-developer/record_run`, {\n  method: 'POST',\n  body: {\n    status: result.success ? 'success' : 'failure',\n    message: result.message,\n    details: result.details\n  }\n})",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.2"
  },
  {
    "id": 234,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Run History Tracking",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Run History Tracking feature - Record total_runs, successful_runs, failed_runs - Store last_run_at timestamp - Save last_status and last_message - Include detailed last_run_details (JSONB) - Calculate success_rate automatically # agent_definitions table\ntotal_runs: 0\nsuccessful_runs: 0\nfailed_runs: 0\nlast_run_at: nil\nlast_status: 'success' | 'failure' | 'error'\nlast_message: \"Completed successfully\"\nlast_run_details: {\n  duration_seconds: 45,\n  files_modified: 3,\n  tests_passed: true\n}\n\n# ---\n\ndef success_rate\n  return 0 if total_runs.zero?\n  (successful_runs.to_f / total_runs * 100).round(1)\nend TRAPID_BIBLE.md RULE #20.3",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "feature",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.3",
    "difficulty": "intermediate",
    "summary": "- Record total_runs, successful_runs, failed_runs - Store last_run_at timestamp - Save last_status and last_message - Include detailed last_run_details (JSONB) - Calculate success_rate automatically",
    "code_example": "# agent_definitions table\ntotal_runs: 0\nsuccessful_runs: 0\nfailed_runs: 0\nlast_run_at: nil\nlast_status: 'success' | 'failure' | 'error'\nlast_message: \"Completed successfully\"\nlast_run_details: {\n  duration_seconds: 45,\n  files_modified: 3,\n  tests_passed: true\n}\n\n# ---\n\ndef success_rate\n  return 0 if total_runs.zero?\n  (successful_runs.to_f / total_runs * 100).round(1)\nend",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.3"
  },
  {
    "id": 235,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Agent Types and Specialization",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Types and Specialization integration - Assign agent_type: `development`, `diagnostic`, `deployment`, or `planning` - Define clear focus area (e.g., \"Rails API Backend Development\") - Specify tools available to agent - Document when to us # Gantt Bug Hunter - Highly specialized\nagent_type: 'diagnostic'\nfocus: 'Gantt Chart & Schedule Master Bug Diagnosis'\nwhen_to_use: 'Gantt-related bugs ONLY'\n\n# Production Bug Hunter - General purpose\nagent_type: 'diagnostic'\nfocus: 'General Production Bug Diagnosis & Resolution'\nwhen_to_use: 'All non-Gantt production bugs' TRAPID_BIBLE.md RULE #20.4",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.4",
    "difficulty": "intermediate",
    "summary": "- Assign agent_type: `development`, `diagnostic`, `deployment`, or `planning` - Define clear focus area (e.g., \"Rails API Backend Development\") - Specify tools available to agent - Document when to us",
    "code_example": "# Gantt Bug Hunter - Highly specialized\nagent_type: 'diagnostic'\nfocus: 'Gantt Chart & Schedule Master Bug Diagnosis'\nwhen_to_use: 'Gantt-related bugs ONLY'\n\n# Production Bug Hunter - General purpose\nagent_type: 'diagnostic'\nfocus: 'General Production Bug Diagnosis & Resolution'\nwhen_to_use: 'All non-Gantt production bugs'",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.4"
  },
  {
    "id": 236,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Agent Priority and Display Order",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Priority and Display Order util - Set priority field (0-100) - Display agents sorted by: priority DESC, name ASC - Show active agents first - Hide inactive agents from main list 100 - Critical development agents (backend-developer)\n90  - Essential development agents (frontend-developer)\n85  - Specialized diagnostic agents (gantt-bug-hunter)\n80  - General diagnostic agents (production-bug-hunter)\n70  - Deployment agents (deploy-manager)\n60  - Planning agents (planning-collaborator)\n0   - Default (new agents) TRAPID_BIBLE.md RULE #20.5",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.5",
    "difficulty": "intermediate",
    "summary": "- Set priority field (0-100) - Display agents sorted by: priority DESC, name ASC - Show active agents first - Hide inactive agents from main list",
    "code_example": "100 - Critical development agents (backend-developer)\n90  - Essential development agents (frontend-developer)\n85  - Specialized diagnostic agents (gantt-bug-hunter)\n80  - General diagnostic agents (production-bug-hunter)\n70  - Deployment agents (deploy-manager)\n60  - Planning agents (planning-collaborator)\n0   - Default (new agents)",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.5"
  },
  {
    "id": 237,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Agent Shortcuts and Invocation",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Agent Shortcuts and Invocation util - Support `run {agent-id}` (e.g., `run backend-developer`) - Support shortened versions (e.g., `backend dev`, `gantt`) - Document shortcuts in `example_invocations` field - Parse user input case-insen backend-developer:\n  - \"backend dev\"\n  - \"run backend-developer\"\n  - \"run backend\"\n\nfrontend-developer:\n  - \"frontend dev\"\n  - \"run frontend-developer\"\n  - \"run frontend\"\n\ngantt-bug-hunter:\n  - \"gantt\"\n  - \"gantt bug hunter\"\n  - \"run gantt-bug-hunter\"\n\ndeploy-manager:\n  - \"deploy\"\n  - \"run deploy-manager\"\n  - \"run deploy\"\n\nproduction-bug-hunter:\n  - \"production bug hunter\"\n  - \"bug hunter\"\n  - \"run production-bug-hunter\"\n\nplanning-collaborator:\n  - \"plan\"\n  - \"run planning-collaborator\"\n  - \"run planner\" TRAPID_BIBLE.md RULE #20.6",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.6",
    "difficulty": "intermediate",
    "summary": "- Support `run {agent-id}` (e.g., `run backend-developer`) - Support shortened versions (e.g., `backend dev`, `gantt`) - Document shortcuts in `example_invocations` field - Parse user input case-insen",
    "code_example": "backend-developer:\n  - \"backend dev\"\n  - \"run backend-developer\"\n  - \"run backend\"\n\nfrontend-developer:\n  - \"frontend dev\"\n  - \"run frontend-developer\"\n  - \"run frontend\"\n\ngantt-bug-hunter:\n  - \"gantt\"\n  - \"gantt bug hunter\"\n  - \"run gantt-bug-hunter\"\n\ndeploy-manager:\n  - \"deploy\"\n  - \"run deploy-manager\"\n  - \"run deploy\"\n\nproduction-bug-hunter:\n  - \"production bug hunter\"\n  - \"bug hunter\"\n  - \"run production-bug-hunter\"\n\nplanning-collaborator:\n  - \"plan\"\n  - \"run planning-collaborator\"\n  - \"run planner\"",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.6"
  },
  {
    "id": 238,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Recently Run Check (Smart Testing)",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Recently Run Check (Smart Testing) util - Check `last_run_at` timestamp - Compare to threshold (e.g., 60 minutes) - Skip redundant tests if recent successful run - ALWAYS re-run if last run failed - Ask user if uncertain # In AgentDefinition model\ndef recently_run?(minutes = 60)\n  return false if last_run_at.nil?\n  return false if last_status != 'success'\n  last_run_at > minutes.minutes.ago\nend\n\n# ---\n\n// Gantt Bug Hunter protocol\nconst agent = await getAgent('gantt-bug-hunter')\n\nif (agent.recently_run(60)) {\n  console.log(`⏭️ Tests skipped (last successful run was ${minutesAgo} minutes ago)`)\n  console.log(`Using cached results from ${agent.last_run_at}`)\n  // Proceed with static analysis only\n} else {\n  console.log(`🧪 Running full test suite (last run: ${agent.last_run_at || 'Never'})`)\n  // Run all 12 automated tests\n} TRAPID_BIBLE.md RULE #20.7",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "util",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.7",
    "difficulty": "intermediate",
    "summary": "- Check `last_run_at` timestamp - Compare to threshold (e.g., 60 minutes) - Skip redundant tests if recent successful run - ALWAYS re-run if last run failed - Ask user if uncertain",
    "code_example": "# In AgentDefinition model\ndef recently_run?(minutes = 60)\n  return false if last_run_at.nil?\n  return false if last_status != 'success'\n  last_run_at > minutes.minutes.ago\nend\n\n# ---\n\n// Gantt Bug Hunter protocol\nconst agent = await getAgent('gantt-bug-hunter')\n\nif (agent.recently_run(60)) {\n  console.log(`⏭️ Tests skipped (last successful run was ${minutesAgo} minutes ago)`)\n  console.log(`Using cached results from ${agent.last_run_at}`)\n  // Proceed with static analysis only\n} else {\n  console.log(`🧪 Running full test suite (last run: ${agent.last_run_at || 'Never'})`)\n  // Run all 12 automated tests\n}",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.7"
  },
  {
    "id": 239,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Shortcut Clarity - AgentShortcutsTab Updates",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Shortcut Clarity - AgentShortcutsTab Updates component - Update `frontend/src/components/settings/AgentShortcutsTab.jsx` when adding new shortcuts - Add new shortcuts to the `baseCommands` array - Ensure shortcuts match agent file definitions exactly - Us // Adding new agent shortcut\nconst baseCommands = [\n  // ... existing shortcuts ...\n  { id: 8, command: 'Run UI Compliance Auditor agent', shortcut: 'ui audit, run ui-compliance-auditor, ui compliance' },\n  // ... more shortcuts ...\n] TRAPID_BIBLE.md RULE #20.8",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "component",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.8",
    "difficulty": "intermediate",
    "summary": "- Update `frontend/src/components/settings/AgentShortcutsTab.jsx` when adding new shortcuts - Add new shortcuts to the `baseCommands` array - Ensure shortcuts match agent file definitions exactly - Us",
    "code_example": "// Adding new agent shortcut\nconst baseCommands = [\n  // ... existing shortcuts ...\n  { id: 8, command: 'Run UI Compliance Auditor agent', shortcut: 'ui audit, run ui-compliance-auditor, ui compliance' },\n  // ... more shortcuts ...\n]",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.8"
  },
  {
    "id": 240,
    "chapter_number": 20,
    "chapter_name": "Agent System & Automation",
    "component": null,
    "title": "Creating New Agents - Complete Checklist",
    "status": "open",
    "severity": "medium",
    "first_reported": null,
    "last_occurred": null,
    "fixed_date": null,
    "scenario": null,
    "root_cause": null,
    "solution": null,
    "prevention": null,
    "metadata": {},
    "search_text": "Creating New Agents - Complete Checklist integration 1. \"agent-id\": {\n     \"total_runs\": 0,\n     \"successful_runs\": 0,\n     \"failed_runs\": 0,\n     \"last_run\": null,\n     \"last_status\": null,\n     \"last_message\": null,\n     \"runs\": []\n   }\n\n# ---\n\n# 1. backend/db/seeds/agent_definitions.rb\n{\n  agent_id: 'ui-compliance-auditor',\n  name: 'UI Compliance Auditor',\n  agent_type: 'diagnostic',\n  focus: 'Table UI Compliance & RULE #19 Standards',\n  model: 'sonnet',\n  purpose: 'Audits UI components for RULE #19 compliance...',\n  # ... other fields\n}\n\n# ---\n\n# 2. backend/app/controllers/api/v1/agents_controller.rb\nagents: {\n  'backend-developer': default_agent_stats,\n  # ... other agents\n  'ui-compliance-auditor': default_agent_stats\n}\n\n# ---\n\n// 3. .claude/agents/run-history.json\n{\n  \"agents\": {\n    \"ui-compliance-auditor\": {\n      \"total_runs\": 0,\n      \"successful_runs\": 0,\n      \"failed_runs\": 0,\n      \"last_run\": null,\n      \"last_status\": null,\n      \"last_message\": null,\n      \"runs\": []\n    }\n  }\n}\n\n# ---\n\n// 4. frontend/src/components/settings/AgentStatus.jsx\nconst getAgentIcon = (agentName) => {\n  const icons = {\n    'ui-compliance-auditor': '✅',\n    // ... other agents\n  };\n}; TRAPID_BIBLE.md RULE #20.9",
    "created_at": "2025-11-17 08:08:23 +1000",
    "updated_at": "2025-11-17 08:08:23 +1000",
    "entry_type": "integration",
    "description": null,
    "details": null,
    "examples": null,
    "recommendations": null,
    "rule_reference": null,
    "section_number": "20.9",
    "difficulty": "intermediate",
    "summary": "1.",
    "code_example": "\"agent-id\": {\n     \"total_runs\": 0,\n     \"successful_runs\": 0,\n     \"failed_runs\": 0,\n     \"last_run\": null,\n     \"last_status\": null,\n     \"last_message\": null,\n     \"runs\": []\n   }\n\n# ---\n\n# 1. backend/db/seeds/agent_definitions.rb\n{\n  agent_id: 'ui-compliance-auditor',\n  name: 'UI Compliance Auditor',\n  agent_type: 'diagnostic',\n  focus: 'Table UI Compliance & RULE #19 Standards',\n  model: 'sonnet',\n  purpose: 'Audits UI components for RULE #19 compliance...',\n  # ... other fields\n}\n\n# ---\n\n# 2. backend/app/controllers/api/v1/agents_controller.rb\nagents: {\n  'backend-developer': default_agent_stats,\n  # ... other agents\n  'ui-compliance-auditor': default_agent_stats\n}\n\n# ---\n\n// 3. .claude/agents/run-history.json\n{\n  \"agents\": {\n    \"ui-compliance-auditor\": {\n      \"total_runs\": 0,\n      \"successful_runs\": 0,\n      \"failed_runs\": 0,\n      \"last_run\": null,\n      \"last_status\": null,\n      \"last_message\": null,\n      \"runs\": []\n    }\n  }\n}\n\n# ---\n\n// 4. frontend/src/components/settings/AgentStatus.jsx\nconst getAgentIcon = (agentName) => {\n  const icons = {\n    'ui-compliance-auditor': '✅',\n    // ... other agents\n  };\n};",
    "common_mistakes": null,
    "testing_strategy": null,
    "related_rules": "TRAPID_BIBLE.md RULE #20.9"
  }
]