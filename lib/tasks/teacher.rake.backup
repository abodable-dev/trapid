# frozen_string_literal: true

namespace :trapid do
  desc 'Import Teacher markdown file to database (one-time migration)'
  task import_teacher: :environment do
    puts 'üîß Importing Teacher from TRAPID_TEACHER.md to database...'
    puts ''

    file_path = Rails.root.join('..', 'TRAPID_DOCS', 'TRAPID_TEACHER.md')
    unless File.exist?(file_path)
      puts "‚ùå File not found: #{file_path}"
      exit 1
    end

    content = File.read(file_path)
    lines = content.split("\n")

    imported_count = 0
    current_chapter = nil
    current_section_lines = []
    current_section_header = nil

    # Helper to extract subsection content
    extract_subsection = lambda do |text, heading|
      # Match ### Heading until next ### or end
      pattern = /###\s+#{Regexp.escape(heading)}\s*\n(.*?)(?=\n###|\z)/m
      match = text.match(pattern)
      match ? match[1].strip : nil
    end

    # Process each section
    process_section = lambda do
      return if current_section_header.nil? || current_section_lines.empty?

      # Parse section header: ## ¬ßX.Y: Title
      match = current_section_header.match(/^##\s+¬ß([\d.A-Z]+):\s*(.+)$/)
      return unless match

      section_number = match[1]
      pattern_title = match[2].strip

      # Determine chapter from section number
      chapter_num = section_number.split('.').first.to_i

      # Parse content
      content_text = current_section_lines.join("\n")

      # Extract Bible reference
      bible_ref_match = content_text.match(/üìñ\s+\*\*Bible Rule:\*\*\s+(.+?)(?:\n|$)/i)
      bible_rule_reference = bible_ref_match ? bible_ref_match[1].strip : nil

      # Extract subsections
      quick_start = extract_subsection.call(content_text, 'Quick Start')
      full_implementation = extract_subsection.call(content_text, 'Full Implementation')
      architecture = extract_subsection.call(content_text, 'Architecture')
      common_mistakes = extract_subsection.call(content_text, 'Common Mistakes')
      testing = extract_subsection.call(content_text, 'Testing')
      migration_guide = extract_subsection.call(content_text, 'Migration Guide')
      integration = extract_subsection.call(content_text, 'Integration')

      # Extract other subsections as notes
      notes_sections = []
      notes_sections << extract_subsection.call(content_text, 'Response Structure')
      notes_sections << extract_subsection.call(content_text, 'Frontend Pattern')
      notes_sections << extract_subsection.call(content_text, 'Notes')
      notes = notes_sections.compact.join("\n\n").strip
      notes = nil if notes.empty?

      # Extract code examples and languages
      code_examples = []
      languages = []
      content_text.scan(/```(\w+)\n(.*?)```/m) do |lang, code|
        languages << lang unless languages.include?(lang)
        code_examples << {
          language: lang,
          code: code.strip,
          description: 'Code Example'
        }
      end

      # Determine complexity
      total_size = [quick_start, full_implementation, architecture].compact.join.length
      complexity = total_size < 500 ? 'simple' : (total_size < 2000 ? 'medium' : 'complex')

      # Extract tags
      tags = []
      tags << 'api' if pattern_title.downcase.include?('api')
      tags << 'database' if pattern_title.downcase.include?('database') || pattern_title.downcase.include?('migration')
      tags << 'ui' if chapter_num == 19
      tags << 'documentation' if pattern_title.downcase.include?('documentation')

      # Chapter names
      chapter_names = {
        0 => 'System-Wide Patterns',
        19 => 'UI/UX Standards & Patterns'
      }

      # Create pattern
      pattern = ImplementationPattern.find_or_initialize_by(
        chapter_number: chapter_num,
        section_number: section_number
      )

      pattern.assign_attributes(
        chapter_name: chapter_names[chapter_num] || "Chapter #{chapter_num}",
        pattern_title: pattern_title,
        bible_rule_reference: bible_rule_reference,
        quick_start: quick_start,
        full_implementation: full_implementation,
        architecture: architecture,
        common_mistakes: common_mistakes,
        testing: testing,
        migration_guide: migration_guide,
        integration: integration,
        notes: notes,
        code_examples: code_examples,
        complexity: complexity,
        languages: languages.uniq,
        tags: tags.uniq
      )

      if pattern.save
        puts "  ‚úÖ ¬ß#{section_number}: #{pattern_title}"
        imported_count += 1
      else
        puts "  ‚ùå Failed to save ¬ß#{section_number}: #{pattern.errors.full_messages.join(', ')}"
      end
    end

    # Parse file line by line
    lines.each do |line|
      if line =~ /^## ¬ß/
        # Process previous section
        process_section.call

        # Start new section
        current_section_header = line
        current_section_lines = []
      elsif current_section_header
        # Collecting section content
        current_section_lines << line
      end
    end

    # Process last section
    process_section.call

    puts ''
    puts "‚úÖ Imported #{imported_count} implementation patterns"
    puts ''
    puts 'üí° Next step: Run `rake trapid:export_teacher` to verify the export'
  end

  desc 'Export Teacher database to TRAPID_TEACHER.md'
  task export_teacher: :environment do
    puts 'üîß Exporting Teacher database to markdown...'

    # Build markdown content
    content = []

    # Header
    content << '# TRAPID TEACHER - Implementation Patterns & Code Examples'
    content << ''
    content << '**Version:** 1.0.0'
    content << "**Last Updated:** #{Time.current.strftime('%Y-%m-%d %H:%M %Z')}"
    content << '**Authority Level:** Reference (implements Bible rules)'
    content << '**Audience:** Claude Code + Human Developers'
    content << ''
    content << '---'
    content << ''
    content << '## üî¥ CRITICAL: Read This First'
    content << ''
    content << '### This Document is "The Teacher"'
    content << ''
    content << 'This file contains **implementation patterns and code examples** for Trapid development.'
    content << ''
    content << '**This Teacher Contains CODE EXAMPLES ONLY:**'
    content << '- üîß Implementation patterns (how to implement features)'
    content << '- üìù Quick start guides (minimal code to get started)'
    content << '- üíª Full implementations (production-ready code with comments)'
    content << '- ‚ö†Ô∏è  Common mistakes (what NOT to do)'
    content << '- üß™ Test examples (how to test the code)'
    content << ''
    content << '**For RULES (MUST/NEVER/ALWAYS):**'
    content << '- üìñ See [TRAPID_BIBLE.md](TRAPID_BIBLE.md)'
    content << ''
    content << '**For BUG HISTORY & KNOWLEDGE:**'
    content << '- üìï See [TRAPID_LEXICON.md](TRAPID_LEXICON.md)'
    content << ''
    content << '**For USER GUIDES (how to use features):**'
    content << '- üìò See [TRAPID_USER_MANUAL.md](TRAPID_USER_MANUAL.md)'
    content << ''
    content << '---'
    content << ''
    content << '## üíæ Database-Driven Teacher'
    content << ''
    content << '**IMPORTANT:** This file is auto-generated from the `implementation_patterns` database table.'
    content << ''
    content << '**To edit entries:**'
    content << '1. Go to Documentation page in Trapid'
    content << '2. Click "üîß TRAPID Teacher"'
    content << '3. Use the UI to add/edit/delete patterns'
    content << '4. Run `rake trapid:export_teacher` to update this file'
    content << ''
    content << '**Single Source of Truth:** Database (not this file)'
    content << ''
    content << '---'
    content << ''
    content << '## Table of Contents'
    content << ''

    # Get all chapters
    chapters = ImplementationPattern.select(:chapter_number, :chapter_name)
                                    .distinct
                                    .order(:chapter_number)

    chapters.each do |chapter|
      content << "- [Chapter #{chapter.chapter_number}: #{chapter.chapter_name}](#chapter-#{chapter.chapter_number}-#{chapter.chapter_name.downcase.gsub(/[^a-z0-9]+/, '-')})"
    end

    content << ''
    content << '---'
    content << ''

    # Generate content for each chapter
    chapters.each do |chapter|
      content << ''
      content << "# Chapter #{chapter.chapter_number}: #{chapter.chapter_name}"
      content << ''
      content << '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê'
      content << "‚îÇ üìñ BIBLE (RULES):     Chapter #{chapter.chapter_number.to_s.rjust(2)}               ‚îÇ"
      content << "‚îÇ üìï LEXICON (BUGS):    Chapter #{chapter.chapter_number.to_s.rjust(2)}               ‚îÇ"
      content << "‚îÇ üìò USER MANUAL (HOW): Chapter #{chapter.chapter_number.to_s.rjust(2)}               ‚îÇ"
      content << '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò'
      content << ''
      content << '**Audience:** Claude Code + Human Developers'
      content << '**Purpose:** Code examples and implementation patterns'
      content << "**Last Updated:** #{Time.current.strftime('%Y-%m-%d')}"
      content << ''
      content << '---'
      content << ''

      # Get patterns for this chapter, ordered by section number
      patterns = ImplementationPattern.where(chapter_number: chapter.chapter_number)
                                      .order(:section_number)

      patterns.each do |pattern|
        # Section header
        content << "## ¬ß#{pattern.section_number} #{pattern.pattern_title}"
        content << ''

        # Complexity and Bible cross-reference
        metadata_parts = []
        metadata_parts << "**Complexity:** #{pattern.complexity_display}"
        metadata_parts << "**Bible Cross-Reference:** #{pattern.bible_rule_reference}" if pattern.bible_rule_reference.present?

        if metadata_parts.any?
          content << metadata_parts.join(' | ')
          content << ''
        end

        # Languages and tags
        if pattern.languages.present? && pattern.languages.any?
          content << "**Languages:** #{pattern.languages.join(', ')}"
        end
        if pattern.tags.present? && pattern.tags.any?
          content << "**Tags:** #{pattern.tags.join(', ')}"
        end
        if pattern.languages.present? || pattern.tags.present?
          content << ''
        end

        # Quick Start
        if pattern.quick_start.present?
          content << '### Quick Start'
          content << ''
          content << pattern.quick_start
          content << ''
        end

        # Full Implementation
        if pattern.full_implementation.present?
          content << '### Full Implementation'
          content << ''
          content << pattern.full_implementation
          content << ''
        end

        # Architecture
        if pattern.architecture.present?
          content << '### Architecture'
          content << ''
          content << pattern.architecture
          content << ''
        end

        # Common Mistakes
        if pattern.common_mistakes.present?
          content << '### Common Mistakes'
          content << ''
          content << pattern.common_mistakes
          content << ''
        end

        # Testing
        if pattern.testing.present?
          content << '### Testing'
          content << ''
          content << pattern.testing
          content << ''
        end

        # Migration Guide
        if pattern.migration_guide.present?
          content << '### Migration Guide'
          content << ''
          content << pattern.migration_guide
          content << ''
        end

        # Integration
        if pattern.integration.present?
          content << '### Integration'
          content << ''
          content << pattern.integration
          content << ''
        end

        # Code Examples
        if pattern.code_examples.present? && pattern.code_examples.any?
          content << '### Code Examples'
          content << ''

          pattern.code_examples.each do |example|
            if example['description'].present?
              content << "**#{example['description']}**"
              content << ''
            end

            content << "```#{example['language']}"
            content << example['code']
            content << '```'
            content << ''
          end
        end

        # Notes
        if pattern.notes.present?
          content << '### Notes'
          content << ''
          content << pattern.notes
          content << ''
        end

        content << '---'
        content << ''
      end

      # Related chapters
      content << '## üìö Related Chapters'
      content << ''
      content << '_Links to related chapters will be added as cross-references are identified._'
      content << ''
      content << '---'
      content << ''
    end

    # Footer
    content << ''
    content << "**Last Generated:** #{Time.current.strftime('%Y-%m-%d %H:%M %Z')}"
    content << '**Generated By:** `rake trapid:export_teacher`'
    content << '**Maintained By:** Development Team via Database UI'
    content << '**Review Schedule:** After each new pattern or implementation update'

    # Write to file
    file_path = Rails.root.join('..', 'TRAPID_DOCS', 'TRAPID_TEACHER.md')
    File.write(file_path, content.join("\n"))

    total_patterns = ImplementationPattern.count
    puts "‚úÖ Exported #{total_patterns} patterns across #{chapters.count} chapters"
    puts "üìÑ File: #{file_path}"
    puts ''
    puts 'üí° Next steps:'
    puts '  1. Review the generated file'
    puts '  2. Commit to git: git add TRAPID_DOCS/TRAPID_TEACHER.md'
    puts '  3. Git commit message: "docs: Update Teacher from database export"'
  end
end
